<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实现简单的Tomcat服务器</title>
    <url>/2019/12/23/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、HTTP请求报文和响应报文"><a href="#一、HTTP请求报文和响应报文" class="headerlink" title="一、HTTP请求报文和响应报文"></a>一、HTTP请求报文和响应报文</h1><blockquote>
<p><a href="https://www.cnblogs.com/engeng/articles/5959335.html" target="_blank" rel="noopener">一次完整的HTTP请求过程</a><a href="https://www.cnblogs.com/engeng/articles/5959335.html" target="_blank" rel="noopener">https://www.cnblogs.com/engeng/articles/5959335.html</a></p>
</blockquote>
<h2 id="1、请求报文"><a href="#1、请求报文" class="headerlink" title="1、请求报文"></a>1、请求报文</h2><p>一个HTTP请求报文由请求行（request line）、请求头部（header）和请求数据3个部分组成。</p>
<p><img alt="img" data-src="http://img.mxranger.cn/20170707143243946.jpg" class="lazyload"></p>
<h3 id="1、请求行"><a href="#1、请求行" class="headerlink" title="1、请求行"></a>1、请求行</h3><p>三部分组成：请求方法，请求URL（不包括域名），HTTP协议版本</p>
<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>请求方法比较多：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</p>
<p>最常用的是GET和POST。</p>
<h4 id="HTTP协议版本"><a href="#HTTP协议版本" class="headerlink" title="HTTP协议版本"></a>HTTP协议版本</h4><p><strong>1）HTTP/1.0</strong></p>
<p>HTTP/1.0支持：GET、POST、HEAD三种HTTP请求方法。</p>
<p><strong>2）HTTP/1.1</strong></p>
<p>HTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。</p>
<p>HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。</p>
<h3 id="2、请求头"><a href="#2、请求头" class="headerlink" title="2、请求头"></a>2、请求头</h3><p>User-Agent : 产生请求的浏览器类型</p>
<p>Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型</p>
<p>Content-Type：发送端发送的实体数据的数据类型。<br> 比如，Content-Type：text/html（application/json）表示发送的是html类型。</p>
<p>Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</p>
<table>
<thead>
<tr>
<th align="center">Content-Type</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">text/html</td>
<td align="center">html格式</td>
</tr>
<tr>
<td align="center">text/plain</td>
<td align="center">纯文本格式</td>
</tr>
<tr>
<td align="center">text/css</td>
<td align="center">CSS格式</td>
</tr>
<tr>
<td align="center">text/javascript</td>
<td align="center">js格式</td>
</tr>
<tr>
<td align="center">image/gif</td>
<td align="center">gif图片格式</td>
</tr>
<tr>
<td align="center">image/jpeg</td>
<td align="center">jpg图片格式</td>
</tr>
<tr>
<td align="center">image/png</td>
<td align="center">png图片格式</td>
</tr>
<tr>
<td align="center">application/x-www-form-urlencoded</td>
<td align="center">POST专用：普通的表单提交默认是通过这种方式。form表单数据被编码为key/value格式发送到服务器。</td>
</tr>
<tr>
<td align="center">application/json</td>
<td align="center">POST专用：用来告诉服务端消息主体是序列化后的 JSON 字符串</td>
</tr>
<tr>
<td align="center">text/xml</td>
<td align="center">POST专用：发送xml数据</td>
</tr>
<tr>
<td align="center">multipart/form-data</td>
<td align="center">POST专用：下面讲解</td>
</tr>
</tbody></table>
<h3 id="3、请求数据"><a href="#3、请求数据" class="headerlink" title="3、请求数据"></a>3、请求数据</h3><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<p><span style="color:red"><strong>注意：请求头和请求体之间有空行</strong></span></p>
<p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h3 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h3><p>以百度首页为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName TestClient</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/5/14</span></span><br><span class="line"><span class="comment"> * Time      16:10</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当成浏览器客户端,发送请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[1] 建立一个socket对象，连接域名80端口</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">"www.baidu.com"</span>,<span class="number">80</span>);</span><br><span class="line">            <span class="comment">//[2]获取输出流对象</span></span><br><span class="line">            in = socket.getInputStream();</span><br><span class="line">            <span class="comment">//[3]获取输入流对象</span></span><br><span class="line">            out = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//[4] 将http协议的请求部分发送到服务端</span></span><br><span class="line">            <span class="comment">//请求行 /subject/about/index.html</span></span><br><span class="line">            out.write(<span class="string">"GET / HTTP/1.1\n"</span>.getBytes());</span><br><span class="line">            <span class="comment">//请求头</span></span><br><span class="line">            out.write(<span class="string">"HOST:www.baidu.com\n"</span>.getBytes());</span><br><span class="line">            out.write(<span class="string">"\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//[5]读取来自服务端的数据打印到控制台</span></span><br><span class="line">            <span class="keyword">int</span> i = in.read();</span><br><span class="line">            <span class="keyword">while</span> (i!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)i);</span><br><span class="line">                i = in.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//[6]释放资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>!=in)&#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                    in = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>!=out)&#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                    out = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>!=socket)&#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                    socket = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>以下是响应数据</p>
<p><img alt="1557931146895" data-src="http://img.mxranger.cn/1557931146895.png" class="lazyload"></p>
<h2 id="2、响应报文"><a href="#2、响应报文" class="headerlink" title="2、响应报文"></a>2、响应报文</h2><p>HTTP的响应报文也由三部分组成：<strong>响应行+响应头+响应体</strong></p>
<p><img alt="img" data-src="http://img.mxranger.cn/20170707145557633.jpg" class="lazyload"></p>
<h3 id="1、响应行"><a href="#1、响应行" class="headerlink" title="1、响应行"></a>1、响应行</h3><p>三部分组成：HTTP协议版本 、状态码和状态描述</p>
<p>HTTP的响应状态码由5段组成：</p>
<ul>
<li>1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急…</li>
<li>2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.</li>
<li>3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。</li>
<li>4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。</li>
<li>5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。</li>
</ul>
<p><strong>以下是几个常见的状态码：</strong><br><strong>200 OK</strong><br>你最希望看到的，即处理成功！<br><strong>303 See Other</strong><br>我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。<br><strong>304 Not Modified</strong><br>告诉客户端，你请求的这个资源至你上次取得后，并没有更改，你直接用你本地的缓存吧，我很忙哦，你能不能少来烦我啊！<br><strong>404 Not Found</strong><br>你最不希望看到的，即找不到页面。如你在google上找到一个页面，点击这个链接返回404，表示这个页面已经被网站删除了，google那边的记录只是美好的回忆。<br><strong>500 Internal Server Error</strong><br>看到这个错误，你就应该查查服务端的日志了，肯定抛出了一堆异常，别睡了，起来改BUG去吧！</p>
<h3 id="2、响应头"><a href="#2、响应头" class="headerlink" title="2、响应头"></a>2、响应头</h3><p>常见的几个</p>
<table>
<thead>
<tr>
<th>Connection</th>
<th>使用keep-alive特性</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Encoding</td>
<td>使用gzip方式对资源压缩</td>
</tr>
<tr>
<td>Content-type</td>
<td>MIME类型为html类型，字符集是 UTF-8</td>
</tr>
<tr>
<td>Date</td>
<td>响应的日期</td>
</tr>
<tr>
<td>Server</td>
<td>使用的WEB服务器</td>
</tr>
</tbody></table>
<h3 id="3、响应体"><a href="#3、响应体" class="headerlink" title="3、响应体"></a>3、响应体</h3><p>返回到浏览器显示的内容</p>
<h3 id="4、案例-1"><a href="#4、案例-1" class="headerlink" title="4、案例"></a>4、案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName TestServer</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/5/14</span></span><br><span class="line"><span class="comment"> * Time      16:26</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模拟服务端,接收浏览器请求返回响应数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//[1] 建立一个socket对象，监听本机的8080端口</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">               <span class="comment">//[2] 等待来自客户端的请求获取和客户端对应的Socket对象</span></span><br><span class="line">               socket = serverSocket.accept();</span><br><span class="line">               System.out.println(<span class="string">"socket:"</span>+socket.toString());</span><br><span class="line">               <span class="comment">//[3] 通过获取到的Socket对象获取到输出流对象</span></span><br><span class="line">               out = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//[4] 通过获取到的输出流对象将HTTP协议的相应部分发送到客户端</span></span><br><span class="line">               out.write(<span class="string">"HTTP/1.1 200 OK\n"</span>.getBytes());</span><br><span class="line">               out.write(<span class="string">"Content-Type:text/html;charset=utf-8\n"</span>.getBytes());</span><br><span class="line">               out.write(<span class="string">"Server:Apache-Coyote/1.1\n"</span>.getBytes());</span><br><span class="line">               <span class="comment">//响应头和响应组之前是有换行的</span></span><br><span class="line">               out.write(<span class="string">"\n\n"</span>.getBytes());</span><br><span class="line">               StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">               buf.append(<span class="string">"&lt;html&gt;&lt;/html&gt;"</span>);</span><br><span class="line">               buf.append(<span class="string">"&lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;"</span>);</span><br><span class="line">               buf.append(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">               buf.append(<span class="string">"&lt;h1&gt; hello world&lt;/h1&gt;"</span>);</span><br><span class="line">               buf.append(<span class="string">"&lt;a href='http://www.baidu.com'&gt;百度&lt;/a&gt;"</span>);</span><br><span class="line">               buf.append(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">               buf.append(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">               out.write(buf.toString().getBytes());</span><br><span class="line">               out.flush();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//[6]释放资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>!=out)&#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                    out = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>!=socket)&#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                    socket = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="to" data-src="http://img.mxranger.cn/to.gif" class="lazyload"></p>
<h1 id="二、实现简单的Tomcat服务器"><a href="#二、实现简单的Tomcat服务器" class="headerlink" title="二、实现简单的Tomcat服务器"></a>二、实现简单的Tomcat服务器</h1><p>大体流程如下：<br><img alt="无标题" data-src="http://img.mxranger.cn/%E6%97%A0%E6%A0%87%E9%A2%98.png" class="lazyload"></p>
<h2 id="1、编写Servlet接口"><a href="#1、编写Servlet接口" class="headerlink" title="1、编写Servlet接口"></a>1、编写Servlet接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.mytomcatV2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Servlet</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/5/15</span></span><br><span class="line"><span class="comment"> * Time      20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有服务端的java小程序都要实现的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//服务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Service</span><span class="params">(InputStream in, OutputStream out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、自定义两个Servlet实现类"><a href="#2、自定义两个Servlet实现类" class="headerlink" title="2、自定义两个Servlet实现类"></a>2、自定义两个Servlet实现类</h2><h3 id="1、AAServlet类"><a href="#1、AAServlet类" class="headerlink" title="1、AAServlet类"></a>1、AAServlet类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.mytomcatV2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName AAServlet</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/5/15</span></span><br><span class="line"><span class="comment"> * Time      20:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AAServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AAServlet...init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Service</span><span class="params">(InputStream in, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AAServlet...service"</span>);</span><br><span class="line">        out.write(<span class="string">"hello world AAServlet"</span>.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AAServlet...destory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、BBServlet类"><a href="#2、BBServlet类" class="headerlink" title="2、BBServlet类"></a>2、BBServlet类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.mytomcatV2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName AAServlet</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/5/15</span></span><br><span class="line"><span class="comment"> * Time      20:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BBServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BBServlet...init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Service</span><span class="params">(InputStream in, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BBServlet...service"</span>);</span><br><span class="line">        out.write(<span class="string">"hello world BBServlet"</span>.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BBServlet...destory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、编写conf-properties配置文件"><a href="#3、编写conf-properties配置文件" class="headerlink" title="3、编写conf.properties配置文件"></a>3、编写conf.properties配置文件</h2><p>用来URL与类路径一一配对</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">aa</span>=<span class="string">cn.mxranger.mytomcatV2.AAServlet</span></span><br><span class="line"><span class="attr">bb</span>=<span class="string">cn.mxranger.mytomcatV2.BBServlet</span></span><br></pre></td></tr></table></figure>

<h2 id="4、创建TestServer类"><a href="#4、创建TestServer类" class="headerlink" title="4、创建TestServer类"></a>4、创建TestServer类</h2><h3 id="1、定义变量"><a href="#1、定义变量" class="headerlink" title="1、定义变量"></a>1、定义变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、定义一个变量，存放服务端WebContent目录的绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String WEB_ROOT = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/WebContent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、定义静态变量，用于存放本次请求的静态页面名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、定义一个静态类型map，存储服务端conf.properties的配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="2、编写静态代码块"><a href="#2、编写静态代码块" class="headerlink" title="2、编写静态代码块"></a>2、编写静态代码块</h3><p>用来在服务器启动前加载配置文件到map中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="comment">//4、服务器启动之前将配置参数中的信息加载到map中</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//[1]创建一个Properties对象</span></span><br><span class="line">       Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//[2]加载WebContent目录下的conf.properties</span></span><br><span class="line">           prop.load(<span class="keyword">new</span> FileInputStream(WEB_ROOT+<span class="string">"/conf.properties"</span>));</span><br><span class="line"></span><br><span class="line">           <span class="comment">//[3]将配置文件中的数据读取到map中</span></span><br><span class="line">           Set set = prop.keySet();</span><br><span class="line">           Iterator iterator = set.iterator();</span><br><span class="line">           <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">               String key = (String) iterator.next();</span><br><span class="line">               String value = prop.getProperty(key);</span><br><span class="line">               map.put(key,value);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、截取资源名称"><a href="#3、截取资源名称" class="headerlink" title="3、截取资源名称"></a>3、截取资源名称</h3><p>将截取的资源名称放入url中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  获取HTTP协议的请求部分，截取客户端要访问的资源名称，将这个资源名称赋值给url</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存放HTTP协议谪求部分数据</span></span><br><span class="line">        StringBuffer content = <span class="keyword">new</span> StringBuffer(<span class="number">2048</span>);</span><br><span class="line">        <span class="comment">//定义一个数组，存放HTTP协议请求部分数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="comment">//定义一个变量i,代表读取数据到数组中之后，教据量的大小</span></span><br><span class="line">        <span class="keyword">int</span> i=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//读取客户端发送过来的数据，将数据读取到字节数组buffer中.i代表读取数据量的大小311字节</span></span><br><span class="line">        i = in.read(buffer);</span><br><span class="line">        <span class="comment">// 通历字节数组，将数组中的数据追加到content变量中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            content.append((<span class="keyword">char</span>)buffer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印HTTP协议请求部分数据</span></span><br><span class="line">        System.out.println(<span class="string">"content::"</span>+content);</span><br><span class="line">        <span class="comment">//截取客尸端要请求的资源路径demo.html，复制给url</span></span><br><span class="line">        parseUrl(content.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseUrl</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放请求行的2个空格的位置</span></span><br><span class="line">        <span class="keyword">int</span> index1,index2;</span><br><span class="line">        <span class="comment">//获取http请求部分第1空格的位置</span></span><br><span class="line">        index1 = content.indexOf(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(index1!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//获取http请求部分第2空格的位置</span></span><br><span class="line">            index2 = content.indexOf(<span class="string">" "</span>,index1 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(index2 &gt; index1)&#123;</span><br><span class="line">                <span class="comment">//截取客尸端要请求的资源名称</span></span><br><span class="line">                url = content.substring(index1 + <span class="number">2</span> , index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、访问静态资源"><a href="#4、访问静态资源" class="headerlink" title="4、访问静态资源"></a>4、访问静态资源</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 发送静态资源</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendStaticResource</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个字节数组，用于存放本次请求的静态资源demo01.html的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2018</span>];</span><br><span class="line">        <span class="comment">// 定义一个文件输入流，用户获取静态资源demoOl.html中的内容</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件对象File,代表本次要请求的资源demo01.html</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(WEB_ROOT,url);</span><br><span class="line">            <span class="comment">// 如果文件存在</span></span><br><span class="line">            <span class="keyword">if</span> (file.exists())&#123;</span><br><span class="line">                <span class="comment">//向客户端输出HTTP协议的响应行/响应头</span></span><br><span class="line">                out.write(<span class="string">"HTTP/1.1 200 OK\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html;charset=utf-8\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Server:Apache-Coyote/1.1\n"</span>.getBytes());</span><br><span class="line">                <span class="comment">//响应头和响应组之前是有换行的</span></span><br><span class="line">                out.write(<span class="string">"\n"</span>.getBytes());</span><br><span class="line">                <span class="comment">// 获取到文件输入流对象</span></span><br><span class="line">                fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                <span class="comment">//读取静态资源demo01.html中的内容到数组中</span></span><br><span class="line">                <span class="keyword">int</span> ch = fis.read(bytes);</span><br><span class="line">                <span class="keyword">while</span> (ch!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 将读取到数组中的内容通过输出流发送到客户端</span></span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,ch);</span><br><span class="line">                    ch = fis.read(bytes);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果文件不存在</span></span><br><span class="line">                <span class="comment">// 向客户端响应文件不存在消息</span></span><br><span class="line">                out.write(<span class="string">"HTTP/1.1 404 not found\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html;charset=utf-8\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Server:Apache-Coyote/1.1\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\n"</span>.getBytes());</span><br><span class="line">                String errMsg = <span class="string">"file not found"</span>;</span><br><span class="line">                out.write(errMsg.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放文件输入流对象</span></span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fis = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、访问动态资源"><a href="#5、访问动态资源" class="headerlink" title="5、访问动态资源"></a>5、访问动态资源</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 发送动态资源</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendDynamicResource</span><span class="params">(InputStream in, OutputStream out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//向客户端输出HTTP协议的响应行/响应头 发送到客户端</span></span><br><span class="line">    out.write(<span class="string">"HTTP/1.1 200 OK\n"</span>.getBytes());</span><br><span class="line">    out.write(<span class="string">"Content-Type:text/html;charset=utf-8\n"</span>.getBytes());</span><br><span class="line">    out.write(<span class="string">"Server:Apache\n"</span>.getBytes());</span><br><span class="line">    <span class="comment">//响应头和响应体之间是有换行的</span></span><br><span class="line">    out.write(<span class="string">"\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断map中是否存在一个key，这个key是否和本次带请求的资源路径一致</span></span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(url))&#123;</span><br><span class="line">        <span class="comment">//如果包含指定的key,获取到map中key对应的value部分</span></span><br><span class="line">        String value = map.get(url);</span><br><span class="line">        <span class="comment">//通过反射将对应的java程序加载内存</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(value);</span><br><span class="line">        Servlet servlet = (Servlet)clazz.newInstance();</span><br><span class="line">        <span class="comment">//执行init方法</span></span><br><span class="line">        servlet.init();</span><br><span class="line">        <span class="comment">//执行service方法</span></span><br><span class="line">        servlet.Service(in,out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、主函数"><a href="#6、主函数" class="headerlink" title="6、主函数"></a>6、主函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(WEB_ROOT);</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3、 建立一个socket对象，监听本机的8080端口</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//4、 等待来自客户端的请求获取和客户端对应的Socket对象</span></span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//System.out.println("socket:"+socket.toString());</span></span><br><span class="line">                <span class="comment">//5、 通过获取到的Socket对象获取到输入、输出流对象</span></span><br><span class="line">                out = socket.getOutputStream();</span><br><span class="line">                in = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//6、 获取HTTP协议的请求部分，截取客户端要访问的资源名称，将这个资源名称赋值给url</span></span><br><span class="line">                <span class="comment">//demo01.html or aa ?</span></span><br><span class="line">                <span class="comment">//判断本次请求的是静态demo.html还是运行在服务端的java小程序</span></span><br><span class="line">                parse(in);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>!=url)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (url.indexOf(<span class="string">"."</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">//发送静态资源文件</span></span><br><span class="line">                        <span class="comment">//7、发送静态资源</span></span><br><span class="line">                        sendStaticResource(out);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//发送动态资源</span></span><br><span class="line">                        sendDynamicResource(in,out);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//[6]释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=in)&#123;</span><br><span class="line">                in.close();</span><br><span class="line">                in = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=out)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=socket)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h2><p><img alt="tomcat" data-src="http://img.mxranger.cn/tomcat.gif" class="lazyload"></p>
<p>完整代码见<a href="https://github.com/GavinGrayer/MyTomcat" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2019/12/23/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h1><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="原型设计模式问题"><a href="#原型设计模式问题" class="headerlink" title="原型设计模式问题"></a>原型设计模式问题</h3><p><img alt="image-20191128144745969" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128144745969.png" class="lazyload"></p>
<p><img alt="image-20191128144821208" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128144821208.png" class="lazyload"></p>
<h3 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h3><p><img alt="image-20191128144904940" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128144904940.png" class="lazyload"></p>
<p><img alt="image-20191128153857871" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128153857871.png" class="lazyload"></p>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p><img alt="image-20191128145740872" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128145740872.png" class="lazyload"></p>
<h3 id="单例模式面试题"><a href="#单例模式面试题" class="headerlink" title="单例模式面试题"></a>单例模式面试题</h3><p><img alt="image-20191128145749532" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128145749532.png" class="lazyload"></p>
<h2 id="设计模式的重要性"><a href="#设计模式的重要性" class="headerlink" title="设计模式的重要性"></a>设计模式的重要性</h2><p><img alt="image-20191128153342274" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128153342274.png" class="lazyload"></p>
<p><img alt="image-20191128153353698" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128153353698.png" class="lazyload"></p>
<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="1、设计模式目的"><a href="#1、设计模式目的" class="headerlink" title="1、设计模式目的"></a>1、设计模式目的</h2><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好</p>
<ol>
<li>代码重用性 (即：相同功能的代码，不用多次编写)</li>
<li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li>
<li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>
<li>可靠性(即：当我们增加新的功能后，对原来的功能没有影响)</li>
<li>使程序呈现<strong>高内聚，低耦合</strong>的特性</li>
</ol>
<h2 id="2、设计模式七大原则"><a href="#2、设计模式七大原则" class="headerlink" title="2、设计模式七大原则"></a>2、设计模式七大原则</h2><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2</p>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><p>1)    降低类的复杂度，一个类只负责一项职责。<br>2)    提高类的可读性，可维护性<br>3)    降低变更引起的风险<br>4)    通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</p>
<h3 id="2、接口隔离原则"><a href="#2、接口隔离原则" class="headerlink" title="2、接口隔离原则"></a>2、接口隔离原则</h3><p>1、客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上<br>2、先看一张图:</p>
<p><img alt="image-20191128161911015" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191128161911015.png" class="lazyload"></p>
<p>3、类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。<br>4、按隔离原则应当这样处理：<br>将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>一个接口包含了5个方法，但是B只用1、2、3方法，D只用1、4、5方法，实现<code>Interface1</code>就需要实现五个方法，不好</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation4();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><blockquote>
<p>将接口拆开为1 、2和3、4和5 ，各自隔离使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.segregation.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// 使用一把</span></span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">		a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">		a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">		C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">		c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">		c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">		c.depend5(<span class="keyword">new</span> D());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B 实现了 operation3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"D 实现了 operation5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">		i.operation2();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">		i.operation3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">		i.operation4();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">		i.operation5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="3、依赖倒转原则"><a href="#3、依赖倒转原则" class="headerlink" title="3、依赖倒转原则"></a>3、依赖倒转原则</h3><p>1、高层模块不应该依赖低层模块，二者都应该依赖其抽象</p>
<p>2、抽象不应该依赖细节，细节应该依赖抽象</p>
<p>3、依赖倒转(倒置)的中心思想是面向接口编程</p>
<p>4、依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</p>
<p>5、使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>person类的receive方法传的参数为指定类，不利用后期其他对象的传入</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成Person接收消息的功能</span></span><br><span class="line"><span class="comment">//方式1分析</span></span><br><span class="line"><span class="comment">//1. 简单，比较容易想到</span></span><br><span class="line"><span class="comment">//2. 如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">//   因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email )</span> </span>&#123;</span><br><span class="line">		System.out.println(email.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><blockquote>
<p>将Person的receive方法传入的为通用接口，这样其他对象想用该方法实现这个接口就好</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//客户端无需改变</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">		</span><br><span class="line">		person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"微信信息: hello,ok"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">		System.out.println(receiver.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="依赖传递的三种方式"><a href="#依赖传递的三种方式" class="headerlink" title="依赖传递的三种方式"></a>依赖传递的三种方式</h4><h5 id="接口传递"><a href="#接口传递" class="headerlink" title="接口传递"></a>接口传递</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"长虹电视机，打开"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>&#123;</span><br><span class="line">     tv.play();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.open(changHong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV tv; <span class="comment">//成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span></span>&#123; <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="setter方式传递"><a href="#setter方式传递" class="headerlink" title="setter方式传递"></a>setter方式传递</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">// ITV接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITV tv;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv = tv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv.play();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"长虹电视机，打开"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.setTv(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><p>1)    低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.<br>2)    变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化<br>3)    继承时遵循里氏替换原则</p>
<h3 id="4、里氏替换原则"><a href="#4、里氏替换原则" class="headerlink" title="4、里氏替换原则"></a>4、里氏替换原则</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>1)    继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</p>
<p>2)    继承在给程序设计带来便利的同时，也带来了弊端。比如使用<strong>继承会给程序带来侵入性</strong>，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</p>
<p>3)    问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>1、里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里的女士提出的。</p>
<p>2、如果对每个类型为<code>T1</code>的对象<code>o1</code>，都有类型为<code>T2</code>的对象<code>o2</code>，使得以<code>T1</code>定义的所有程序P在所有的对象<code>o1</code>都代换成<code>o2</code>时，程序P的行为没有发生变化，那么类型<code>T2</code>是类型<code>T1</code>的子类型。换句话说，<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</p>
<p>3、在使用继承时，遵循里氏替换原则，<strong>在子类中尽量不要重写父类的方法</strong></p>
<p>4、里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，<strong>在适当的情况下，可以通过聚合，组合，依赖来解决问题</strong>。</p>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>因B类重写了父类的方法，改变了原有的本意：两数相减</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		System.out.println(<span class="string">"11-3="</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		System.out.println(<span class="string">"11-3="</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改进-2"><a href="#改进-2" class="headerlink" title="改进"></a>改进</h4><blockquote>
<p>将A组合到B中，</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">	<span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="5、开闭原则"><a href="#5、开闭原则" class="headerlink" title="5、开闭原则"></a>5、开闭原则</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>1、开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</p>
<p>2、一个软件实体如类，<span style="color:red"><strong>模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)</strong>。</span>用抽象构建框架，用实现扩展细节。</p>
<p>3、当软件需要变化时，尽量<strong>通过扩展</strong>软件实体的行为来实现变化，而<strong>不是通过修改</strong>已有的代码来实现变化。</p>
<p>4、编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
<h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>每当需要添加不同图形，都要对<code>GraphicEditor</code>进行修改</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">			drawRectangle(s);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">			drawCircle(s);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">			drawTriangle(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绘制矩形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绘制圆形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绘制三角形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Rectangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Triangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改进-3"><a href="#改进-3" class="headerlink" title="改进"></a>改进</h4><blockquote>
<p>抽取一个抽象类，定义变量和方法，扩展不同图形继承即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int m_type;</span><br><span class="line"></span><br><span class="line">public abstract void draw();//抽象方法</span><br></pre></td></tr></table></figure>


</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用看看存在的问题</span></span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		s.draw();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m_type;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Rectangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Triangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	OtherGraphic() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">" 绘制其它图形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6、迪米特法则"><a href="#6、迪米特法则" class="headerlink" title="6、迪米特法则"></a>6、迪米特法则</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>1、一个对象应该对其他对象保持最少的了解</p>
<p>2、类与类关系越密切，耦合度越大</p>
<p>3、<strong>迪米特法则(Demeter Principle)又叫最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息</p>
<p>4、迪米特法则还有个更简单的定义：只与直接的朋友通信</p>
<p>5、直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。<strong>其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友</strong>，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
<h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>学院员工管理类的所有员工信息的输出内容 放在了学校管理类中输出，这样不好</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学院的所有员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">"学院员工id= "</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">		<span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">		<span class="comment">//3. 违反了 迪米特法则 </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">"------------学院员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">"------------学校总部员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改进-4"><a href="#改进-4" class="headerlink" title="改进"></a>改进</h4><blockquote>
<p>输出学院员工的信息的方法应该属于<code>CollegeManager</code>类，<code>SchoolManager</code>类只负责调用输出方法即可，符合迪米特的最少知道原则</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学院的所有员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">"学院员工id= "</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输出学院员工的信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">"------------学院员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">		sub.printEmployee();</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">"------------学校总部员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="注意事项和细节-2"><a href="#注意事项和细节-2" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><p>1、迪米特法则的核心是降低类之间的耦合<br>2、但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</p>
<h3 id="7、合成复用原则"><a href="#7、合成复用原则" class="headerlink" title="7、合成复用原则"></a>7、合成复用原则</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
<h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>使用 依赖、聚合、组合的方式代替继承</p>
<p>依赖：将对象做参数</p>
<p>组合：创建对象实例</p>
<p>聚合：将对象做变量，set方法传入</p>
</blockquote>
<p><img alt="替代继承" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9B%BF%E4%BB%A3%E7%BB%A7%E6%89%BF.png" class="lazyload"></p>
<h2 id="3、设计原则核心思想"><a href="#3、设计原则核心思想" class="headerlink" title="3、设计原则核心思想"></a>3、设计原则核心思想</h2><p>1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>
<p>2、针对接口编程，而不是针对实现编程。</p>
<p>3、为了交互对象之间的松耦合设计而努力</p>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>1、UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</p>
<p>2、UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:</p>
<p>3、使用UML来建模，常用的工具有Rational Rose , 也可以使用一些插件来建模</p>
<p>工具</p>
<p><img alt="image-20191130105226295" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130105226295.png" class="lazyload"></p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理， UML图分类：</p>
<p>1、用例图(use case)<br>2、静态结构图：类图、对象图、包图、组件图、部署图<br>3、动态行为图：交互图（时序图与协作图）、状态图、活动图</p>
<p>说明：</p>
<p>1、类图是描述类与类之间的关系的，是UML图中最核心的<br>2、在讲解设计模式时，我们必然会使用类图，为了让学员们能够把设计模式学到位，需要先给大家讲解类图<br>3、温馨提示：如果已经掌握UML类图的学员，可以直接听设计模式的章节</p>
<h3 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">//代码形式-&gt;类图</span></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span>  name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML类图如下：</p>
<p><img alt="image-20191130111036301" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130111036301.png" class="lazyload"></p>
<h2 id="类图——依赖关系"><a href="#类图——依赖关系" class="headerlink" title="类图——依赖关系"></a>类图——依赖关系</h2><blockquote>
<p><strong>只要是在类中用到了对方，那么他们之间就存在依赖关系</strong>。如果没有对方，连编绎都通过不了。</p>
</blockquote>
<h3 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PersonDao personDao;<span class="comment">// 类</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IDCard <span class="title">getIDCard</span><span class="params">(Integer personid)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Department department = <span class="keyword">new</span> Department();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>UML图如下：</p>
<p><img alt="image-20191130113240913" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130113240913.png" class="lazyload"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1)    类中用到了对方<br>2)    如果是类的成员属性<br>3)    如果是方法的返回类型<br>4)    是方法接收的参数类型<br>5)    方法中使用到</p>
<h2 id="类图——泛化关系"><a href="#类图——泛化关系" class="headerlink" title="类图——泛化关系"></a>类图——泛化关系</h2><blockquote>
<p><strong>泛化关系实际上就是继承关系</strong>，他是依赖关系的特例</p>
</blockquote>
<h3 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoSupport</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Object entity)</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Object id)</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceBean</span> <span class="keyword">extends</span> <span class="title">Daosupport</span></span>&#123; </span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img alt="image-20191130152553398" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130152553398.png" class="lazyload"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1)    泛化关系实际上就是继承关系<br>2)    如果A类继承了B类，我们就说A和B存在泛化关系</p>
<h2 id="类图——实现关系"><a href="#类图——实现关系" class="headerlink" title="类图——实现关系"></a>类图——实现关系</h2><blockquote>
<p>实现关系实际上就是A类实现B接口，他是依赖关系的特例</p>
</blockquote>
<h3 id="举例-9"><a href="#举例-9" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Interger id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceBean</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Interger id)</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img alt="image-20191130153302994" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130153302994.png" class="lazyload"></p>
<h2 id="类图——关联关系"><a href="#类图——关联关系" class="headerlink" title="类图——关联关系"></a>类图——关联关系</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>关联关系实际上就是类与类之间的联系，他是依赖关系的特例</p>
<p><strong>关联具有导航性：即双向关系或单向关系</strong><br>关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个）， “0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m个）。</p>
<p><img alt="image-20191130154346510" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130154346510.png" class="lazyload"></p>
<h2 id="类图——聚合关系"><a href="#类图——聚合关系" class="headerlink" title="类图——聚合关系"></a>类图——聚合关系</h2><p>聚合关系（Aggregation）表示的是整体和部分的关系，<strong>整体与部分可以分开</strong>。<strong>聚合关系是关联关系的特例</strong>，所以他具有关联的导航性与多重性。</p>
<p>如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：</p>
<p><img alt="image-20191130154511238" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130154511238.png" class="lazyload"></p>
<h2 id="类图——组合关系"><a href="#类图——组合关系" class="headerlink" title="类图——组合关系"></a>类图——组合关系</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>组合关系：也是整体与部分的关系，但是<strong>整体与部分不可以分开</strong>。</p>
<h3 id="举例-10"><a href="#举例-10" class="headerlink" title="举例"></a>举例</h3><p>再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么 Head 和Person 就是 组合，IDCard 和 Person 就是聚合。</p>
<p>但是如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard 和 Person 就是组合了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IDCard card;	<span class="comment">//聚合</span></span><br><span class="line">	<span class="keyword">private</span> Head head = <span class="keyword">new</span> Head(); <span class="comment">//组合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191130162251629" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130162251629.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mouse mouse = <span class="keyword">new</span> Mouse(); <span class="comment">//鼠标可以和computer不能分离</span></span><br><span class="line">	<span class="keyword">private</span> Moniter moniter = <span class="keyword">new</span> Moniter();<span class="comment">//显示器可以和Computer不能分离</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMouse</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mouse = mouse;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoniter</span><span class="params">(Moniter moniter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.moniter = moniter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img alt="image-20191130163736116" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191130163736116.png" class="lazyload"></p>
<h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h2><p>1)    设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>2)    设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。</p>
<p>3)    &lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”）</p>
<p>4)    设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>分为三种类型，共23种</p>
<p>1、创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</p>
<p>2、结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p>
<p>3、行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。</p>
<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h2><p>​        所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，<strong>对某个类只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法(静态方法)。</p>
<p>​        比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式。</p>
<h2 id="八种方式"><a href="#八种方式" class="headerlink" title="八种方式"></a>八种方式</h2><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singletonTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"hashcode::"</span> + instance.hashCode()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"hashcode::"</span> + instance2.hashCode()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、构造器私有化，外部能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p><strong>缺点</strong>：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</p>
<p>​        这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果</p>
<p><strong>结论</strong>：这种单例模式可用，可能造成内存浪费</p>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、构造器私有化，外部能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、在静态代码块中创建单例对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>​        这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p>
<p><strong>结论</strong>：这种单例模式可用，但是可能造成内存浪费</p>
<h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、构造器私有化，外部能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、当调用getInstance 才创建单例对象 饿汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>1、起到了Lazy Loading的效果，但是只能在单线程下使用。</p>
<p>2、如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</p>
<p><strong>结论</strong>：在实际开发中，不要使用这种方式.</p>
<h3 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h3><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p>1、解决了线程不安全问题</p>
<p>2、效率太低了，每个线程在想获得类的实例时候，执行<code>getInstance()</code>方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低</p>
<p><strong>结论</strong>：在实际开发中，不推荐使用这种方式</p>
<h3 id="懒汉式（线程安全-同步代码块）"><a href="#懒汉式（线程安全-同步代码块）" class="headerlink" title="懒汉式（线程安全 同步代码块）"></a>懒汉式（线程安全 同步代码块）</h3><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步代码块)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">              	instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><p>1、这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块</p>
<p>2、<span style="color:red"><strong>但是这种同步并不能起到线程同步的作用</strong></span>。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</p>
<p><strong>结论</strong>：在实际开发中，不能使用这种方式</p>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题</span></span><br><span class="line">	<span class="comment">//同时保证了效率，推荐使用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">              		instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><p>1、Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。</p>
<p>2、这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.</p>
<p>3、线程安全；延迟加载；效率较高</p>
<p><strong>结论</strong>：在实际开发中，推荐使用这种单例设计模式</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><p>1、这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p>
<p>2、<strong>静态内部类方式在Singleton类被装载时并不会立即实例化</strong>，而是在需要实例化时，调用<code>getInstance</code>方法，才会装载<code>SingletonInstance</code>类，从而完成Singleton的实例化。</p>
<p>3、类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p>
<p>4、优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。</p>
<p><strong>结论</strong>：推荐使用。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest08</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Singleton instance = Singleton.INSTANCE;</span><br><span class="line">		Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">		System.out.println(instance == instance2);</span><br><span class="line">		</span><br><span class="line">		System.out.println(instance.hashCode());</span><br><span class="line">		System.out.println(instance2.hashCode());</span><br><span class="line">		</span><br><span class="line">		instance.sayOK();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">	INSTANCE; <span class="comment">//属性</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><p>1、这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p>
<p>2、这种方式是Effective Java作者Josh Bloch 提倡的方式</p>
<p><strong>结论</strong>：推荐使用</p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>1、我们JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)</p>
<p><img alt="image-20191201111601888" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191201111601888.png" class="lazyload"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</p>
<p>2、当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</p>
<p><strong>单例模式使用的场景</strong></p>
<blockquote>
<p>需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)</p>
</blockquote>
<h1 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>这里我们用生产电脑来举例，假设有一个电脑的代工生产商，它目前已经可以代工生产联想电脑了，随着业务的拓展，这个代工生产商还要生产惠普和华硕的电脑，这样我们就需要用一个单独的类来专门生产电脑，这就用到了简单工厂模式。</p>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img alt="这里写图片描述" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20160211134612096.png" class="lazyload"></p>
<ul>
<li>Factory：工厂类，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>IProduct：抽象产品类，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li>
<li>Product：具体产品类，是简单工厂模式的创建目标。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="创建抽象产品类"><a href="#创建抽象产品类" class="headerlink" title="创建抽象产品类"></a>创建抽象产品类</h4><p>我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建具体产品类"><a href="#创建具体产品类" class="headerlink" title="创建具体产品类"></a><strong>创建具体产品类</strong></h4><p>接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer ，并实现了父类的start方法</p>
<h5 id="联想电脑"><a href="#联想电脑" class="headerlink" title="联想电脑"></a>联想电脑</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"联想电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="惠普电脑"><a href="#惠普电脑" class="headerlink" title="惠普电脑"></a>惠普电脑</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"惠普电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="华硕电脑"><a href="#华硕电脑" class="headerlink" title="华硕电脑"></a>华硕电脑</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"华硕电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="创建工厂类"><a href="#创建工厂类" class="headerlink" title="创建工厂类"></a>创建工厂类</h4><p>接下来创建一个工厂类，它提供了一个静态方法createComputer用来生产电脑。你只需要传入你想生产的电脑的品牌，它就会实例化相应品牌的电脑对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Computer mComputer=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"lenovo"</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> LenovoComputer();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hp"</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> HpComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"asus"</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> AsusComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端调用工厂类"><a href="#客户端调用工厂类" class="headerlink" title="客户端调用工厂类"></a>客户端调用工厂类</h4><p>客户端调用工厂类，传入“hp”生产出惠普电脑并调用该电脑对象的start方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">      ComputerFactory.createComputer(<span class="string">"hp"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>工厂类负责创建的对象比较少。<br>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心。</p>
<h4 id="简单工厂模式优缺点"><a href="#简单工厂模式优缺点" class="headerlink" title="简单工厂模式优缺点"></a>简单工厂模式优缺点</h4><p><strong>优点</strong>：<br>使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性。</p>
<p><strong>缺点</strong>：<br>可实例化的类型在编译期间已经被确定，如果增加新类型，则需要修改工厂，违背了开放封闭原则(ASD) 。 简单工厂需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>当电脑需求量越来越大，每个品牌的电脑都要建立各自的具体工厂去制造</p>
<blockquote>
<p> <a href="https://blog.csdn.net/jason0539/article/details/23020989#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/23020989#commentBox</a> </p>
<p> <a href="https://blog.csdn.net/itachi85/article/details/50651177" target="_blank" rel="noopener">https://blog.csdn.net/itachi85/article/details/50651177</a> </p>
</blockquote>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="创建抽象产品类-1"><a href="#创建抽象产品类-1" class="headerlink" title="创建抽象产品类"></a>创建抽象产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建具体产品类-1"><a href="#创建具体产品类-1" class="headerlink" title="创建具体产品类"></a>创建具体产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hp电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"华硕电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"联想电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建抽象工厂类"><a href="#创建抽象工厂类" class="headerlink" title="创建抽象工厂类"></a>创建抽象工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Computer <span class="title">createComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建具体工厂类"><a href="#创建具体工厂类" class="headerlink" title="创建具体工厂类"></a>创建具体工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        LenovoFactory lenovoFactory = <span class="keyword">new</span> LenovoFactory();</span><br><span class="line">        LenovoComputer lenovoComputer = (LenovoComputer) lenovoFactory.createComputer();</span><br><span class="line">        lenovoComputer.start();</span><br><span class="line"></span><br><span class="line">        HpFactory hpFactory = <span class="keyword">new</span> HpFactory();</span><br><span class="line">        HpComputer hpComputer = (HpComputer) hpFactory.createComputer();</span><br><span class="line">        hpComputer.start();</span><br><span class="line"></span><br><span class="line">        AsusFactory asusFactory = <span class="keyword">new</span> AsusFactory();</span><br><span class="line">        AsusComputer asusComputer = (AsusComputer) asusFactory.createComputer();</span><br><span class="line">        asusComputer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191202215031305" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191202215031305.png" class="lazyload"></p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。<br>在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。</p>
<p><img alt="img" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20150410110918027.png" class="lazyload"></p>
<p>可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。</p>
<p><img alt="img" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20150410111021890.png" class="lazyload"></p>
<p>系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图：</p>
<p><img alt="img" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20150410110953938.png" class="lazyload"></p>
<p>显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。<br>在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。</p>
<h3 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h3><p>随着客户的要求越来越高，宝马车需要不同配置的空调和发动机等配件。于是这个工厂开始生产空调和发动机，用来组装汽车。这时候工厂有两个系列的产品:空调和发动机。宝马320系列配置A型号空调和A型号发动机，宝马230系列配置B型号空调和B型号发动机。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	发动机以及型号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;  </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineA</span> <span class="keyword">extends</span> <span class="title">Engine</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineA"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineBextends</span> <span class="title">Engine</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineB</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineB"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	空调以及型号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aircondition</span> </span>&#123;  </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionA</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionA"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionB</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionB</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionB"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h4><blockquote>
<p>将工厂生产的东西进一步抽象细化，达到生产一个产品族的级别</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建工厂的接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//制造发动机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//制造空调 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span></span>; </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//为宝马320系列生产配件  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW320</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineA();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionA();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//宝马523系列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW523</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">     <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineB();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionB();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//生产宝马320系列配件</span></span><br><span class="line">        FactoryBMW320 factoryBMW320 = <span class="keyword">new</span> FactoryBMW320();  </span><br><span class="line">        factoryBMW320.createEngine();</span><br><span class="line">        factoryBMW320.createAircondition();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//生产宝马523系列配件  </span></span><br><span class="line">        FactoryBMW523 factoryBMW523 = <span class="keyword">new</span> FactoryBMW523();  </span><br><span class="line">        factoryBMW320.createEngine();</span><br><span class="line">        factoryBMW320.createAircondition();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。</p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>将实例化对象的代码提取出来放到一个类中统一管理和维护，达到个主项目的依赖关系的解耦，从而提高项目的扩展和维护性。</p>
<h3 id="依赖抽象原则"><a href="#依赖抽象原则" class="headerlink" title="依赖抽象原则"></a>依赖抽象原则</h3><p>1、创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。</p>
<p>2、不要让类继承具体类，而是继承抽象类或者是实现接口</p>
<p>3、不要覆盖基类中已经实现的方法</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// getInstance 是 Calendar 静态方法</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 注意月份下标从0开始，所以取月份要+1</span></span><br><span class="line">        System.out.println(<span class="string">"年:"</span> + cal.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(<span class="string">"月:"</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"日:"</span> + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(<span class="string">"时:"</span> + cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        System.out.println(<span class="string">"分:"</span> + cal.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(<span class="string">"秒:"</span> + cal.get(Calendar.SECOND));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实例流程如图下所示：</p>
<p><img alt="calendar源码" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/calendar%E6%BA%90%E7%A0%81.png" class="lazyload"></p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h2><p>1、原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</p>
<p>2、原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</p>
<p>3、工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()</p>
<p>4、形象的理解：孙大圣拔出猴毛，变出其它孙大圣</p>
<h2 id="原型模式原理结构图"><a href="#原型模式原理结构图" class="headerlink" title="原型模式原理结构图"></a>原型模式原理结构图</h2><p><img alt="image-20191205151843465" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191205151843465.png" class="lazyload"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>克隆羊问题： </p>
<p>现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom羊属性完全相同的10只羊。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力=&gt; 原型模式</p>
</blockquote>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><h3 id="Sheep类"><a href="#Sheep类" class="headerlink" title="Sheep类"></a>Sheep类</h3><blockquote>
<p>实现Cloneable，使用默认的clone方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"蒙古羊"</span>;</span><br><span class="line">    <span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sheep [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", color="</span> + color + <span class="string">", address="</span> + address + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆该实例，使用默认的clone方法来完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"原型模式完成对象的创建"</span>);</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);</span><br><span class="line"></span><br><span class="line">        sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">"jack"</span>, <span class="number">2</span>, <span class="string">"黑色"</span>);</span><br><span class="line"></span><br><span class="line">        Sheep sheep2 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">        Sheep sheep3 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">        Sheep sheep4 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">        Sheep sheep5 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"sheep2 ="</span> + sheep2 + <span class="string">"sheep2.friend="</span> + sheep2.friend.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sheep3 ="</span> + sheep3 + <span class="string">"sheep3.friend="</span> + sheep3.friend.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sheep4 ="</span> + sheep4 + <span class="string">"sheep4.friend="</span> + sheep4.friend.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sheep5 ="</span> + sheep5 + <span class="string">"sheep5.friend="</span> + sheep5.friend.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191204194845466" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191204194845466.png" class="lazyload"></p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>1、对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</p>
<p>2、<strong>对于数据类型是引用数据类型的成员变量</strong>，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是<strong>只是将该成员变量的引用值（内存地址）复制一份给新的对象</strong>。因为<strong>实际上两个对象的该成员变量都指向同一个实例</strong>。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p>
<p>3、前面我们克隆羊就是浅拷贝</p>
<p>4、浅拷贝是使用默认的clone()方法来实现<br><code>sheep = (Sheep) super.clone();</code></p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>1、复制对象的所有基本数据类型的成员变量值</p>
<p>2、为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝</p>
<p><strong>两种方式：</strong></p>
<p>深拷贝实现方式1：</p>
<p>深拷贝实现方式2：</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><blockquote>
<p>重写clone方法来实现深拷贝</p>
</blockquote>
<h5 id="DeepCloneableTarget类"><a href="#DeepCloneableTarget类" class="headerlink" title="DeepCloneableTarget类"></a>DeepCloneableTarget类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DeepProtoType类"><a href="#DeepProtoType类" class="headerlink" title="DeepProtoType类"></a>DeepProtoType类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝 - 方式 1 使用clone 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object deep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//这里完成对基本数据类型(属性)和String的克隆</span></span><br><span class="line">        deep = <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//对引用类型的属性，进行单独处理</span></span><br><span class="line">        DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">        deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> deepProtoType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="方式二（推荐）"><a href="#方式二（推荐）" class="headerlink" title="方式二（推荐）"></a>方式二（推荐）</h4><blockquote>
<p>通过对象序列化实现深拷贝(推荐)</p>
</blockquote>
<h4 id="DeepProtoType类-1"><a href="#DeepProtoType类-1" class="headerlink" title="DeepProtoType类"></a>DeepProtoType类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        p.name = <span class="string">"宋江"</span>;</span><br><span class="line">        p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">"大牛"</span>, <span class="string">"小牛"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1 完成深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//		DeepProtoType p2 = (DeepProtoType) p.clone();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		System.out.println("p.name=" + p.name + "p.deepCloneableTarget=" + p.deepCloneableTarget.hashCode());</span></span><br><span class="line"><span class="comment">//		System.out.println("p2.name=" + p.name + "p2.deepCloneableTarget=" + p2.deepCloneableTarget.hashCode());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2 完成深拷贝</span></span><br><span class="line">        DeepProtoType p2 = (DeepProtoType) p.deepClone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"p.name="</span> + p.name + <span class="string">"p.deepCloneableTarget="</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"p2.name="</span> + p.name + <span class="string">"p2.deepCloneableTarget="</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="image-20191205151601101" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191205151601101.png" class="lazyload"></p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>1、创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</p>
<p>2、不用重新初始化对象，而是动态地获得对象运行时的状态</p>
<p>3、如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</p>
<p>4、在实现深克隆的时候可能需要比较复杂的代码</p>
<p><strong>缺点</strong>：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.</p>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><blockquote>
<p>将产品 和产品的创建过程分离  解耦 ==&gt; 建造者模式</p>
</blockquote>
<h2 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h2><p>1、    建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p>2、    建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>
<h3 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h3><p>1、    Product（产品角色）：一个具体的产品对象。</p>
<p>2、    Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口/抽象类。</p>
<p>3、    ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。</p>
<p>4、    Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</p>
<h2 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h2><p><img alt="image-20191205154827048" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191205154827048.png" class="lazyload"></p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><blockquote>
<p>建造房子    过程为打桩、砌墙、封顶</p>
</blockquote>
<p><img alt="image-20191205203829198" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191205203829198.png" class="lazyload"></p>
<h3 id="House"><a href="#House" class="headerlink" title="House"></a>House</h3><blockquote>
<p>​    房子 基础属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBaise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaise</span><span class="params">(String baise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roofed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoofed</span><span class="params">(String roofed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roofed = roofed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="HouseBuilder"><a href="#HouseBuilder" class="headerlink" title="HouseBuilder"></a>HouseBuilder</h3><blockquote>
<p>抽象类：    建造流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造流程</span></span><br><span class="line">    <span class="comment">//[1]打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//[2]砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//[3]封顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[4]建造房子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> House <span class="title">buildHouse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="HighBuilding"><a href="#HighBuilding" class="headerlink" title="HighBuilding"></a>HighBuilding</h3><blockquote>
<p>高楼建造，继承HouseBuilder</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighBuilding</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">" 高楼的打地基100米 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">" 高楼的砌墙20cm "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">" 高楼的透明屋顶 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CommonHouse"><a href="#CommonHouse" class="headerlink" title="CommonHouse"></a>CommonHouse</h3><blockquote>
<p>普通房建造，继承HouseBuilder</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打地基5米"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子砌墙10cm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子封顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="HouseDirector"><a href="#HouseDirector" class="headerlink" title="HouseDirector"></a>HouseDirector</h3><blockquote>
<p>指挥者    处理建造房子流程  将房子产品返回</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//指挥者，这里去指定制作流程，返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器传入 houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过setter 传入 houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何处理建造房子的流程，交给指挥者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//盖普通房子</span></span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备创建房子的指挥者</span></span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line"></span><br><span class="line">        House house1 = houseDirector.constructHouse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println("输出流程");</span></span><br><span class="line"></span><br><span class="line">        HighBuilding highBuilding = <span class="keyword">new</span> HighBuilding();</span><br><span class="line">        houseDirector.setHouseBuilder(highBuilding);</span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>1、    客户端(使用程序)<strong>不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</strong><br>2、    每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，<strong>用户使用不同的具体建造者即可得到不同的产品对象</strong><br>3、    <strong>可以更加精细地控制产品的创建过程。</strong>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程<br>4、    <strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</p>
<p>5、    建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。<br>6、    如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</p>
<p>7、    抽象工厂模式VS建造者模式<br>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p>
<h2 id="StringBuilder源码"><a href="#StringBuilder源码" class="headerlink" title="StringBuilder源码"></a>StringBuilder源码</h2><p><img alt="image-20191208152506839" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208152506839.png" class="lazyload"></p>
<p>建造者模式的角色分析：</p>
<p>【1】    <code>Appendable</code> 接口定义了多个append方法(抽象方法), 即<code>Appendable</code> 为抽象建造者, 定义了抽象方法<strong>（<code>Appendable</code>   类比    <code>HouseBuilder</code>）</strong></p>
<p>【2】    <code>AbstractStringBuilder</code> 实现了<code>Appendable</code> 接口方法，这里的<code>AbstractStringBuilder</code> 已经是建造者，只是不能实例化 </p>
<p>【3】   <code>StringBuilder</code> 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由<code>AbstractStringBuilder</code> 完成, 而<code>StringBuilder</code> 继承了<code>AbstractStringBuilder</code><strong>(<code>StringBuilder</code>  类比  <code>HighBuilding</code>和<code>CommonHouse</code>)</strong></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h2><p>1、    <strong>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</p>
<p>2、    适配器模式属于结构型模式</p>
<p>3、    主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>Adapter类，通过继承src类，实现dst 类接口，完成src-&gt;dst的适配。</p>
</blockquote>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><blockquote>
<p> 手机充电    220V 到5V的适配过程</p>
</blockquote>
<p><img alt="image-20191208160410479" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208160410479.png" class="lazyload"></p>
<h4 id="src-原类"><a href="#src-原类" class="headerlink" title="src 原类"></a>src 原类</h4><blockquote>
<p><code>Voltage220V</code>类  作为src  220v电压输入</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出220V的电压</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"电压="</span> + src + <span class="string">"伏"</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定义适配器5V接口"><a href="#定义适配器5V接口" class="headerlink" title="定义适配器5V接口"></a>定义适配器5V接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="适配器实现类"><a href="#适配器实现类" class="headerlink" title="适配器实现类"></a>适配器实现类</h4><blockquote>
<p>继承了220v电压的输入电压<code>output220V()</code>   +   实现 5v接口的输出方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到220v电压</span></span><br><span class="line">        <span class="keyword">int</span> src = output220V();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dstV = src / <span class="number">44</span>; <span class="comment">// 转成5v</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="手机类"><a href="#手机类" class="headerlink" title="手机类"></a>手机类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//充电方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压为5v，可以充电~"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(iVoltage5V.output5V() &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压大于5v，不可以充电~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-5"><a href="#客户端-5" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========适配器模式====="</span>);</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><p>1、    基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口，完成src-&gt;dst的适配<br>2、<span style="color:red">    <strong>根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系</strong>。</span></p>
<p><strong>对象适配器模式是适配器模式常用的一种</strong></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>修改适配器  将继承改为成员对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter2</span> <span class="keyword">implements</span> <span class="title">Voltage5</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> Voltage220 voltage220; <span class="comment">//持有Voltage220对象,不是继承了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><h4 id="VoltageAdapter适配器"><a href="#VoltageAdapter适配器" class="headerlink" title="VoltageAdapter适配器"></a>VoltageAdapter适配器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(voltage220V == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取到220v电压</span></span><br><span class="line">        <span class="keyword">int</span> src = voltage220V.output220V();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dstV = src / <span class="number">44</span>; <span class="comment">// 转成5v</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------客户端------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========适配器模式====="</span>);</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191208192947706" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208192947706.png" class="lazyload"></p>
<h2 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h2><h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><p>1、    一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。<br>2、    <strong>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</strong><br>3、    适用于一个接口不想使用其所有的方法的情况。</p>
<blockquote>
<p><span style="color:red"><strong>若想只实现某一个接口的方法，只能使用 抽象类 实现接口的方式，间接的选择抽象类某个方法</strong></span></p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在安卓开发中经常会遇到接口适配器模式</p>
<p>Android中的属性动画<code>ValueAnimator</code>类可以通过<code>addListener(AnimatorListener listener)</code>方法添加监听器，那么常规写法如下：</p>
<img alt="image-20191208193318814" style="zoom:75%;" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208193318814.png" class="lazyload">



<p>有时候我们不想实现<br><code>Animator.AnimatorListener</code>接口的全部方法，我们只想监听<code>onAnimationStart</code>，我们会如下写</p>
<p><img alt="image-20191208193405485" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208193405485.png" class="lazyload"></p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><h4 id="顶级接口"><a href="#顶级接口" class="headerlink" title="顶级接口"></a>顶级接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>抽象类实现接口，默认实现空方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在AbsAdapter 将 Interface4的方法默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-6"><a href="#客户端-6" class="headerlink" title="客户端"></a>客户端</h4><p>使用匿名内部类 只是用一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">            <span class="comment">//只需要</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用了m1的方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        absAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191208193751565" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208193751565.png" class="lazyload"></p>
<h2 id="SpringMVC框架源码分析"><a href="#SpringMVC框架源码分析" class="headerlink" title="SpringMVC框架源码分析"></a>SpringMVC框架源码分析</h2><blockquote>
<p>简易版Dispatcher源码</p>
</blockquote>
<p><img alt="image-20191208200843857" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208200843857.png" class="lazyload"></p>
<h3 id="模拟SpringMVC适配器模式"><a href="#模拟SpringMVC适配器模式" class="headerlink" title="模拟SpringMVC适配器模式"></a>模拟SpringMVC适配器模式</h3><blockquote>
<p>模拟一套简易版SpringMVC的适配器模式获取到Controller源码</p>
</blockquote>
<p><img alt="image-20191208201702927" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191208201702927.png" class="lazyload"></p>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>定义controller接口，创建<code>HttpController、SimpleController、AnnotationController</code>实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//多种Controller实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"http..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimplerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"simple..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"annotation..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h4><p>创建适配器接口，<code>SimpleHandlerAdapter、HttpHandlerAdapter、AnnotationHandlerAdapter</code>实现接口，<code>supports</code>方法判断是哪个controller，然后执行对应的handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">///定义一个Adapter接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种适配器类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((SimpleController) handler).doSimplerHandler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> SimpleController);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((HttpController) handler).doHttpHandler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpController);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((AnnotationController) handler).doAnnotationHandler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> AnnotationController);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="DispatchServlet"><a href="#DispatchServlet" class="headerlink" title="DispatchServlet"></a>DispatchServlet</h4><p>类初始化将所有的适配器存放到列表中，根据<code>doDispatch</code>方法来判断走哪个controller的适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此处模拟SpringMVC从request取handler的对象，</span></span><br><span class="line">		<span class="comment">// 适配器可以获取到希望的Controller</span></span><br><span class="line">		 HttpController controller = <span class="keyword">new</span> HttpController();</span><br><span class="line">		<span class="comment">// AnnotationController controller = new AnnotationController();</span></span><br><span class="line">		<span class="comment">//SimpleController controller = new SimpleController();</span></span><br><span class="line">		<span class="comment">// 得到对应适配器</span></span><br><span class="line">		HandlerAdapter adapter = getHandler(controller);</span><br><span class="line">		<span class="comment">// 通过适配器执行对应的controller对应方法</span></span><br><span class="line">		adapter.handle(controller);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历：根据得到的controller(handler), 返回对应适配器</span></span><br><span class="line">		<span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (adapter.supports(controller)) &#123;</span><br><span class="line">				<span class="keyword">return</span> adapter;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DispatchServlet().doDispatch(); <span class="comment">// http...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>•    Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类<br>•    适配器代替controller执行相应的方法<br>•    扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了,<br>•    这就是设计模式的力量</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>1、    三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。<br>2、    类适配器：以类给到，在Adapter里，就是将src当做类，继承<br>对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有<br>接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现<br>3、    Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</p>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h2><p>1、    桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</p>
<p>2、    是一种结构型设计模式</p>
<p>3、    Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</p>
<h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><blockquote>
<p>手机类型和品牌问题</p>
</blockquote>
<p>父类组合接口，子类调用接口的实现</p>
<p><img alt="image-20191209151247266" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191209151247266.png" class="lazyload"></p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><h3 id="品牌接口"><a href="#品牌接口" class="headerlink" title="品牌接口"></a>品牌接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="品牌实现"><a href="#品牌实现" class="headerlink" title="品牌实现"></a>品牌实现</h3><p>分别实现vivo和xiaomi</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vivo</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"vivo open"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"vivo close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"vivo call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi open"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="桥梁抽象类"><a href="#桥梁抽象类" class="headerlink" title="桥梁抽象类"></a>桥梁抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组合品牌</span></span><br><span class="line">    <span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        brand.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        brand.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        brand.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//折叠式手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldedPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FoldedPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"折叠"</span>);</span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"折叠"</span>);</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"折叠"</span>);</span><br><span class="line">        <span class="keyword">super</span>.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直立手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpRightPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UpRightPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"直立"</span>);</span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"直立"</span>);</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"直立"</span>);</span><br><span class="line">        <span class="keyword">super</span>.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端-7"><a href="#客户端-7" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">        phone.open();</span><br><span class="line">        phone.call();</span><br><span class="line">        phone.close();</span><br><span class="line"></span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">        phone1.open();</span><br><span class="line">        phone1.call();</span><br><span class="line">        phone1.close();</span><br><span class="line"></span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">        phone2.open();</span><br><span class="line">        phone2.call();</span><br><span class="line">        phone2.close();</span><br><span class="line"></span><br><span class="line">        Phone phone3 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">        phone3.open();</span><br><span class="line">        phone3.call();</span><br><span class="line">        phone3.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="JDBC源码"><a href="#JDBC源码" class="headerlink" title="JDBC源码"></a>JDBC源码</h2><p>Jdbc 的 Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle的Driver，这些就可以当做实现接口类</p>
<p><img alt="image-20191210104039741" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191210104039741.png" class="lazyload"></p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>1、    实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</p>
<p>2、    对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</p>
<p>3、    <strong>桥接模式替代多层继承方案，可以减少子类的个数</strong>，降低系统的管理和维护成本。</p>
<p>4、    桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</p>
<p>5、    桥接模式要求<strong>正确识别出系统中两个独立变化的维度</strong>，因此其使用范围有一定的局限性，即需要有这样的应用场景。</p>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h2><p>装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p>
<h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2><p>1、    咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</p>
<p>2、    调料：Milk、Soy(豆浆)、Chocolate</p>
<p>3、    要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</p>
<p>4、    使用OO的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</p>
<h3 id="装饰者模式设计"><a href="#装饰者模式设计" class="headerlink" title="装饰者模式设计"></a>装饰者模式设计</h3><p><img alt="image-20191210115254126" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191210115254126.png" class="lazyload"></p>
<h3 id="下订单"><a href="#下订单" class="headerlink" title="下订单"></a>下订单</h3><p>一层层嵌套包装，和俄罗斯套娃一样</p>
<p>每加一种调味品，都携带原订单的内容，【副包裹主】 </p>
<p><img alt="image-20191210115317153" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191210115317153.png" class="lazyload"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="顶级抽象类"><a href="#顶级抽象类" class="headerlink" title="顶级抽象类"></a>顶级抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String des;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="缓冲实现类"><a href="#缓冲实现类" class="headerlink" title="缓冲实现类"></a>缓冲实现类</h3><blockquote>
<p>饮料中coffee的类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	继承coffee的不同咖啡</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShortBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"ShortBlack咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"美式咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Espress</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"意大利咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decaf</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"Decaf咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装饰者"><a href="#装饰者" class="headerlink" title="装饰者"></a>装饰者</h3><blockquote>
<p>继承 + 组合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Drink drink; <span class="comment">//被装饰者对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getPrice 自己的价格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + drink.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//drink.getDes() 输出被装饰者的信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDes() + <span class="string">" "</span> + <span class="keyword">super</span>.getPrice() + <span class="string">"&amp;&amp;"</span> + drink.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="调味品继承"><a href="#调味品继承" class="headerlink" title="调味品继承"></a>调味品继承</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体的Decorator  调味品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">        setDes(<span class="string">"巧克力"</span>);</span><br><span class="line">        setPrice(<span class="number">3.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的Decorator  调味品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">        setDes(<span class="string">"牛奶"</span>);</span><br><span class="line">        setPrice(<span class="number">3.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的Decorator  调味品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">        setDes(<span class="string">"豆浆"</span>);</span><br><span class="line">        setPrice(<span class="number">3.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端-8"><a href="#客户端-8" class="headerlink" title="客户端"></a>客户端</h3><blockquote>
<p>下订单</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//装饰者模式 下订单：2份巧克力 + 1份牛奶的LongBlack</span></span><br><span class="line">        <span class="comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 点一份 LongBlack</span></span><br><span class="line">        Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">        System.out.println(<span class="string">"费用1="</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">"描述="</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. order 加入一份牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> Milk(order);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"order 加入一份牛奶 费用 ="</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">"order 加入一份牛奶 描述 = "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. order 加入一份巧克力</span></span><br><span class="line"></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力  费用 ="</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力 描述 = "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. order 加入一份巧克力</span></span><br><span class="line"></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"order 加入一份牛奶 加入2份巧克力   费用 ="</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">"order 加入一份牛奶 加入2份巧克力 描述 = "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line"></span><br><span class="line">        Drink order2 = <span class="keyword">new</span> Decaf();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"order2 无因咖啡  费用 ="</span> + order2.cost());</span><br><span class="line">        System.out.println(<span class="string">"order2 无因咖啡 描述 = "</span> + order2.getDes());</span><br><span class="line"></span><br><span class="line">        order2 = <span class="keyword">new</span> Milk(order2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"order2 无因咖啡 加入一份牛奶  费用 ="</span> + order2.cost());</span><br><span class="line">        System.out.println(<span class="string">"order2 无因咖啡 加入一份牛奶 描述 = "</span> + order2.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img alt="image-20191211144322843" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191211144322843.png" class="lazyload"></p>
<h2 id="IO流源码分析"><a href="#IO流源码分析" class="headerlink" title="IO流源码分析"></a>IO流源码分析</h2><p><img alt="image-20191211145646540" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191211145646540.png" class="lazyload"></p>
<p><img alt="image-20191211150336209" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191211150336209.png" class="lazyload"></p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"d:\\1.txt"</span>));</span><br><span class="line">        System.out.println(dis.read());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img alt="image-20191211150118881" style="zoom:200%;" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191211150118881.png" class="lazyload">



<p>总结：</p>
<ol>
<li><p>InputStream 是抽象类, 类似我们前面讲的 Drink</p>
</li>
<li><p>FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack</p>
</li>
<li><p>FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者</p>
</li>
<li><p>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</p>
</li>
<li><p>FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者</p>
</li>
<li><p>分析得出在jdk 的io体系中，就是使用装饰者模式</p>
</li>
</ol>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h2><p>1、    组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。</p>
<p>2、    组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
<p>3、    这种类型的设计模式属于结构型模式。</p>
<p>4、    组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子</p>
<p><img alt="image-20191211155042828" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191211155042828.png" class="lazyload"></p>
<h2 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img alt="image-20191211155149449" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191211155149449.png" class="lazyload"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="顶级抽象类-1"><a href="#顶级抽象类-1" class="headerlink" title="顶级抽象类"></a>顶级抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">	<span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><h4 id="University"><a href="#University" class="headerlink" title="University"></a>University</h4><blockquote>
<p>实现类的顶级类似父类，但没有和其他类有继承关系，掌管着院系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	大学</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//List 中 存放的College</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents</span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="College"><a href="#College" class="headerlink" title="College"></a>College</h4><blockquote>
<p>掌管着院系里的专业</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	院系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//List 中 存放的Department</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents</span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Department"><a href="#Department" class="headerlink" title="Department"></a>Department</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//没有集合</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-9"><a href="#客户端-9" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">		OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">"清华大学"</span>, <span class="string">" 中国顶级大学 "</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建 学院</span></span><br><span class="line">		OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">"计算机学院"</span>, <span class="string">" 计算机学院 "</span>);</span><br><span class="line">		OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">"信息工程学院"</span>, <span class="string">" 信息工程学院 "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"软件工程"</span>, <span class="string">" 软件工程不错 "</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"网络工程"</span>, <span class="string">" 网络工程不错 "</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"计算机科学与技术"</span>, <span class="string">" 计算机科学与技术是老牌的专业 "</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"通信工程"</span>, <span class="string">" 通信工程不好学 "</span>));</span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"信息工程"</span>, <span class="string">" 信息工程好学 "</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将学院加入到 学校</span></span><br><span class="line">		university.add(computerCollege);</span><br><span class="line">		university.add(infoEngineercollege);</span><br><span class="line"></span><br><span class="line">		university.print();</span><br><span class="line">		<span class="comment">//infoEngineercollege.print();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img alt="image-20191211160525845" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191211160525845.png" class="lazyload"></p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h2><p>外观模式（Facade），也叫“过程模式”：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p>
<p>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p>
<blockquote>
<p>说白了，由一个管理者去管理不同的子系统，调用者只需要让管理者去做就行，和中介一样</p>
</blockquote>
<p><img alt="image-20191212150813489" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212150813489.png" class="lazyload"></p>
<ul>
<li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象</li>
<li>调用者(Client): 外观接口的调用者</li>
<li>子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者</li>
</ul>
<h2 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h2><p>影院管理</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>定义一个高层接口，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口</p>
<p><img alt="image-20191212151111548" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212151111548.png" class="lazyload"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h3><h4 id="DVD"><a href="#DVD" class="headerlink" title="DVD"></a>DVD</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DVDPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用单例模式, 使用饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DVDPlayer instance = <span class="keyword">new</span> DVDPlayer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dvd on ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dvd off ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dvd is playing ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dvd pause ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="爆米花"><a href="#爆米花" class="headerlink" title="爆米花"></a>爆米花</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popcorn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Popcorn instance = <span class="keyword">new</span> Popcorn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Popcorn <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" popcorn on "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" popcorn ff "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" popcorn is poping  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Screen instance = <span class="keyword">new</span> Screen();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Screen <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Screen up "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Screen down "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="立体声"><a href="#立体声" class="headerlink" title="立体声"></a>立体声</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stereo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Stereo instance = <span class="keyword">new</span> Stereo();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stereo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Stereo on "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Screen off "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Screen up.. "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="影院灯光"><a href="#影院灯光" class="headerlink" title="影院灯光"></a>影院灯光</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheaterLight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> TheaterLight instance = <span class="keyword">new</span> TheaterLight();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TheaterLight <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" TheaterLight on "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" TheaterLight off "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" TheaterLight dim.. "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bright</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" TheaterLight bright.. "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="投影仪"><a href="#投影仪" class="headerlink" title="投影仪"></a>投影仪</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Projector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Projector instance = <span class="keyword">new</span> Projector();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Projector <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Projector on "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Projector ff "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">focus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" Projector is Projector  "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="影院管理者"><a href="#影院管理者" class="headerlink" title="影院管理者"></a>影院管理者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义各个子系统对象</span></span><br><span class="line">	<span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line">	<span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">	<span class="keyword">private</span> Stereo stereo;</span><br><span class="line">	<span class="keyword">private</span> Projector projector;</span><br><span class="line">	<span class="keyword">private</span> Screen screen;</span><br><span class="line">	<span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.projector = Projector.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.screen = Screen.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//操作分成 4 步</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123; <span class="comment">//准备</span></span><br><span class="line">		popcorn.on();</span><br><span class="line">		popcorn.pop();</span><br><span class="line">		screen.down();</span><br><span class="line">		projector.on();</span><br><span class="line">		stereo.on();</span><br><span class="line">		dVDPlayer.on();</span><br><span class="line">		theaterLight.dim();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;  <span class="comment">//播放</span></span><br><span class="line">		dVDPlayer.play();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123; <span class="comment">//暂停</span></span><br><span class="line">		dVDPlayer.pause();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;  <span class="comment">//关闭</span></span><br><span class="line">		popcorn.off();</span><br><span class="line">		theaterLight.bright();</span><br><span class="line">		screen.up();</span><br><span class="line">		projector.off();</span><br><span class="line">		stereo.off();</span><br><span class="line">		dVDPlayer.off();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端-10"><a href="#客户端-10" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HomeTheaterFacade homeTheaterFacade = <span class="keyword">new</span> HomeTheaterFacade();</span><br><span class="line">		homeTheaterFacade.ready();</span><br><span class="line">		homeTheaterFacade.play();</span><br><span class="line">		homeTheaterFacade.end();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>1、    外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</p>
<p>2、    外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</p>
<p>3、    通过合理的使用外观模式，可以帮我们更好的划分访问的层次</p>
<p>4、    当系统需要进行分层设计时，可以考虑使用Facade模式</p>
<p>5、    在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</p>
<p>6、    不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</p>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h2><p>1、    享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>2、    常用于系统底层开发，解决系统的性能问题。像<strong>数据库连接池</strong>，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</p>
<p>3、    享元模式能够解决<strong>重复对象的内存浪费的问题</strong>，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</p>
<p>4、    享元模式经典的<strong>应用场景就是池技术</strong>了，String常量池（ JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面 ）、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</p>
<h2 id="原理类图"><a href="#原理类图" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191212153540973" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212153540973.png" class="lazyload"></p>
<p><img alt="image-20191212153602311" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212153602311.png" class="lazyload"></p>
<p>内部状态和外部状态</p>
<blockquote>
<p>内部状态：内容共享</p>
<p>外部状态：内容独立</p>
</blockquote>
<p><img alt="image-20191212153701808" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212153701808.png" class="lazyload"></p>
<h2 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h2><p>网站外包，制作类似产品展示的网站，内容不同</p>
<p><img alt="image-20191212154949700" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212154949700.png" class="lazyload"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="WebSite"><a href="#WebSite" class="headerlink" title="WebSite"></a>WebSite</h3><p>顶级抽象类（接口也行），网站总称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h3><p>具体的网站</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//共享的部分，内部状态</span></span><br><span class="line">	<span class="keyword">private</span> String type = <span class="string">""</span>; <span class="comment">//网站发布的形式(类型)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebSite</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"网站的发布形式为:"</span> + type + <span class="string">" 在使用中 .. 使用者是"</span> + user.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="网站工厂"><a href="#网站工厂" class="headerlink" title="网站工厂"></a>网站工厂</h3><p>用来生产不同类型的网站，使用HashMap作为池的存储</p>
<p>相同类型的实例只创建一次，如果该类型的网站有实例，则返回对象，没有则进行创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 网站工厂类，根据需要返回压一个网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSiteFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//集合， 充当池的作用</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebSite <span class="title">getWebSiteCategory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!pool.containsKey(type)) &#123;</span><br><span class="line">			<span class="comment">//就创建一个网站，并放入到池中</span></span><br><span class="line">			pool.put(type, <span class="keyword">new</span> ConcreteWebSite(type));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (WebSite)pool.get(type);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWebSiteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pool.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端-11"><a href="#客户端-11" class="headerlink" title="客户端"></a>客户端</h3><p>共有三种类型，创建6个网站，相同类型的实例只创建一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String types[] =</span><br><span class="line">			&#123; <span class="string">"新闻"</span>, <span class="string">"博客"</span> , <span class="string">"音乐"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> types[<span class="keyword">new</span> Random().nextInt(types.length)];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个工厂类</span></span><br><span class="line">		WebSiteFactory factory = <span class="keyword">new</span> WebSiteFactory();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 客户要一个以新闻形式发布的网站</span></span><br><span class="line">			WebSite webSite1 = factory.getWebSiteCategory(getType());</span><br><span class="line">			webSite1.use(<span class="keyword">new</span> User(<span class="string">"tom"</span> + i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191212155833214" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212155834806.png" class="lazyload"></p>
<h2 id="Integer源码分析"><a href="#Integer源码分析" class="headerlink" title="Integer源码分析"></a>Integer源码分析</h2><p><img alt="image-20191212160501489" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212160501489.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//如果 Integer.valueOf(x) x 在  -128 --- 127 直接，就是使用享元模式返回,如果不在</span></span><br><span class="line">		<span class="comment">//范围类，则仍然 new </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//小结:</span></span><br><span class="line">		<span class="comment">//1. 在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回</span></span><br><span class="line">		<span class="comment">//2. valueOf 方法，就使用到享元模式</span></span><br><span class="line">		<span class="comment">//3. 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Integer x = Integer.valueOf(<span class="number">127</span>); <span class="comment">// 得到 x实例，类型 Integer</span></span><br><span class="line">		Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">// 得到 y 实例，类型 Integer</span></span><br><span class="line">		Integer z = Integer.valueOf(<span class="number">127</span>);<span class="comment">//..</span></span><br><span class="line">		Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(x.equals(y)); <span class="comment">// 大小，true</span></span><br><span class="line">		System.out.println(x == y ); <span class="comment">//  false</span></span><br><span class="line">		System.out.println(x == z ); <span class="comment">// true</span></span><br><span class="line">		System.out.println(w == x ); <span class="comment">// false</span></span><br><span class="line">		System.out.println(w == y ); <span class="comment">// false</span></span><br><span class="line">			</span><br><span class="line">		Integer x1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		Integer x2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		System.out.println(<span class="string">"x1==x2"</span> + (x1 == x2)); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h3><p>1、 在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回</p>
<p>2、 valueOf 方法，就使用到享元模式</p>
<p>3、 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快</p>
<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>1、    在享元模式这样理解，“享”就表示共享，“元”表示对象</p>
<p>2、    系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</p>
<p>3、    用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储</p>
<p>4、    享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</p>
<p>5、    享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.</p>
<p>6、    使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制</p>
<p>7、    享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="介绍-23"><a href="#介绍-23" class="headerlink" title="介绍"></a>介绍</h2><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</p>
<p>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</p>
<p>代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK代理、接口代理)和 Cglib代理(可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴) 。</p>
<p>代理模式示意图：</p>
<p><img alt="image-20191212163747839" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191212163747839.png" class="lazyload"></p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="介绍-24"><a href="#介绍-24" class="headerlink" title="介绍"></a>介绍</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="顶级接口-1"><a href="#顶级接口-1" class="headerlink" title="顶级接口"></a>顶级接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现类-2"><a href="#实现类-2" class="headerlink" title="实现类"></a>实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师授课中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理实现类"><a href="#代理实现类" class="headerlink" title="代理实现类"></a>代理实现类</h4><p>继承 + 聚合</p>
<p>静态代理对象调用目标方法，可以在前后进行功能扩展，判断等…..</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    静态代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以对目标功能进行扩展</span></span><br><span class="line">        System.out.println(<span class="string">"代理对象开始"</span>);</span><br><span class="line">        target.teach();</span><br><span class="line">        System.out.println(<span class="string">"代理结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-12"><a href="#客户端-12" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象（被代理对象）</span></span><br><span class="line">        TeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">        <span class="comment">//创建代理对象,同时将 被代理对象  传给 代理对象</span></span><br><span class="line">        TeacherDaoProxy proxy = <span class="keyword">new</span> TeacherDaoProxy(teacherDao);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过代理对象，调用到被代理对象的方法</span></span><br><span class="line">        <span class="comment">// 执行的是代理对象的方法，代理对象再去调用被代理对象方法</span></span><br><span class="line">        proxy.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展</p>
<p>缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</p>
<p>一旦接口增加方法,目标对象与代理对象都要维护</p>
<h2 id="动态代理-JDK代理"><a href="#动态代理-JDK代理" class="headerlink" title="动态代理(JDK代理)"></a>动态代理(JDK代理)</h2><h3 id="介绍-25"><a href="#介绍-25" class="headerlink" title="介绍"></a>介绍</h3><p>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</p>
<p>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</p>
<p>动态代理也叫做：JDK代理、接口代理</p>
<p>使用代理类所在包:java.lang.reflect.Proxy</p>
<p>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数、</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="顶级接口和目标实现类"><a href="#顶级接口和目标实现类" class="headerlink" title="顶级接口和目标实现类"></a>顶级接口和目标实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师授课中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello..."</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h4><p>使用<code>Proxy.newProxyInstance</code>的方法返回一个代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ClassLoader loader  指定当前目标对象使用的类加载器，获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            Class&lt;?&gt;[] interfaces   目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            InvocationHandler h     事情处理，指定目标对象的方法时，会触发事情处理器方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"jdk代理开始........"</span>);</span><br><span class="line">                        Object retVal = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"jdk代理结束..........."</span>);</span><br><span class="line">                        <span class="keyword">return</span> retVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-13"><a href="#客户端-13" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        ITeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给目标对象，创建代理对象</span></span><br><span class="line">        ITeacherDao proxyInstance = (ITeacherDao) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//proxyInstance=class com.sun.proxy.$Proxy0</span></span><br><span class="line">        System.out.println(<span class="string">"proxyInstance="</span> + proxyInstance.getClass());</span><br><span class="line"></span><br><span class="line">        proxyInstance.teach();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//proxyInstance.sayHello(" tom ");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img alt="image-20191213153726853" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191213153726853.png" class="lazyload"></p>
<h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><h3 id="介绍-26"><a href="#介绍-26" class="headerlink" title="介绍"></a>介绍</h3><p>静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理</p>
<p>Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</p>
<p>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。</p>
<p>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的<strong>被许多AOP的框架使用</strong>,例如Spring AOP，实现方法拦截</p>
<blockquote>
<p>在AOP编程中如何选择代理模式：</p>
<ol>
<li>目标对象需要实现接口，用JDK代理</li>
<li>目标对象不需要实现接口，用Cglib代理</li>
</ol>
</blockquote>
<p>​    </p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="思路图解"><a href="#思路图解" class="headerlink" title="思路图解"></a>思路图解</h4><p><img alt="image-20191213165434444" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191213165434444.png" class="lazyload"></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><img alt="image-20191213170358180" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191213170358180.png" class="lazyload"></p>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="目标对象类"><a href="#目标对象类" class="headerlink" title="目标对象类"></a>目标对象类</h5><p>没有实现某个接口，独立类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 老师授课中  ， 我是cglib代理，不需要实现接口 "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h5><p>和动态代理流程类似，比动态代理多实现一个<code>getProxyInstance</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">//2. 设置父类</span></span><br><span class="line">		enhancer.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">//3. 设置回调函数</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Cglib代理模式 ~~ 开始"</span>);</span><br><span class="line">		Object returnVal = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">"Cglib代理模式 ~~ 提交"</span>);</span><br><span class="line">		<span class="keyword">return</span> returnVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端-14"><a href="#客户端-14" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        TeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">        <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">        String res = proxyInstance.teach();</span><br><span class="line">        System.out.println(<span class="string">"res="</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img alt="image-20191213170124413" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191213170124413.png" class="lazyload"></p>
<h2 id="代理模式的变体"><a href="#代理模式的变体" class="headerlink" title="代理模式的变体"></a>代理模式的变体</h2><ol>
<li><p>防火墙代理<br>内网通过代理穿透防火墙，实现对公网的访问。</p>
</li>
<li><p>缓存代理<br>比如：当请求图片文件等资源时，先到缓存代理区，如果取到资源则ok,如果取不到资源，再到公网或者数据库取，然后缓存。</p>
</li>
<li><p>远程代理<br>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p>
</li>
<li><p>同步代理：主要使用在多线程编程中，完成多线程间同步工作</p>
</li>
</ol>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="介绍-27"><a href="#介绍-27" class="headerlink" title="介绍"></a>介绍</h2><p>1、    模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>2、    简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</p>
<p>3、    这种类型的设计模式属于行为型模式。</p>
<h2 id="原理类图-1"><a href="#原理类图-1" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191214145358209" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214145358209.png" class="lazyload"></p>
<p>1、    AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现 其它的抽象方法operationr2,3,4<br>2、    ConcreteClass 实现抽象方法operationr2,3,4, 以完成算法中特点子类的步骤</p>
<h2 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h2><blockquote>
<p>制作豆浆</p>
<p>•    制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎<br>•    通过添加不同的配料，可以制作出不同口味的豆浆<br>•    选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的(红豆、花生豆浆。。。)</p>
</blockquote>
<h3 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h3><p>在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。</p>
<p>豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img alt="image-20191214145615257" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214145615257.png" class="lazyload"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        select();</span><br><span class="line">        <span class="keyword">if</span>(customerWantCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">        soak();</span><br><span class="line">        beat();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选材料</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第一步：选择好的新鲜黄豆  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浸泡</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第三步， 黄豆和配料开始浸泡， 需要3小时 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第四步：黄豆和配料放到豆浆机去打碎  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实现类-3"><a href="#实现类-3" class="headerlink" title="实现类"></a>实现类</h4><p>豆浆种类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">" 加入上好的红豆 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">" 加入上好的花生 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//空实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-15"><a href="#客户端-15" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//制作红豆豆浆</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"----制作红豆豆浆----"</span>);</span><br><span class="line">		SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();</span><br><span class="line">		redBeanSoyaMilk.make();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"----制作花生豆浆----"</span>);</span><br><span class="line">		SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();</span><br><span class="line">		peanutSoyaMilk.make();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"----制作纯豆浆----"</span>);</span><br><span class="line">		SoyaMilk pureSoyaMilk = <span class="keyword">new</span> PureSoyaMilk();</span><br><span class="line">		pureSoyaMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191214150104989" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214150104989.png" class="lazyload"></p>
<h2 id="Spring-IOC源码分析"><a href="#Spring-IOC源码分析" class="headerlink" title="Spring IOC源码分析"></a>Spring IOC源码分析</h2><p>Spring IOC容器初始化时运用到模板模式</p>
<p><img alt="image-20191214151108598" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214151108598.png" class="lazyload"></p>
<p><img alt="image-20191214151118208" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214151118208.png" class="lazyload"></p>
<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</p>
</li>
<li><p>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。</p>
</li>
<li><p>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</p>
</li>
</ol>
<p>该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大</p>
<p><strong>一般模板方法都加上final关键字， 防止子类重写模板方法.</strong></p>
<p><span style="color:red"><strong>模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理</strong></span></p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="介绍-28"><a href="#介绍-28" class="headerlink" title="介绍"></a>介绍</h2><p> 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 </p>
<p><img alt="image-20191214163023318" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214163023318.png" class="lazyload"></p>
<p>1、    Invoker 是调用者角色<strong>（将军）</strong><br>2、    Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类<br>3、    Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作<strong>（士兵）</strong><br>4、    ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>遥控器 智能家电项目</p>
<p><img alt="image-20191214163201654" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214163201654.png" class="lazyload"></p>
<h2 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Command命令接口"><a href="#Command命令接口" class="headerlink" title="Command命令接口"></a>Command命令接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="开关接收者"><a href="#开关接收者" class="headerlink" title="开关接收者"></a>开关接收者</h3><p>需要执行电灯、电视机的功能，类似dao层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电灯打开......."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电灯关闭...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" 电视机打开了.. "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">" 电视机关闭了.. "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="开关实现类接口"><a href="#开关实现类接口" class="headerlink" title="开关实现类接口"></a>开关实现类接口</h3><p>将接收者聚合进来，<strong>有点像service层让dao层执行命令一样</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚合LightReceiver</span></span><br><span class="line">    <span class="keyword">private</span> LightReceiver light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚合LightReceiver</span></span><br><span class="line">    <span class="keyword">private</span> LightReceiver light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 聚合TVReceiver</span></span><br><span class="line"></span><br><span class="line">	TVReceiver tv;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TVOffCommand</span><span class="params">(TVReceiver tv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.tv = tv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		tv.off();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		tv.on();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合TVReceiver</span></span><br><span class="line"></span><br><span class="line">    TVReceiver tv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TVOnCommand</span><span class="params">(TVReceiver tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 调用接收者的方法</span></span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 调用接收者的方法</span></span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="调用者"><a href="#调用者" class="headerlink" title="调用者"></a>调用者</h3><p>充当遥控器的角色，存储不同家电的开关命令</p>
<p>负责执行各类家电的开关和撤销工作</p>
<p><img alt="image-20191214163918269" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214163918269.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开按钮命令数组</span></span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    Command[] offCommands;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行撤销的命令</span></span><br><span class="line">    Command undoCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，完成对按钮的初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给我们的按钮设置你需要的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> no,Command onCommand,Command offCommand)</span></span>&#123;</span><br><span class="line">        onCommands[no] = onCommand;</span><br><span class="line">        offCommands[no] = offCommand;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按下开按钮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到你按下的开的按钮，并调用对应方法</span></span><br><span class="line">        onCommands[no].execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录这次的操作，用于撤销</span></span><br><span class="line">        undoCommand = onCommands[no];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按下开按钮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到你按下的开的按钮，并调用对应方法</span></span><br><span class="line">        onCommands[no].execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录这次的操作，用于撤销</span></span><br><span class="line">        undoCommand = onCommands[no];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下撤销按钮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端-16"><a href="#客户端-16" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用命令设计模式，完成通过遥控器，对点灯的操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建电灯的对象（接受者）</span></span><br><span class="line">        LightReceiver lightReceiver = <span class="keyword">new</span> LightReceiver();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建电灯相关的开关命令</span></span><br><span class="line">        LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(lightReceiver);</span><br><span class="line">        LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(lightReceiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要一个遥控器</span></span><br><span class="line">        RemoteController remoteController = <span class="keyword">new</span> RemoteController();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作</span></span><br><span class="line">        remoteController.setCommand(<span class="number">0</span>, lightOnCommand, lightOffCommand);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------按下灯的开按钮-----------"</span>);</span><br><span class="line">        remoteController.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------按下灯的关按钮-----------"</span>);</span><br><span class="line">        remoteController.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------按下撤销按钮-----------"</span>);</span><br><span class="line">        remoteController.undoButtonWasPushed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=========使用遥控器操作电视机=========="</span>);</span><br><span class="line"></span><br><span class="line">        TVReceiver tvReceiver = <span class="keyword">new</span> TVReceiver();</span><br><span class="line"></span><br><span class="line">        TVOffCommand tvOffCommand = <span class="keyword">new</span> TVOffCommand(tvReceiver);</span><br><span class="line">        TVOnCommand tvOnCommand = <span class="keyword">new</span> TVOnCommand(tvReceiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作</span></span><br><span class="line">        remoteController.setCommand(<span class="number">1</span>, tvOnCommand, tvOffCommand);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------按下电视机的开按钮-----------"</span>);</span><br><span class="line">        remoteController.onButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------按下电视机的关按钮-----------"</span>);</span><br><span class="line">        remoteController.offButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------按下撤销按钮-----------"</span>);</span><br><span class="line">        remoteController.undoButtonWasPushed();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img alt="image-20191214164129775" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191214164129775.png" class="lazyload"></p>
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p><img alt="jdbctemplate命令模式" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/jdbctemplate%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" class="lazyload"></p>
<p>角色分析</p>
<ul>
<li>StatementCallback 接口 ,类似命令接口(Command)</li>
<li>class QueryStatementCallback implements StatementCallback<t>, SqlProvider , 匿名内部类，实现了命令接口，同时也充当命令接收者</t></li>
<li>命令调用者是JdbcTemplate , 其中execute(StatementCallback<t> action) 方法中，调用action.doInStatement 方法.  不同的实现StatementCallback 接口的对象，对应不同的doInStatemnt 实现逻辑</t></li>
<li>另外实现 StatementCallback 命令接口的子类还有 QueryStatementCallback</li>
</ul>
<h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p>1、    将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：” 请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。</p>
<p>2、    容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令</p>
<p>3、    <strong>容易实现对请求的撤销和重做</strong></p>
<p>4、    命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意</p>
<p>5、    空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</p>
<p>6、    命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令）订单的撤销/恢复、触发-反馈机制</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="介绍-29"><a href="#介绍-29" class="headerlink" title="介绍"></a>介绍</h2><p>最复杂的设计模式，并且使用频率不高，《设计模式》的作者评价为：大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。</p>
<p>访问者模式是一种将数据操作和数据结构分离的设计模式。</p>
<blockquote>
<p> 借鉴 <a href="https://www.jianshu.com/p/1f1049d0a0f4" target="_blank" rel="noopener">https://www.jianshu.com/p/1f1049d0a0f4</a> </p>
</blockquote>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>对象结构比较稳定，但经常需要在此对象结构上定义新的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ol>
<h2 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h2><p><img alt="img" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7345261-f1b6fe6189c026da.jpg" class="lazyload"></p>
<p>角色介绍</p>
<ul>
<li>Visitor：接口或者抽象类，定义了对每个 Element 访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁地修改 Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。</li>
<li>ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。</li>
<li>Element：元素接口或者抽象类，它定义了一个接受访问者（accept）的方法，其意义是指每一个元素都要可以被访问者访问。<br>ElementA、ElementB：具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li>
<li>ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。</li>
</ul>
<h2 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h2><p>年底，CEO和CTO开始评定员工一年的工作绩效，员工分为工程师和经理，CTO关注工程师的代码量、经理的新产品数量；CEO关注的是工程师的KPI和经理的KPI以及新产品数量。<br>由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同员工类型进行不同的处理。访问者模式此时可以派上用场了。</p>
<h2 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="员工基类"><a href="#员工基类" class="headerlink" title="员工基类"></a>员工基类</h3><p>包含员工 姓名 和 kpi 信息</p>
<p>Staff 类定义了员工基本信息及一个 accept 方法，accept 方法表示接受访问者的访问，由子类具体实现。Visitor 是个接口，传入不同的实现类，可访问不同的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 员工基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kpi;<span class="comment">// 员工KPI</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Staff</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        kpi = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心方法，接受Visitor的访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类"></a>具体实现类</h3><p>工程师和经理的实现类</p>
<p>工程师 ：代码量        经理：产品数量    </p>
<p>两者存在差异性</p>
<p> Staff、Engineer、Manager 3个类型就是<strong>对象结构，这些类型相对稳定</strong>，不会发生变化 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工程师</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engineer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将自己的信息传给访问者访问</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工程师一年的代码数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCodeLines</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span> * <span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将自己的信息传给访问者访问</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一年做的产品数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProducts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h3><p>一个存放员工的列表，可以说是一个业务报表类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 员工业务报表类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessReport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Staff&gt; mStaffs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStaffs.add(<span class="keyword">new</span> Manager(<span class="string">"经理-A"</span>));</span><br><span class="line">        mStaffs.add(<span class="keyword">new</span> Engineer(<span class="string">"工程师-A"</span>));</span><br><span class="line">        mStaffs.add(<span class="keyword">new</span> Engineer(<span class="string">"工程师-B"</span>));</span><br><span class="line">        mStaffs.add(<span class="keyword">new</span> Engineer(<span class="string">"工程师-C"</span>));</span><br><span class="line">        mStaffs.add(<span class="keyword">new</span> Manager(<span class="string">"经理-B"</span>));</span><br><span class="line">        mStaffs.add(<span class="keyword">new</span> Engineer(<span class="string">"工程师-D"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为访问者展示报表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> visitor 公司高层，如CEO、CTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showReport</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Staff staff : mStaffs) &#123;</span><br><span class="line">            staff.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="访问者接口"><a href="#访问者接口" class="headerlink" title="访问者接口"></a>访问者接口</h3><p>首先定义了一个 Visitor 接口，该接口有两个 visit 函数，参数分别是 Engineer、Manager，也就是说对于 Engineer、Manager 的访问会调用两个不同的方法，以此达成区别对待、差异化处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问工程师类型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问经理类型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager manager)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="具体访问者"><a href="#具体访问者" class="headerlink" title="具体访问者"></a>具体访问者</h3><p>CEO、CTO类，各自访问所需要的内容</p>
<p>在CEO的访问者中，CEO关注工程师的 KPI，经理的 KPI 和新产品数量 </p>
<p>在CTO的访问者中，CTO关注工程师的代码量、经理的新产品数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CEO访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工程师: "</span> + engineer.name + <span class="string">", KPI: "</span> + engineer.kpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager manager)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"经理: "</span> + manager.name + <span class="string">", KPI: "</span> + manager.kpi +</span><br><span class="line">                <span class="string">", 新产品数量: "</span> + manager.getProducts());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CTO访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CTOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工程师: "</span> + engineer.name + <span class="string">", 代码行数: "</span> + engineer.getCodeLines());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager manager)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"经理: "</span> + manager.name + <span class="string">", 产品数量: "</span> + manager.getProducts());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端-17"><a href="#客户端-17" class="headerlink" title="客户端"></a>客户端</h3><p>报表根据不同访问者访问不同的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建报表</span></span><br><span class="line">        BusinessReport report = <span class="keyword">new</span> BusinessReport();</span><br><span class="line">        System.out.println(<span class="string">"=========== CEO看报表 ==========="</span>);</span><br><span class="line">        report.showReport(<span class="keyword">new</span> CEOVisitor());</span><br><span class="line">        System.out.println(<span class="string">"=========== CTO看报表 ==========="</span>);</span><br><span class="line">        report.showReport(<span class="keyword">new</span> CTOVisitor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下<br><img alt="image-20191215151225079" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191215151225079.png" class="lazyload"></p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>在上述示例中，Staff 扮演了 Element 角色，而 Engineer 和 Manager 都是 ConcreteElement；CEOVisitor 和 CTOVisitor 都是具体的 Visitor 对象；而 BusinessReport 就是 ObjectStructure；Client就是客户端代码</p>
<h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p>访问者模式的优点。</p>
<ol>
<li><strong>各角色职责分离，符合单一职责原则</strong><br>通过UML类图和上面的示例可以看出来，Visitor、ConcreteVisitor、Element 、ObjectStructure，职责单一，各司其责。</li>
<li><strong>具有优秀的扩展性</strong><br>如果需要增加新的访问者，增加实现类 ConcreteVisitor 就可以快速扩展。</li>
<li><strong>使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化</strong><br>员工属性（数据结构）和CEO、CTO访问者（数据操作）的解耦。</li>
<li><strong>灵活性</strong></li>
</ol>
<p>访问者模式的缺点。</p>
<ol>
<li><strong>具体元素对访问者公布细节，违反了迪米特原则</strong><br>CEO、CTO需要调用具体员工的方法。</li>
<li><strong>具体元素变更时导致修改成本大</strong><br>变更员工属性时，多个访问者都要修改。</li>
<li><strong>违反了依赖倒置原则，为了达到“区别对待”而依赖了具体类，没有以来抽象</strong><br>访问者 visit 方法中，依赖了具体员工的具体方法。</li>
</ol>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="介绍-30"><a href="#介绍-30" class="headerlink" title="介绍"></a>介绍</h2><p>迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式</p>
<p>如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</p>
<p>迭代器模式    提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。</p>
<h2 id="原理类图-2"><a href="#原理类图-2" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191216104851689" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191216104851689.png" class="lazyload"></p>
<p>角色职责</p>
<ol>
<li>Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove</li>
<li>ConcreteIterator : 具体的迭代器类，管理迭代</li>
<li>Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦</li>
</ol>
<h2 id="案例-10"><a href="#案例-10" class="headerlink" title="案例"></a>案例</h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><img alt="迭代器案例uml类图" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A1%88%E4%BE%8Buml%E7%B1%BB%E5%9B%BE.png" class="lazyload"></p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="迭代器模块"><a href="#迭代器模块" class="headerlink" title="迭代器模块"></a>迭代器模块</h4><p>迭代器类实现Iterator接口，重写<code>hasNext</code> <code>next</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信息院系的迭代器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoCollegeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们需要Department 是以怎样的方式存放</span></span><br><span class="line">    List&lt;Department&gt; departments;</span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">// 遍历的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoCollegeIterator</span><span class="params">(List&lt;Department&gt; departments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.departments = departments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position &gt;= departments.size() -<span class="number">1</span> || departments.get(position) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Department department = departments.get(position);</span><br><span class="line">        position += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollegeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们需要Department 是以怎样的方式存放</span></span><br><span class="line">    Department[] departments;</span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">// 遍历的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComputerCollegeIterator</span><span class="params">(Department[] departments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.departments = departments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position &gt;= departments.length || departments[position] == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Department department = departments[position];</span><br><span class="line">        position += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="院系模块"><a href="#院系模块" class="headerlink" title="院系模块"></a>院系模块</h4><p>自建了两个院系，构造方法默认了几个专业</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="keyword">int</span> numOfDepartment = <span class="number">0</span> ;<span class="comment">// 保存当前数组的对象个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ComputerCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departments = <span class="keyword">new</span> Department[<span class="number">5</span>];</span><br><span class="line">		addDepartment(<span class="string">"Java专业"</span>, <span class="string">" Java专业 "</span>);</span><br><span class="line">		addDepartment(<span class="string">"PHP专业"</span>, <span class="string">" PHP专业 "</span>);</span><br><span class="line">		addDepartment(<span class="string">"大数据专业"</span>, <span class="string">" 大数据专业 "</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"计算机学院"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departments[numOfDepartment] = department;</span><br><span class="line">		numOfDepartment += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ComputerCollegeIterator(departments);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	List&lt;Department&gt; departmentList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InfoCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departmentList = <span class="keyword">new</span> ArrayList&lt;Department&gt;();</span><br><span class="line">		addDepartment(<span class="string">"信息安全专业"</span>, <span class="string">" 信息安全专业 "</span>);</span><br><span class="line">		addDepartment(<span class="string">"网络安全专业"</span>, <span class="string">" 网络安全专业 "</span>);</span><br><span class="line">		addDepartment(<span class="string">"服务器安全专业"</span>, <span class="string">" 服务器安全专业 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"信息工程学院"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departmentList.add(department);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InfoCollegeIterator(departmentList);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="输出类"><a href="#输出类" class="headerlink" title="输出类"></a>输出类</h4><p>负责输出学院里的专业</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPutImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//学院集合</span></span><br><span class="line">	List&lt;College&gt; collegeList;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OutPutImpl</span><span class="params">(List&lt;College&gt; collegeList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.collegeList = collegeList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有学院,然后调用printDepartment 输出各个学院的系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从collegeList 取出所有学院, Java 中的 List 已经实现Iterator</span></span><br><span class="line">		Iterator&lt;College&gt; iterator = collegeList.iterator();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			<span class="comment">//取出一个学院</span></span><br><span class="line">			College college = iterator.next();</span><br><span class="line">			System.out.println(<span class="string">"=== "</span>+college.getName() +<span class="string">"====="</span> );</span><br><span class="line">			printDepartment(college.createIterator()); <span class="comment">//得到对应迭代器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出 学院输出 系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printDepartment</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			Department d = (Department)iterator.next();</span><br><span class="line">			System.out.println(d.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-18"><a href="#客户端-18" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//创建学院</span></span><br><span class="line">        List&lt;College&gt; collegeList = <span class="keyword">new</span> ArrayList&lt;College&gt;();</span><br><span class="line"></span><br><span class="line">        ComputerCollege computerCollege = <span class="keyword">new</span> ComputerCollege();</span><br><span class="line">        InfoCollege infoCollege = <span class="keyword">new</span> InfoCollege();</span><br><span class="line"></span><br><span class="line">        collegeList.add(computerCollege);</span><br><span class="line">        <span class="comment">//collegeList.add(infoCollege);</span></span><br><span class="line"></span><br><span class="line">        OutPutImpl outPutImpl = <span class="keyword">new</span> OutPutImpl(collegeList);</span><br><span class="line">        outPutImpl.printCollege();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191216111516951" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191216111516951.png" class="lazyload"></p>
<h2 id="ArrayList源码"><a href="#ArrayList源码" class="headerlink" title="ArrayList源码"></a>ArrayList源码</h2><p><img alt="image-20191221095539988" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221095539988.png" class="lazyload"></p>
<p>角色分析</p>
<ul>
<li>内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类</li>
<li>List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象</li>
<li>ArrayList 是实现聚合接口List 的子类，实现了iterator()</li>
<li>Iterator 接口系统提供</li>
<li>迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</li>
</ul>
<h2 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1)    提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。<br>2)    隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。<br>3)    提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做<strong>单一责任原则</strong>）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。<br>4)    当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类</p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="介绍-31"><a href="#介绍-31" class="headerlink" title="介绍"></a>介绍</h2><p>观察者模式的定义：<br>　　在对象之间定义了<strong>一对多</strong>的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。</p>
<div style="color:red">
    <strong>
        大白话：<br>
        其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。<br><br>
        类似于消息队列<br><br>
    </strong>
</div>

<h2 id="原理类图-3"><a href="#原理类图-3" class="headerlink" title="原理类图"></a>原理类图</h2><ol>
<li>气象局：Subject</li>
<li>用户/第三方网站：Observer</li>
</ol>
<p><img alt="image-20191221104734390" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221104734390.png" class="lazyload"></p>
<p>Subject：登记注册、移除和通知</p>
<ol>
<li>registerObserver 注册</li>
<li>removeObserver 移除</li>
<li>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送，看具体需求定</li>
</ol>
<p>Observer:  接收输入</p>
<h2 id="案例-11"><a href="#案例-11" class="headerlink" title="案例"></a>案例</h2><blockquote>
<p>天气预报项目需求</p>
<p>1、    气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。<br>2、    需要设计开放型API，便于其他第三方也能接入气象站获取数据。<br>3、    提供温度、气压和湿度的接口<br>测量数据更新时，要能实时的通知给第三方</p>
</blockquote>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="总部抽象类"><a href="#总部抽象类" class="headerlink" title="总部抽象类"></a>总部抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="comment">//注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="comment">//移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="comment">//提醒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="气象局实现类"><a href="#气象局实现类" class="headerlink" title="气象局实现类"></a>气象局实现类</h4><p>将订阅方存放到<code>ArrayList</code>中进行管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName WeatherData</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/12/21</span></span><br><span class="line"><span class="comment"> * Time      10:24</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  天气局 总部 包含数据</span></span><br><span class="line"><span class="comment"> *  类是核心</span></span><br><span class="line"><span class="comment"> *  1. 包含最新的天气情况信息</span></span><br><span class="line"><span class="comment"> *  2. 含有 观察者集合，使用ArrayList管理</span></span><br><span class="line"><span class="comment"> *  3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherDataServer</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 温度，气压，湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherDataServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用 接入方的 update</span></span><br><span class="line"></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当数据有更新时，就调用 setData   并发送通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册一个观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除一个观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(observers.contains(o)) &#123;</span><br><span class="line">            observers.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有的观察者，并通知</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">            observers.get(i).update(<span class="keyword">this</span>.temperature, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="观察者（订阅方）"><a href="#观察者（订阅方）" class="headerlink" title="观察者（订阅方）"></a>观察者（订阅方）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature   温度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre           气压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity      湿度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature,<span class="keyword">float</span> pre,<span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h4><p>百度天气  和新浪天气  实现观察者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baidu</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 温度，气压，湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature 温度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressure    气压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity    湿度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"baidu...."</span>);</span><br><span class="line">        System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>);</span><br><span class="line">        System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>);</span><br><span class="line">        System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sina</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 温度，气压，湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature 温度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressure    气压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity    湿度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sina..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>);</span><br><span class="line">        System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>);</span><br><span class="line">        System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-19"><a href="#客户端-19" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个WeatherDataServer 气象服务站</span></span><br><span class="line">        WeatherDataServer weatherData = <span class="keyword">new</span> WeatherDataServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建观察者</span></span><br><span class="line">        Baidu baiduSite = <span class="keyword">new</span> Baidu();</span><br><span class="line">        Sina sinaSite = <span class="keyword">new</span> Sina();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册到weatherData</span></span><br><span class="line">        weatherData.registerObserver(baiduSite);</span><br><span class="line">        weatherData.registerObserver(sinaSite);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">"通知各个注册的观察者, 看看信息"</span>);</span><br><span class="line">        weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        weatherData.removeObserver(baiduSite);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"通知各个注册的观察者, 看看信息"</span>);</span><br><span class="line">        weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img alt="image-20191221105645782" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221105645782.png" class="lazyload"></p>
<h2 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h2><p><strong>优点：</strong></p>
<p> 1、观察者和被观察者是抽象耦合的。</p>
<p> 2、建立一套触发机制。</p>
<p><strong>缺点：</strong></p>
<p> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </p>
<p>2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </p>
<p>3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="介绍-32"><a href="#介绍-32" class="headerlink" title="介绍"></a>介绍</h2><p><strong>中介者模式（Mediator Pattern）</strong>，用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<p>中介者模式属于行为型模式，使代码易于维护</p>
<p>比如MVC模式，C（Controller控制器）是M（Model模型）和V（View视图）的中介者，在前后端交互时起到了中间人的作用</p>
<h2 id="原理类图-4"><a href="#原理类图-4" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191221144542085" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221144542085.png" class="lazyload"></p>
<p>角色分析</p>
<img alt="image-20191221144613045" style="zoom:150%;" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221144613045.png" class="lazyload">





<h2 id="案例-12"><a href="#案例-12" class="headerlink" title="案例"></a>案例</h2><p>智能家居 和外观模式例子一样</p>
<p><img alt="image-20191221144731790" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221144731790.png" class="lazyload"></p>
<img alt="image-20191221144801156" style="zoom:120%;" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221144801156.png" class="lazyload">



<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><h4 id="家用设备抽象类"><a href="#家用设备抽象类" class="headerlink" title="家用设备抽象类"></a>家用设备抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同事抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mediator mediator;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mediator <span class="title">GetMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.mediator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="家用电器实现类"><a href="#家用电器实现类" class="headerlink" title="家用电器实现类"></a>家用电器实现类</h4><p>闹钟 、 窗帘 、 电视机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------------------闹钟-------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Alarm</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="comment">//在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合]</span></span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendAlarm</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		SendMessage(stateChange);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//调用的中介者对象的getMessage</span></span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------窗帘---------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Curtains</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Curtains</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpCurtains</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I am holding Up Curtains!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------电视机-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TV</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartTv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"It's time to StartTv!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopTv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"StopTv!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中介者抽象类"><a href="#中介者抽象类" class="headerlink" title="中介者抽象类"></a>中介者抽象类</h4><p><code>Register</code>将点用电器注册到<code>hashmap</code>中</p>
<p><code>GetMessage</code>接收信息后做一系列动作</p>
<p><code>SendMessage</code>空方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将给中介者对象，加入到集合中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//接收消息, 具体的同事对象发出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中介者实现类"><a href="#中介者实现类" class="headerlink" title="中介者实现类"></a>中介者实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体的中介者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合，放入所有的同事对象</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		colleagueMap = <span class="keyword">new</span> HashMap&lt;String, Colleague&gt;();</span><br><span class="line">		interMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		colleagueMap.put(colleagueName, colleague);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			interMap.put(<span class="string">"Alarm"</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			interMap.put(<span class="string">"CoffeeMachine"</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">			interMap.put(<span class="string">"TV"</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			interMap.put(<span class="string">"Curtains"</span>, colleagueName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体中介者的核心方法</span></span><br><span class="line">	<span class="comment">//1. 根据得到消息，完成对应任务</span></span><br><span class="line">	<span class="comment">//2. 中介者在这个方法，协调各个具体的同事对象，完成任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//处理闹钟发出的消息</span></span><br><span class="line">		<span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123; <span class="comment">//当闹钟响起，制作咖啡 打开电视.....</span></span><br><span class="line">				((CoffeeMachine) (colleagueMap.get(interMap</span><br><span class="line">						.get(<span class="string">"CoffeeMachine"</span>)))).StartCoffee();</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StartTv();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StopTv();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			((Curtains) (colleagueMap.get(interMap.get(<span class="string">"Curtains"</span>))))</span><br><span class="line">					.UpCurtains();</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;<span class="comment">//如果TV发现消息</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			<span class="comment">//如果是以窗帘发出的消息，这里处理...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-20"><a href="#客户端-20" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个中介者对象</span></span><br><span class="line">		Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建Alarm 并且加入到  ConcreteMediator 对象的HashMap</span></span><br><span class="line">		Alarm alarm = <span class="keyword">new</span> Alarm(mediator, <span class="string">"alarm"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建了CoffeeMachine 对象，并  且加入到  ConcreteMediator 对象的HashMap</span></span><br><span class="line">		CoffeeMachine coffeeMachine = <span class="keyword">new</span> CoffeeMachine(mediator,</span><br><span class="line">				<span class="string">"coffeeMachine"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建 Curtains , 并  且加入到  ConcreteMediator 对象的HashMap</span></span><br><span class="line">		Curtains curtains = <span class="keyword">new</span> Curtains(mediator, <span class="string">"curtains"</span>);</span><br><span class="line">		TV tV = <span class="keyword">new</span> TV(mediator, <span class="string">"TV"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//让闹钟发出消息</span></span><br><span class="line">		alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">		coffeeMachine.FinishCoffee();</span><br><span class="line">		alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h2><ol>
<li>多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦</li>
<li>减少类间依赖，降低了耦合，符合迪米特原则</li>
<li>中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li>
<li>如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</li>
</ol>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="介绍-33"><a href="#介绍-33" class="headerlink" title="介绍"></a>介绍</h2><p> 备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式 </p>
<p> <strong>应用实例：</strong> </p>
<p>1、后悔药。 2、打游戏时的存档。 3、Windows 里的 <code>ctri + z</code>。 4、IE 中的后退。 4、数据库的事务管理 </p>
<p> <strong>使用场景：</strong></p>
<p> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作 </p>
<h2 id="原理类图-5"><a href="#原理类图-5" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="备忘录模式的 UML 图" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/memento_pattern_uml_diagram.jpg" class="lazyload"></p>
<p>备忘录模式使用三个类 <em>Memento<em>、</em>Originator</em> 和 <em>CareTaker</em>。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。</p>
<p><em>MementoPatternDemo*，我们的演示类使用 *CareTaker</em> 和 <em>Originator</em> 对象来显示对象的状态恢复</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p>备份每一次的状态记录</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h4><p>将状态封装成<code>Memento</code>备忘录对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Caretaker"><a href="#Caretaker" class="headerlink" title="Caretaker"></a>Caretaker</h4><p><code>mementoList</code>存放着每一次的状态记录</p>
<p>负责增加之前的记录  和获取之前的记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在List 集合中会有很多的备忘录对象</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		mementoList.add(memento);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取到第index个Originator 的 备忘录对象(即保存状态)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Originator"><a href="#Originator" class="headerlink" title="Originator"></a>Originator</h4><p>每次的记录对象</p>
<ol>
<li><p><code>saveStateMemento</code>方法返回当前状态信息的<code>Memento</code>封装对象，交给<code>Caretaker</code> 保存到<code>mementoList</code>中</p>
</li>
<li><p><code>getStateFromMemento</code>方法为从<code>Caretaker</code> 中获取到某一个时间点的<code>Memento</code>封装对象，读取出来</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String state;<span class="comment">//状态信息</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//编写一个方法，可以保存一个状态对象 Memento</span></span><br><span class="line">	<span class="comment">//因此编写一个方法，返回 Memento</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过备忘录对象，恢复状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		state = memento.getState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-21"><a href="#客户端-21" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">		originator.setState(<span class="string">" 状态#1 攻击力 100 "</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//保存了当前的状态</span></span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">		originator.setState(<span class="string">" 状态#2 攻击力 80 "</span>);</span><br><span class="line"></span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">		originator.setState(<span class="string">" 状态#3 攻击力 50 "</span>);</span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"当前的状态是 ="</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//希望得到状态 1, 将 originator 恢复到状态1</span></span><br><span class="line"></span><br><span class="line">		originator.getStateFromMemento(caretaker.get(<span class="number">0</span>));</span><br><span class="line">		System.out.println(<span class="string">"恢复到状态1 , 当前的状态是"</span>);</span><br><span class="line">		System.out.println(<span class="string">"当前的状态是 ="</span> + originator.getState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191221152248828" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221152248828.png" class="lazyload"></p>
<h2 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h2><p><strong>优点：</strong> </p>
<p>1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</p>
<p>2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存</p>
<h1 id="解释器模式-1"><a href="#解释器模式-1" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="介绍-34"><a href="#介绍-34" class="headerlink" title="介绍"></a>介绍</h2><p> 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等 </p>
<p> <strong>使用场景：</strong></p>
<p> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 </p>
<p>2、一些重复出现的问题可以用一种简单的语言来进行表达。 </p>
<p>3、一个简单语法需要解释的场景。 </p>
<h2 id="原理类图-6"><a href="#原理类图-6" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191221201425964" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221201425964.png" class="lazyload"></p>
<p>角色分析</p>
<ol>
<li>Context: 是环境角色,含有解释器之外的全局信息.</li>
<li>AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所共享</li>
<li>TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作</li>
<li>NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作.</li>
</ol>
<h2 id="案例-13"><a href="#案例-13" class="headerlink" title="案例"></a>案例</h2><p>计算 a + b - c 的值</p>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="抽象表达式类"><a href="#抽象表达式类" class="headerlink" title="抽象表达式类"></a>抽象表达式类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类表达式，通过HashMap 键值对, 可以获取到变量的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="comment">// a + b - c</span></span><br><span class="line">	<span class="comment">// 解释公式和数值, key 就是公式(表达式) 参数[a,b,c], value就是就是具体值</span></span><br><span class="line">	<span class="comment">// HashMap &#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实现类-4"><a href="#实现类-4" class="headerlink" title="实现类"></a>实现类</h4><p>加法、减法、变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> <span class="keyword">extends</span> <span class="title">SymbolExpression</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AddExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(left, right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理相加</span></span><br><span class="line">	<span class="comment">//var 仍然是 &#123;a=10,b=20&#125;..</span></span><br><span class="line">	<span class="comment">//一会我们debug 源码,就ok</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10</span></span><br><span class="line">		<span class="comment">//super.right.interpreter(var): 返回right 表达式对应值 b = 20</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.left.interpreter(<span class="keyword">var</span>) + <span class="keyword">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubExpression</span> <span class="keyword">extends</span> <span class="title">SymbolExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(left, right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//求出left 和 right 表达式相减后的结果</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.left.interpreter(<span class="keyword">var</span>) - <span class="keyword">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String key; <span class="comment">// key=a,key=b,key=c</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VarExpression</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// var 就是&#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="comment">// interpreter 根据 变量名称，返回对应值</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">var</span>.get(<span class="keyword">this</span>.key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Calculator"><a href="#Calculator" class="headerlink" title="Calculator"></a>Calculator</h4><p>计算器，包含表达式成员变量，在构造函数中将输入的字符串转成表达式包裹在成员变量中，使用Stack 栈进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义表达式</span></span><br><span class="line">	<span class="keyword">private</span> Expression expression;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数传参，并解析</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String expStr)</span> </span>&#123; <span class="comment">// expStr = a+b</span></span><br><span class="line">		<span class="comment">// 安排运算先后顺序</span></span><br><span class="line">		Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">// 表达式拆分成字符数组</span></span><br><span class="line">		<span class="keyword">char</span>[] charArray = expStr.toCharArray();<span class="comment">// [a, +, b]</span></span><br><span class="line"></span><br><span class="line">		Expression left = <span class="keyword">null</span>;</span><br><span class="line">		Expression right = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//遍历我们的字符数组， 即遍历  [a, +, b]</span></span><br><span class="line">		<span class="comment">//针对不同的情况，做处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (charArray[i]) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'+'</span>: <span class="comment">//</span></span><br><span class="line">					left = stack.pop();<span class="comment">// 从stack取出left =&gt; "a"</span></span><br><span class="line">					right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));<span class="comment">// 取出右表达式 "b"</span></span><br><span class="line">					stack.push(<span class="keyword">new</span> AddExpression(left, right));<span class="comment">// 然后根据得到left 和 right 构建 AddExpresson加入stack</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'-'</span>: <span class="comment">//</span></span><br><span class="line">					left = stack.pop();</span><br><span class="line">					right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));</span><br><span class="line">					stack.push(<span class="keyword">new</span> SubExpression(left, right));</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="comment">//如果是一个 Var 就创建要给 VarExpression 对象，并push到 stack</span></span><br><span class="line">					stack.push(<span class="keyword">new</span> VarExpression(String.valueOf(charArray[i])));</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当遍历完整个 charArray 数组后，stack 就得到最后Expression</span></span><br><span class="line">		<span class="keyword">this</span>.expression = stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//最后将表达式a+b和 var = &#123;a=10,b=20&#125;</span></span><br><span class="line">		<span class="comment">//然后传递给expression的interpreter进行解释执行</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.expression.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-22"><a href="#客户端-22" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		String expStr = getExpStr(); <span class="comment">// a+b</span></span><br><span class="line">		HashMap&lt;String, Integer&gt; <span class="keyword">var</span> = getValue(expStr);<span class="comment">// var &#123;a=10, b=20&#125;</span></span><br><span class="line">		Calculator calculator = <span class="keyword">new</span> Calculator(expStr);</span><br><span class="line">		System.out.println(<span class="string">"运算结果："</span> + expStr + <span class="string">"="</span> + calculator.run(<span class="keyword">var</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得表达式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExpStr</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"请输入表达式："</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得值映射</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getValue</span><span class="params">(String expStr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> ch : expStr.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch != <span class="string">'+'</span> &amp;&amp; ch != <span class="string">'-'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!map.containsKey(String.valueOf(ch))) &#123;</span><br><span class="line">					System.out.print(<span class="string">"请输入"</span> + String.valueOf(ch) + <span class="string">"的值："</span>);</span><br><span class="line">					String in = (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">					map.put(String.valueOf(ch), Integer.valueOf(in));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191221202149442" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191221202149442.png" class="lazyload"></p>
<h2 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h2><p><strong>应用实例：</strong>编译器、运算表达式计算。</p>
<p><strong>优点：</strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p>
<p><strong>缺点：</strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="介绍-35"><a href="#介绍-35" class="headerlink" title="介绍"></a>介绍</h2><p>状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换</p>
<p>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类</p>
<h2 id="原理类图-7"><a href="#原理类图-7" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191222143415882" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222143415882.png" class="lazyload"></p>
<ol>
<li>Context 类为环境角色, 用于维护State实例,这个实例定义当前状态</li>
<li>State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为</li>
<li>ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为</li>
</ol>
<h2 id="案例-14"><a href="#案例-14" class="headerlink" title="案例"></a>案例</h2><p>电灯当前的开关状态</p>
<h3 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="状态接口"><a href="#状态接口" class="headerlink" title="状态接口"></a>状态接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  执行状态的修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context   上下文环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开和关两种状态"><a href="#开和关两种状态" class="headerlink" title="开和关两种状态"></a>开和关两种状态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    电灯开状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">"light open ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    电灯关状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">"light close ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上下文环境"><a href="#上下文环境" class="headerlink" title="上下文环境"></a>上下文环境</h4><p>用来存放当前的电灯状态  作为成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    上下文环境角色，包含着当前电灯的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">if</span>( state <span class="keyword">instanceof</span>  OpenState)&#123;</span><br><span class="line">            System.out.println(<span class="string">"current light open ..."</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"current light close ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-23"><a href="#客户端-23" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、创建上下文环境  +  开关状态实例</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        CloseState closeState = <span class="keyword">new</span> CloseState();</span><br><span class="line">        OpenState openState = <span class="keyword">new</span> OpenState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看当前电灯状态</span></span><br><span class="line">        context.getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、开灯  切换状态</span></span><br><span class="line">        openState.doAction(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、关灯  切换状态</span></span><br><span class="line">        closeState.doAction(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img alt="image-20191222145155632" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222145155632.png" class="lazyload"></p>
<h2 id="借贷平台订单模块"><a href="#借贷平台订单模块" class="headerlink" title="借贷平台订单模块"></a>借贷平台订单模块</h2><p>当前订单状态包含很多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[电审] --&gt;B[电审失败]</span><br><span class="line">    A --&gt; C[定价发布]</span><br><span class="line">    C --&gt; D[无人接单失败]</span><br><span class="line">    C --&gt; E[接单]</span><br><span class="line">    E --&gt; F[付款失败]</span><br><span class="line">    E --&gt; G[付款]</span><br><span class="line">    G --&gt; H[反馈]</span><br></pre></td></tr></table></figure>



<h3 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h3><p>自行实现 ……</p>
<h2 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h2><ol>
<li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li>
<li>方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错</li>
<li>符合“开闭原则”。容易增删状态</li>
<li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度</li>
<li>应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式</li>
</ol>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="介绍-36"><a href="#介绍-36" class="headerlink" title="介绍"></a>介绍</h2><p>​        策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</p>
<pre><code>创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法 </code></pre><h2 id="原理类图-8"><a href="#原理类图-8" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191222152659276" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222152659276.png" class="lazyload"></p>
<h2 id="案例-15"><a href="#案例-15" class="headerlink" title="案例"></a>案例</h2><p>根据四则运算指定 +  — * 三种策略，修改不同策略执行不同的操作</p>
<h3 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="策略实现类"><a href="#策略实现类" class="headerlink" title="策略实现类"></a>策略实现类</h4><p>指定各自的运算方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="上下文环境-1"><a href="#上下文环境-1" class="headerlink" title="上下文环境"></a>上下文环境</h4><p>保存当前的何种策略模式    并执行相应的策略操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SetStrategy</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="客户端-24"><a href="#客户端-24" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(); </span><br><span class="line">       </span><br><span class="line">      context.SetStrategy(<span class="keyword">new</span> OperationAdd());</span><br><span class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context.SetStrategy(<span class="keyword">new</span> OperationSubstract());      </span><br><span class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context.SetStrategy(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191222153609955" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222153609955.png" class="lazyload"></p>
<h2 id="策略-VS-状态"><a href="#策略-VS-状态" class="headerlink" title="策略 VS 状态"></a>策略 VS 状态</h2><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。</p>
<p><strong>但是状态模式是通过状态转移来改变 Context 所组合的 State 对象<code>openState.doAction(context);</code>，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象<code>context.SetStrategy(new OperationAdd());</code></strong>。</p>
<p>所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h2 id="Arrays源码分析"><a href="#Arrays源码分析" class="headerlink" title="Arrays源码分析"></a>Arrays源码分析</h2><p><img alt="image-20191222154333594" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222154333594.png" class="lazyload"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//数组</span></span><br><span class="line">		Integer[] data = &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">		<span class="comment">// 实现降序排序，返回-1放左边，1放右边，0保持不变</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">// 1. 实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator&lt;Integer&gt;()&#123;..&#125;</span></span><br><span class="line">		<span class="comment">// 2. 对象 new Comparator&lt;Integer&gt;()&#123;..&#125; 就是实现了 策略接口 的对象</span></span><br><span class="line">		<span class="comment">// 3. public int compare(Integer o1, Integer o2)&#123;&#125; 指定具体的处理方式</span></span><br><span class="line">		Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span></span><br><span class="line"><span class="comment">		        if (c == null) &#123;</span></span><br><span class="line"><span class="comment">		            sort(a); //默认方法</span></span><br><span class="line"><span class="comment">		        &#125; else &#123; </span></span><br><span class="line"><span class="comment">		            if (LegacyMergeSort.userRequested)</span></span><br><span class="line"><span class="comment">		                legacyMergeSort(a, c); //使用策略对象c</span></span><br><span class="line"><span class="comment">		            else</span></span><br><span class="line"><span class="comment">		            	// 使用策略对象c</span></span><br><span class="line"><span class="comment">		                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span></span><br><span class="line"><span class="comment">		        &#125;</span></span><br><span class="line"><span class="comment">		    &#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//方式1 </span></span><br><span class="line">		Arrays.sort(data, comparator);</span><br><span class="line">		</span><br><span class="line">		System.out.println(Arrays.toString(data)); <span class="comment">// 降序排序</span></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式2- 同时lambda 表达式实现 策略模式</span></span><br><span class="line">		Integer[] data2 = &#123; <span class="number">19</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">13</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(data2, (var1, var2) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(var1.compareTo(var2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"data2="</span> + Arrays.toString(data2));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h2><ol>
<li>策略模式的关键是：分析项目中变化部分与不变部分</li>
<li>策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性</li>
<li><strong>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else）</strong></li>
<li>提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展</li>
<li>需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li>
</ol>
<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="介绍-37"><a href="#介绍-37" class="headerlink" title="介绍"></a>介绍</h2><ol>
<li>职责链模式（Chain of Responsibility Pattern）,又叫责任链模式，为请求创建了一个接收者对象的链(简单示意图)。这种模式对请求的发送者和接收者进行解耦。</li>
<li>职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</li>
<li>这种类型的设计模式属于行为型模式</li>
</ol>
<h3 id="最佳应用场景"><a href="#最佳应用场景" class="headerlink" title="最佳应用场景"></a>最佳应用场景</h3><p>有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器</p>
<h2 id="原理类图-9"><a href="#原理类图-9" class="headerlink" title="原理类图"></a>原理类图</h2><p><img alt="image-20191222160437096" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222160437096.png" class="lazyload"></p>
<ol>
<li>Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler</li>
<li>ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处理者), 如果可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链</li>
<li>Request ， 含义很多属性，表示一个请求</li>
</ol>
<h2 id="案例-16"><a href="#案例-16" class="headerlink" title="案例"></a>案例</h2><p>编写程序完成学校OA系统的采购审批项目：需求</p>
<p>①如果金额小于等于5000, 由教学主任审批<br>②如果金额小于等于10000, 由院长审批<br>④如果金额超过30000以上，由校长审批</p>
<p><img alt data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E7%B1%BB%E5%9B%BE.png" class="lazyload"></p>
<h3 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="抽象处理者类"><a href="#抽象处理者类" class="headerlink" title="抽象处理者类"></a>抽象处理者类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line">    Approver nextApprover; <span class="comment">//下一个处理者（节点）</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprover</span><span class="params">(Approver nextApprover)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextApprover = nextApprover;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理者实现类"><a href="#处理者实现类" class="headerlink" title="处理者实现类"></a>处理者实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No1Approver</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">No1Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( purchaseRequest.getPrice() &lt;= <span class="number">5000</span>)&#123; <span class="comment">//我负责</span></span><br><span class="line">           System.out.println(<span class="string">"编号:"</span> + purchaseRequest.getId() + <span class="keyword">this</span>.name + <span class="string">" 处理中...."</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123; <span class="comment">//我负责不了，给下一个负责人</span></span><br><span class="line">           nextApprover.processRequest(purchaseRequest);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No2Approver</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">No2Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( purchaseRequest.getPrice() &gt; <span class="number">5000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">10000</span>)&#123; <span class="comment">//我负责</span></span><br><span class="line">           System.out.println(<span class="string">"编号:"</span> + purchaseRequest.getId() + <span class="keyword">this</span>.name + <span class="string">" 处理中...."</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123; <span class="comment">//我负责不了，给下一个负责人</span></span><br><span class="line">           nextApprover.processRequest(purchaseRequest);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No3Approver</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">No3Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( purchaseRequest.getPrice() &gt; <span class="number">10000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">30000</span>)&#123; <span class="comment">//我负责</span></span><br><span class="line">           System.out.println(<span class="string">"编号:"</span> + purchaseRequest.getId() + <span class="keyword">this</span>.name + <span class="string">" 处理中...."</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123; <span class="comment">//我负责不了，给下一个负责人</span></span><br><span class="line">           System.out.println(<span class="string">"没那么多钱...."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="请求类"><a href="#请求类" class="headerlink" title="请求类"></a>请求类</h4><p>一个采购的请求实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    请求实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>; <span class="comment">//请求类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>; <span class="comment">//请求金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> price, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-25"><a href="#客户端-25" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个请求类   购买材料需要15000元</span></span><br><span class="line">        PurchaseRequest request = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>,<span class="number">15000</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//创建责任链</span></span><br><span class="line">        Approver no1 = <span class="keyword">new</span> No1Approver(<span class="string">"教学主任"</span>);</span><br><span class="line">        Approver no2 = <span class="keyword">new</span> No2Approver(<span class="string">"院长"</span>);</span><br><span class="line">        Approver no3 = <span class="keyword">new</span> No3Approver(<span class="string">"校长"</span>);</span><br><span class="line">        no1.setApprover(no2);</span><br><span class="line">        no2.setApprover(no3);</span><br><span class="line">        no3.setApprover(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        no1.processRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191222164955744" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222164955744.png" class="lazyload"></p>
<h2 id="SpringMVC源码分析"><a href="#SpringMVC源码分析" class="headerlink" title="SpringMVC源码分析"></a>SpringMVC源码分析</h2><p>拦截器使用了责任链，执行一系列的拦截器</p>
<p><img alt="image-20191222165126855" data-src="http://img.mxranger.cn/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20191222165126855.png" class="lazyload"></p>
<ul>
<li>springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等</li>
<li>在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式</li>
<li>HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程</li>
<li>HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应的拦截器.</li>
</ul>
<h2 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h2><ol>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
<li>性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高级教程</title>
    <url>/2019/12/12/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1、mysql架构介绍"><a href="#1、mysql架构介绍" class="headerlink" title="1、mysql架构介绍"></a>1、mysql架构介绍</h1><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><p><img alt="1562313619304" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562313619304.png" class="lazyload"></p>
<p>windows默认安装下</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>C:\ProgramData\MySQL\MySQL Server 5.7\Data</td>
<td>mysql数据库文件存放路径</td>
</tr>
<tr>
<td>C:\Program Files\MySQL\MySQL Server 5.7\bin</td>
<td>相关命令目录</td>
</tr>
</tbody></table>
<h2 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h2><table>
<thead>
<tr>
<th>系统</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>windows</td>
<td>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</td>
</tr>
<tr>
<td>linux</td>
<td>/etc/my.cnf</td>
</tr>
</tbody></table>
<p>主要配置文件</p>
<table>
<thead>
<tr>
<th>配置文件信息</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>二进制日志log-bin</td>
<td>主从复制</td>
</tr>
<tr>
<td>错误日志log-error</td>
<td>默认关闭，记录严重的警告和错误信息，每次启动和关闭的详细信息等</td>
</tr>
<tr>
<td>查询日志log</td>
<td>默认关闭，记录查询的sql语句，如果开启会降低mysql整体性能，消耗资源</td>
</tr>
<tr>
<td>数据文件</td>
<td>[数据文件](# 3、数据文件)</td>
</tr>
</tbody></table>
<h2 id="3、数据文件"><a href="#3、数据文件" class="headerlink" title="3、数据文件"></a>3、数据文件</h2><h3 id="采用MyISAM"><a href="#采用MyISAM" class="headerlink" title="采用MyISAM"></a>采用MyISAM</h3><p>创建表后会有相应的文件</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>frm</td>
<td>存放表结构</td>
</tr>
<tr>
<td>myd</td>
<td>存放表数据</td>
</tr>
<tr>
<td>myi</td>
<td>存放表索引</td>
</tr>
</tbody></table>
<h3 id="采用InnoDB"><a href="#采用InnoDB" class="headerlink" title="采用InnoDB"></a>采用InnoDB</h3><table>
<thead>
<tr>
<th>文件类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>frm</td>
<td>存放表结构</td>
</tr>
<tr>
<td>ibd</td>
<td>存放表数据和索引信息</td>
</tr>
<tr>
<td>myi</td>
<td>分区存储</td>
</tr>
</tbody></table>
<h2 id="4、逻辑架构"><a href="#4、逻辑架构" class="headerlink" title="4、逻辑架构"></a>4、逻辑架构</h2><p>连接层、 服务层、引擎层、存储层</p>
<p><img alt="1562465089529" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562465089529.png" class="lazyload"></p>
<p><img alt="1562547594658" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562547594658.png" class="lazyload"></p>
<h2 id="5、存储引擎"><a href="#5、存储引擎" class="headerlink" title="5、存储引擎"></a>5、存储引擎</h2><h3 id="1、查看命令"><a href="#1、查看命令" class="headerlink" title="1、查看命令"></a>1、查看命令</h3><p><img alt="1562468067667" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468067667.png" class="lazyload"></p>
<h3 id="2、两种存储引擎的对比"><a href="#2、两种存储引擎的对比" class="headerlink" title="2、两种存储引擎的对比"></a>2、两种存储引擎的对比</h3><p><img alt="1562468301820" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468301820.png" class="lazyload"></p>
<h3 id="3、阿里巴巴、淘宝用哪个"><a href="#3、阿里巴巴、淘宝用哪个" class="headerlink" title="3、阿里巴巴、淘宝用哪个"></a>3、阿里巴巴、淘宝用哪个</h3><p><img alt="1562468462939" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468462939.png" class="lazyload"></p>
<p><img alt="1562468505117" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468505117.png" class="lazyload"></p>
<h1 id="2、索引优化分析"><a href="#2、索引优化分析" class="headerlink" title="2、索引优化分析"></a>2、索引优化分析</h1><h2 id="1、性能下降"><a href="#1、性能下降" class="headerlink" title="1、性能下降"></a>1、性能下降</h2><p>[1] 查询语句写的烂</p>
<p>[2] 索引失效（单值、复合）</p>
<p>单值索引：</p>
<p><img alt="1562482326220" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482326220.png" class="lazyload"></p>
<p>复合索引：</p>
<p><img alt="1562482346108" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482346108.png" class="lazyload"></p>
<p>[3] 关联查询太多join</p>
<p>[4] 服务器调优及各个参数设置（缓冲、线程数）</p>
<h2 id="2、常见通用的join查询"><a href="#2、常见通用的join查询" class="headerlink" title="2、常见通用的join查询"></a>2、常见通用的join查询</h2><h3 id="1、sql执行顺序"><a href="#1、sql执行顺序" class="headerlink" title="1、sql执行顺序"></a>1、sql执行顺序</h3><p>手写顺序</p>
<p><img alt="1562482436989" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482436989.png" class="lazyload"></p>
<p>机读顺序</p>
<p><img alt="1562482264884" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482264884.png" class="lazyload"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img alt="1562482505700" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482505700.png" class="lazyload"></p>
<h3 id="2、7种join"><a href="#2、7种join" class="headerlink" title="2、7种join"></a>2、7种join</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img alt="1560566711450" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566711450.png" class="lazyload"></p>
<p><img alt="1560566734011" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566734011.png" class="lazyload"></p>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create datebase db0629;</span><br><span class="line"></span><br><span class="line">create table tbl_dept(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	deptName VARCHAR(30) DEFAULT null,</span><br><span class="line">	locAdd VARCHAR(40) DEFAULT null,</span><br><span class="line">	PRIMARY KEY(id)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">create table tbl_emp(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(20) DEFAULT null,</span><br><span class="line">	deptId INT(41) DEFAULT null,</span><br><span class="line">	PRIMARY KEY(id),</span><br><span class="line">	KEY fk_dept_id(deptId)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;RD&apos;,11);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;HR&apos;,12);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;MK&apos;,13);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;MIS&apos;,14);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;FD&apos;,15);</span><br><span class="line"></span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;z3&apos;,1);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;z4&apos;,1);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;z5&apos;,1);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;w5&apos;,2);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;w6&apos;,2);</span><br></pre></td></tr></table></figure>



<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p><img alt="1562551995856" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562551995856.png" class="lazyload"></p>
<h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><p><img alt="1562552028273" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552028273.png" class="lazyload"></p>
<h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><p><img alt="1562552050783" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552050783.png" class="lazyload"></p>
<h5 id="左连接——A独有"><a href="#左连接——A独有" class="headerlink" title="左连接——A独有"></a>左连接——A独有</h5><p><img alt="1562552241017" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552241017.png" class="lazyload"></p>
<h5 id="右连接——B独有"><a href="#右连接——B独有" class="headerlink" title="右连接——B独有"></a>右连接——B独有</h5><p><img alt="1562552415831" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552415831.png" class="lazyload"></p>
<p><img alt="1562552394162" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552394162.png" class="lazyload"></p>
<h5 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h5><p>oracle支持、mysql不支持</p>
<p>那如何查询量表独有的数据，且能查询量表共有数据不重复，等同于全连接？</p>
<p>使用union联合查询<strong><em>（两表记录拼接）</em></strong>可以达到全连接的效果</p>
<p><strong>a,b表的共有 + a表独有 + b表独有</strong></p>
<p><img alt="1562553332405" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562553332405.png" class="lazyload"></p>
<p><strong>a，b表的独有</strong></p>
<p><img alt="1562553564573" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562553564573.png" class="lazyload"></p>
<h2 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>索引是帮助MySQL高效获取数据的数据结构</p>
<p><strong>本质：索引是一种数据结构</strong>     <strong>目的：提高查找效率</strong></p>
<p><span style="color:red">简单理解：排好序的快速查找数据结构</span></p>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><p><img alt="1562655186449" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562655186449.png" class="lazyload"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img alt="1562675915837" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562675915837.png" class="lazyload"></p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p>
<p><span style="color:red">我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构阻止的索引。</span>其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引，唯一索引默认都是使用B+数索引，统称索引。当然，除了B+数这种类型的索引之外，还有哈希索引（hash index）等</p>
<h3 id="2、优点"><a href="#2、优点" class="headerlink" title="2、优点"></a>2、优点</h3><p>【1】类似大学图书馆建数目索引，提高数据检索的效率，降低数据库的IO成本</p>
<p>【2】通过索引列队数据进行排序，降低数据排序的成本，降低CPU消耗</p>
<h3 id="3、缺点"><a href="#3、缺点" class="headerlink" title="3、缺点"></a>3、缺点</h3><p>【1】实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，索引索引列也是要占用空间的</p>
<p>【2】虽然索引大大提高查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete，因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后索引信息</p>
<p>【3】索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</p>
<h3 id="5、分类"><a href="#5、分类" class="headerlink" title="5、分类"></a>5、分类</h3><h4 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h4><p>即一个索引只包含单个列，一个表可以有多个单例索引</p>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列的值必须唯一，但允许有空值</p>
<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>即一个索引包含多个列</p>
<p>基本语法</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [unique] index indexName on mytable(columname(length))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter mytable add [unique] index [indexName] on (columnname(length))</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index [indexName] on mytable</span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from table_name</span><br></pre></td></tr></table></figure>

<h4 id="使用alter命令"><a href="#使用alter命令" class="headerlink" title="使用alter命令"></a>使用alter命令</h4><p><img alt="1562725302031" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725302031.png" class="lazyload"></p>
<h3 id="6、索引结构"><a href="#6、索引结构" class="headerlink" title="6、索引结构"></a>6、索引结构</h3><p><img alt="1562725375115" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725375115.png" class="lazyload"></p>
<p>常用的就是b树索引</p>
<p><img alt="1562726908900" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562726908900.png" class="lazyload"></p>
<h4 id="BTree索引（★★★）"><a href="#BTree索引（★★★）" class="headerlink" title="BTree索引（★★★）"></a>BTree索引（★★★）</h4><p><img alt="1562725618351" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725618351.png" class="lazyload"></p>
<p><img alt="1562725764061" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725764061.png" class="lazyload"></p>
<p><img alt="1562726567948" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562726567948.png" class="lazyload"></p>
<h3 id="7、使用情况"><a href="#7、使用情况" class="headerlink" title="7、使用情况"></a>7、使用情况</h3><h4 id="需要创建索引情况"><a href="#需要创建索引情况" class="headerlink" title="需要创建索引情况"></a>需要创建索引情况</h4><p>[1] 主键自动建立唯一索引</p>
<p>[2] 频繁作为查询条件的字段应该创建索引</p>
<p>[3] 查询中与其他表关联的字段，外键关系建立索引</p>
<p>[4] 频繁更新的字段不适合创建索引</p>
<p><strong><em>原因：因为每次更新不单单是更新了记录还会更新索引</em></strong></p>
<p>[5] where条件里用不到的字段不创建索引</p>
<p>[6] 单键/组合索引的选择问题  （高并发下倾向创建组合索引）</p>
<p>[7] 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</p>
<p>[8] 查询中统计或分组字段</p>
<h4 id="不需要创建索引情况"><a href="#不需要创建索引情况" class="headerlink" title="不需要创建索引情况"></a>不需要创建索引情况</h4><p>[1]表记录太少（三百万以上）</p>
<p>[2]经常增删改的表</p>
<p><strong><em>原因：提高查询速度，同时却会降低更新表的速度，如对表进行insert、update、delete。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</em></strong></p>
<p>[3] 数据重复且分布均匀的表字段，因此应该只为经常查询和最经常排序的数据列建立索引。注意：如果每个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p>
<p><img alt="1562727970377" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562727970377.png" class="lazyload"></p>
<h2 id="4、性能分析"><a href="#4、性能分析" class="headerlink" title="4、性能分析"></a>4、性能分析</h2><h3 id="1、MySQL-Query-Optimizer"><a href="#1、MySQL-Query-Optimizer" class="headerlink" title="1、MySQL Query Optimizer"></a>1、MySQL Query Optimizer</h3><p><img alt="1562828303386" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562828303386.png" class="lazyload"></p>
<h3 id="2、MySQL常见瓶颈"><a href="#2、MySQL常见瓶颈" class="headerlink" title="2、MySQL常见瓶颈"></a>2、MySQL常见瓶颈</h3><p>CPU：CPU在饱和的时候一般发生在数据装入内存或磁盘上读取数据时候</p>
<p>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</p>
<p>服务器应届的性能瓶颈：top、free、iostat和vmstat来查看系统的性能状态</p>
<h3 id="3、EXPLAIN关键字"><a href="#3、EXPLAIN关键字" class="headerlink" title="3、EXPLAIN关键字"></a>3、EXPLAIN关键字</h3><h4 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>使用explain 关键字可以模拟优化器质性SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>两种方式查看信息</p>
<p>explain + sql语句      （横版）       或者        explain + sql语句 + \G   （竖版）</p>
<p><img alt="1563067896613" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563067896613.png" class="lazyload"></p>
<h4 id="2、用途"><a href="#2、用途" class="headerlink" title="2、用途"></a>2、用途</h4><p>[1] 表的读取顺序 (id)</p>
<p>[2] 数据读取操作的操作类型 (select_type)</p>
<p>[3] 哪些索引可以使用（possible_keys）</p>
<p>[4] 哪些索引被实际使用 (key)</p>
<p>[5] 表之间的引用 (ref)</p>
<p>[6] 每张表有多少行被优化器查询 (rows)</p>
<h4 id="3、各字段解释"><a href="#3、各字段解释" class="headerlink" title="3、各字段解释"></a>3、各字段解释</h4><p><img alt="1562832868456" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562832868456.png" class="lazyload"></p>
<h5 id="1、id-star-star-star"><a href="#1、id-star-star-star" class="headerlink" title="1、id(:star::star::star:)"></a>1、id(:star::star::star:)</h5><h6 id="1、id相同"><a href="#1、id相同" class="headerlink" title="1、id相同"></a>1、id相同</h6><p><strong><em>结论：id相同，执行顺序由上至下</em></strong></p>
<p><img alt="1562833260375" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562833260375.png" class="lazyload"></p>
<h6 id="2、id不同"><a href="#2、id不同" class="headerlink" title="2、id不同"></a>2、id不同</h6><p>id值越大，优先级越高，越先被执行</p>
<p><strong><em>结论：最里面先执行，执行完再执行外面</em></strong></p>
<p><img alt="1562834820380" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562834820380.png" class="lazyload"></p>
<h6 id="3、id相同-不同"><a href="#3、id相同-不同" class="headerlink" title="3、id相同+不同"></a>3、id相同+不同</h6><p><strong><em>结论：id不同，先执行id值高的；id相同，再按顺序执行</em></strong></p>
<p><img alt="1562835041054" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562835041054.png" class="lazyload"></p>
<h5 id="2、select-type"><a href="#2、select-type" class="headerlink" title="2、select_type"></a>2、select_type</h5><p>主要区别于普通查询、联合查询、子查询等的复杂查询</p>
<p><img alt="1562895858960" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562895858960.png" class="lazyload"></p>
<p><img alt="1562895997142" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562895997142.png" class="lazyload"></p>
<h5 id="3、table"><a href="#3、table" class="headerlink" title="3、table"></a>3、table</h5><p>显示着一行的数据是关于哪张表</p>
<h5 id="4、type-star-star-star"><a href="#4、type-star-star-star" class="headerlink" title="4、type(:star::star::star:)"></a>4、type(:star::star::star:)</h5><p><img alt="1562896400411" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562896400411.png" class="lazyload"></p>
<p><span style="color:red"><strong>从最好到最差依次为：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong></span></p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref</p>
<p><img alt="1562897176702" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562897176702.png" class="lazyload"></p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><p><strong><em>【 system、const 】</em></strong></p>
<p>单行单表查询速度最快</p>
<p><img alt="1562897990578" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562897990578.png" class="lazyload"></p>
<p><strong><em>【 eq_ref 】</em></strong></p>
<p><img alt="1562899162056" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562899162056.png" class="lazyload"></p>
<p><strong><em>【ref】</em></strong></p>
<p>非唯一索引扫描</p>
<p><img alt="1562899509488" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562899509488.png" class="lazyload"></p>
<p><strong><em>【range】</em></strong></p>
<p>范围查询比全表查询好一些</p>
<p><img alt="1562900172447" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562900172447.png" class="lazyload"></p>
<p><strong><em>【index】</em></strong></p>
<p>id主键索引，前提是id建了索引</p>
<p><img alt="1562900373895" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562900373895.png" class="lazyload"></p>
<p><strong><em>【ALL】</em></strong></p>
<p><img alt="1562900487021" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562900487021.png" class="lazyload"></p>
<h5 id="5、possible-keys、key-star-star-star"><a href="#5、possible-keys、key-star-star-star" class="headerlink" title="5、possible_keys、key(:star::star::star:)"></a>5、possible_keys、key(:star::star::star:)</h5><p><img alt="1562981774596" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562981774596.png" class="lazyload"></p>
<p><img alt="1562982024121" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982024121.png" class="lazyload"></p>
<p><span style="color:red"><strong>总结：possible_keys 理论上用了几个索引，key实际上用了几个索引</strong></span></p>
<h6 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h6><p><img alt="1562982431561" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982431561.png" class="lazyload"></p>
<p>理论上用primary和idx_t1两个索引，实际只用到idx_t1一个索引</p>
<h6 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h6><p><img alt="1562982549442" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982549442.png" class="lazyload"></p>
<p>如果查询的字段刚好和你创建的索引一致的话，理论上没有索引，单实际上用了创建的索引，如上图<code>idx_col1_col2</code>索引，比<code>select *.....</code>来得快，因为type是index，而不是all</p>
<h5 id="6、key-len"><a href="#6、key-len" class="headerlink" title="6、key_len"></a>6、key_len</h5><p><img alt="1562982931136" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982931136.png" class="lazyload"></p>
<p><img alt="1562983569857" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562983569857.png" class="lazyload"></p>
<hr>
<p>【结论】：相同条件下查询，key_len越小越好，精度越小越好。精度高消耗大</p>
<h5 id="7、ref"><a href="#7、ref" class="headerlink" title="7、ref"></a>7、ref</h5><p><img alt="1562983818094" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562983818094.png" class="lazyload"></p>
<h6 id="举例1-1"><a href="#举例1-1" class="headerlink" title="举例1"></a>举例1</h6><p><img alt="1562984512712" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562984512712.png" class="lazyload"></p>
<p>t1先根据条件常量进行查询后，t1作为驱动表进行关联查询，ref中会显示test库中t1表里的id字段被使用</p>
<h6 id="举例2-1"><a href="#举例2-1" class="headerlink" title="举例2"></a>举例2</h6><p><img alt="1562984567264" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562984567264.png" class="lazyload"></p>
<p>t2作为驱动表进行全表扫描，然后根据连接条件，ref中显示t2表中使用的col1字段，以及<code>t1.col2=‘ac’</code>常量条件</p>
<hr>
<p>【总结】：如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p>
<h5 id="8、rows-star-star-star"><a href="#8、rows-star-star-star" class="headerlink" title="8、rows(:star::star::star:)"></a>8、rows(:star::star::star:)</h5><p><img alt="1562985248900" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562985248900.png" class="lazyload"></p>
<p><img alt="1562985581967" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562985581967.png" class="lazyload"></p>
<h5 id="9、extra-star-star-star"><a href="#9、extra-star-star-star" class="headerlink" title="9、extra(:star::star::star:)"></a>9、extra(:star::star::star:)</h5><p>包含不合适在其他列中显示但十分重要的额外信息</p>
<p><img alt="2019-07-14_092733" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/2019-07-14_092733.png" class="lazyload"></p>
<h6 id="1、Using-filesort-star-star-star"><a href="#1、Using-filesort-star-star-star" class="headerlink" title="1、Using filesort(:star::star::star:)"></a>1、Using filesort(:star::star::star:)</h6><p><span style="color:red"><strong><em>评价：性能很差</em></strong></span></p>
<p><img alt="1563067624976" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563067624976.png" class="lazyload"></p>
<p><img alt="TIM截图20190714094047" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714094047.jpg" class="lazyload"></p>
<hr>
<p>【结论】：后者效率高，性能更加，前者另起炉灶，虽有索引，但没用到，用的文件排序</p>
<h6 id="2、Using-temporary-star-star-star"><a href="#2、Using-temporary-star-star-star" class="headerlink" title="2、Using temporary(:star::star::star:)"></a>2、Using temporary(:star::star::star:)</h6><p><span style="color:red"><strong><em>评价：比Using filesort更差</em></strong></span></p>
<p><img alt="TIM截图20190714095559" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714095559.jpg" class="lazyload"></p>
<p><img alt="TIM截图20190714144421" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714144421.jpg" class="lazyload"></p>
<h6 id="3、Using-index-star-star-star"><a href="#3、Using-index-star-star-star" class="headerlink" title="3、Using index(:star::star::star:)"></a>3、Using index(:star::star::star:)</h6><p><span style="color:red"><strong><em>评价：效率不错</em></strong></span></p>
<p><img alt="TIM截图20190714144950" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714144950.jpg" class="lazyload"></p>
<p><img alt="1563087112897" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563087112897.png" class="lazyload"></p>
<p><img alt="TIM截图20190714145552" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714145552.jpg" class="lazyload"></p>
<p><img alt="1563087694241" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563087694241.png" class="lazyload"></p>
<h6 id="4、using-where"><a href="#4、using-where" class="headerlink" title="4、using where"></a>4、using where</h6><p>表明使用了where过滤</p>
<h6 id="5、using-join-buffer"><a href="#5、using-join-buffer" class="headerlink" title="5、using join buffer"></a>5、using join buffer</h6><p>使用连接缓存</p>
<h6 id="6、impossible-where"><a href="#6、impossible-where" class="headerlink" title="6、impossible where"></a>6、impossible where</h6><p>where子句的值总是false，不能用来获取任何元组</p>
<p><img alt="1563088478530" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563088478530.png" class="lazyload"></p>
<h6 id="7、select-tables-optimized-away"><a href="#7、select-tables-optimized-away" class="headerlink" title="7、select tables optimized away"></a>7、select tables optimized away</h6><p><img alt="1563088501273" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563088501273.png" class="lazyload"></p>
<h6 id="8、distinct"><a href="#8、distinct" class="headerlink" title="8、distinct"></a>8、distinct</h6><p><img alt="1563088527305" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563088527305.png" class="lazyload"></p>
<h3 id="4、热身案例"><a href="#4、热身案例" class="headerlink" title="4、热身案例"></a>4、热身案例</h3><p><img alt="1563089145085" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563089145085.png" class="lazyload"></p>
<p><img alt="1563089331442" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563089331442.png" class="lazyload"></p>
<h2 id="5、索引优化"><a href="#5、索引优化" class="headerlink" title="5、索引优化"></a>5、索引优化</h2><h3 id="1、索引分析"><a href="#1、索引分析" class="headerlink" title="1、索引分析"></a>1、索引分析</h3><h4 id="1、单表"><a href="#1、单表" class="headerlink" title="1、单表"></a>1、单表</h4><h5 id="建立SQL"><a href="#建立SQL" class="headerlink" title="建立SQL"></a>建立SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">author_id INT(10) UNSIGNED NOT NULL,</span><br><span class="line">category_id INT(10) UNSIGNED NOT NULL,</span><br><span class="line">views INT(10) UNSIGNED NOT NULL,</span><br><span class="line">comments INT(10) UNSIGNED NOT NULL, </span><br><span class="line">title VARBINARY(255) NOT NULL, </span><br><span class="line">content TEXT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO article(author_id, category_id, views, comments, title, content) VALUES </span><br><span class="line">(1, 1,1,1, &apos;1&apos;,&apos;1&apos;),</span><br><span class="line">(2, 2, 2, 2,&apos;2&apos;,&apos;2&apos;),</span><br><span class="line">(1, 1,3, 3,&apos;3&apos;,&apos;3&apos;);</span><br></pre></td></tr></table></figure>



<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><blockquote>
<p>查询category_id为1且comments大于1的情况下，views最多的article_id</p>
</blockquote>
<p><strong>步骤：</strong></p>
<p><strong>[1]首先 编写sql语句</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">SELECT id,author_id</span><br><span class="line">FROM article</span><br><span class="line">WHERE category_id = 1 AND comments &gt; 1</span><br><span class="line">ORDER BY views</span><br><span class="line">DESC LIMIT 1;</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<p><img alt="1563091204680" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091204680.png" class="lazyload"></p>
<hr>
<p>结论，很显然，type是ALL，即最坏的情况，Extra里还出现了using filesort，也是最坏的情况，必须优化</p>
<p><strong>[2] 建立索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_article_ccv on article(category_id,comments,views);</span><br><span class="line">#查看</span><br><span class="line">show index from article;</span><br></pre></td></tr></table></figure>

<p><img alt="1563091372030" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091372030.png" class="lazyload"></p>
<p><strong>[3] explain分析</strong></p>
<p><img alt="1563091420110" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091420110.png" class="lazyload"></p>
<hr>
<p>结果发现，type变成了range，可以忍受，但是Extra里还出现了using filesort是无法接受的</p>
<p><strong>继续优化！！！</strong></p>
<p><strong>【4】置换条件分析</strong></p>
<p>与 <code>comment = 1</code>条件进行比对</p>
<p><img alt="1563091537358" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091537358.png" class="lazyload"></p>
<p>发现性能变好了，type变成ref，extra也没有using filesort</p>
<hr>
<p>得出结论：范围条件可能会导致索引失效，用不上后面的索引，就好比建了个三层楼，告诉你101、202、3楼挨个搜，用不上后面的索引了</p>
<p><img alt="1563091821021" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091821021.png" class="lazyload"></p>
<p><strong>【5】重新建立索引</strong></p>
<p>鉴于上面的范围问题，采取绕过范围字段，将category_id和views建立索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除索引</span><br><span class="line">DROP INDEX idx_article_ccv on article;</span><br><span class="line">#重建索引</span><br><span class="line">CREATE INDEX idx_article_ccv on article(category_id,views);</span><br></pre></td></tr></table></figure>



<p><strong>【6】explain继续查看结果</strong></p>
<p><img alt="1563103971539" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563103971539.png" class="lazyload"></p>
<hr>
<p>可以看到，type变成ref，ectra中的using filesort也消失了，结果非常理想</p>
<h4 id="2、两表"><a href="#2、两表" class="headerlink" title="2、两表"></a>2、两表</h4><h5 id="建立SQL-1"><a href="#建立SQL-1" class="headerlink" title="建立SQL"></a>建立SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS class(</span><br><span class="line">	id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS book(</span><br><span class="line">	bookid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY(bookid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br></pre></td></tr></table></figure>







<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><blockquote>
<p>左连接两表查询所有记录</p>
</blockquote>
<p><strong>步骤：</strong></p>
<p>【1】首先explain分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#分析</span><br><span class="line">explain </span><br><span class="line">#左：class  右：book</span><br><span class="line">select * from class left join book on class.card = book.card;</span><br></pre></td></tr></table></figure>

<p><img alt="1563173355156" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173355156.png" class="lazyload"></p>
<hr>
<p>结果很糟糕</p>
<p>【2】右表加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1] 试试右表索引  </span><br><span class="line">ALTER TABLE book add INDEX Y(card);</span><br></pre></td></tr></table></figure>

<p>继续explain分析，结果如下</p>
<p><img alt="1563173439652" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173439652.png" class="lazyload"></p>
<hr>
<p>结果发现一个all一个ref，总共rows 21行，不错</p>
<p>【3】试试左表加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除</span><br><span class="line">drop index Y on book;</span><br><span class="line">#[2] 试试左表索引  </span><br><span class="line">ALTER TABLE class add INDEX Y(card);</span><br></pre></td></tr></table></figure>

<p>继续explain分析，结果如下</p>
<p><img alt="1563173520464" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173520464.png" class="lazyload"></p>
<hr>
<p>结果发现，一个是index一个all，index的性能没有ref好，而且rows总共40行，还有extra出现连接缓存</p>
<p>【结论】：这是由左连接的特性决定的。</p>
<p><img alt="1563173986234" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173986234.png" class="lazyload"></p>
<p><code>LEFT JOIN</code>条件用于确定如何从右表搜索行，左边一定都有，所以右边是我们的关键点，一定要建立索引。左边是需要全部扫描的，而右边部分扫描，用索引更好。</p>
<p><strong>:star::star::star:右连接同理，索引加载左表上！！！:star::star::star:</strong></p>
<h4 id="3、三表"><a href="#3、三表" class="headerlink" title="3、三表"></a>3、三表</h4><h5 id="建立SQL-2"><a href="#建立SQL-2" class="headerlink" title="建立SQL"></a>建立SQL</h5><p>在两表的基础上加一个phone表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS phone(</span><br><span class="line">	phoneid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY(phoneid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br></pre></td></tr></table></figure>





<h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><blockquote>
<p>三表查询</p>
</blockquote>
<p><strong>步骤：</strong></p>
<p>【1】explain分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#三表查询</span><br><span class="line">explain</span><br><span class="line">select * </span><br><span class="line">from class</span><br><span class="line">LEFT JOIN book</span><br><span class="line">on class.card = book.card</span><br><span class="line">LEFT JOIN phone</span><br><span class="line">on book.card = phone.card</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1563175244554" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175244554.png" class="lazyload"></p>
<hr>
<p>继续优化</p>
<p>【2】添加索引</p>
<p>在book和phone上添加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y(card);</span><br><span class="line">ALTER TABLE phone ADD INDEX Y(card);</span><br></pre></td></tr></table></figure>

<p>继续explain分析</p>
<p><img alt="1563175355033" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175355033.png" class="lazyload"></p>
<hr>
<p>效果很好</p>
<p><img alt="1563175407152" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175407152.png" class="lazyload"></p>
<p>【结论】</p>
<p><img alt="1563175553954" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175553954.png" class="lazyload"></p>
<h3 id="2、索引失效（应该避免）"><a href="#2、索引失效（应该避免）" class="headerlink" title="2、索引失效（应该避免）"></a>2、索引失效（应该避免）</h3><h4 id="索引失效10种原因"><a href="#索引失效10种原因" class="headerlink" title="索引失效10种原因"></a>索引失效10种原因</h4><p><img alt="1563239560954" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563239560954.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-1"><a href="#案例分析——索引优化No-1" class="headerlink" title="案例分析——索引优化No.1"></a>案例分析——索引优化No.1</h4><h5 id="建立sql"><a href="#建立sql" class="headerlink" title="建立sql"></a>建立sql</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table staffs(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(24) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;姓名&apos;,</span><br><span class="line">	age INT NOT NULL DEFAULT 0 COMMENT &apos;年龄&apos;,</span><br><span class="line">	pos VARCHAR(20) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;职位&apos;, </span><br><span class="line">  add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;入职时间&apos;</span><br><span class="line">)CHARSET UTF8 COMMENT &apos;员工记录表&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&apos;Z3&apos;,22,&apos;MANAGER&apos;,NOW());</span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&apos;july&apos;,23,&apos;dev&apos;,NOW());</span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&apos;2000&apos;,23,&apos;dev&apos;,NOW());</span><br><span class="line"></span><br><span class="line">SELECT * from staffs;</span><br><span class="line"></span><br><span class="line">ALTER TABLE staffs add INDEX idx_nameAgePos(name,age,pos);</span><br></pre></td></tr></table></figure>



<h5 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h5><p>【1】顺序列</p>
<p><code>name</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where NAME = &apos;july&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240271179" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240271179.png" class="lazyload"></p>
<p>可以用到索引</p>
<p><code>name-&gt;age</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where NAME = &apos;july&apos; AND age = 23;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240319660" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240319660.png" class="lazyload"></p>
<p>也用到了索引</p>
<p><code>x-&gt;age-&gt;pos</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where age = 23 AND pos = &apos;dev&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240366826" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240366826.png" class="lazyload"></p>
<p>没有用到索引</p>
<p><code>x-&gt;x-&gt;pos</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where pos = &apos;dev&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240405842" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240405842.png" class="lazyload"></p>
<p>也没有用到索引</p>
<p>【2】跳过中间列</p>
<p><code>name-&gt;age</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">SELECT *</span><br><span class="line">from staffs</span><br><span class="line">where NAME = &apos;july&apos; AND age = 23;</span><br></pre></td></tr></table></figure>

<p><img alt="1563241015553" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563241015553.png" class="lazyload"></p>
<p><code>name-&gt;x-&gt;pos</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">SELECT *</span><br><span class="line">from staffs</span><br><span class="line">where NAME = &apos;july&apos; AND pos = &apos;dev&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563241040433" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563241040433.png" class="lazyload"></p>
<p>发现跳过列依然用了索引，但不是全值匹配，而是部分匹配，<span style="color:red"><strong>违背了最佳左前缀法则</strong></span></p>
<hr>
<p>【结论】：</p>
<p><img alt="1563240461985" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240461985.png" class="lazyload"></p>
<p>必须要从头开始，也就是name开始。建索引的第一个字段不能丢失</p>
<h4 id="案例分析——索引优化No-2"><a href="#案例分析——索引优化No-2" class="headerlink" title="案例分析——索引优化No.2"></a>案例分析——索引优化No.2</h4><p><img alt="1563263040242" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263040242.png" class="lazyload"></p>
<p>如下sql语句分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from staffs</span><br><span class="line">where left(name,4) = &apos;july&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563263085387" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263085387.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from staffs</span><br><span class="line">where name = &apos;july&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563263104778" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263104778.png" class="lazyload"></p>
<hr>
<p>【结论】：使用函数会索引失效，因此不在索引上做任何操作，任何不精确的操作都会出现这个问题</p>
<h4 id="案例分析——索引优化No-3"><a href="#案例分析——索引优化No-3" class="headerlink" title="案例分析——索引优化No.3"></a>案例分析——索引优化No.3</h4><p>在有索引（name-&gt;age-&gt;pos）的前提下，查询条件出现范围后，则其右边的列就会发生索引失效</p>
<p><img alt="1563263710916" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263710916.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-4"><a href="#案例分析——索引优化No-4" class="headerlink" title="案例分析——索引优化No.4"></a>案例分析——索引优化No.4</h4><p><img alt="1563264353622" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264353622.png" class="lazyload"></p>
<p><img alt="1563264607421" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264607421.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-5"><a href="#案例分析——索引优化No-5" class="headerlink" title="案例分析——索引优化No.5"></a>案例分析——索引优化No.5</h4><p><img alt="1563264847779" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264847779.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-6"><a href="#案例分析——索引优化No-6" class="headerlink" title="案例分析——索引优化No.6"></a>案例分析——索引优化No.6</h4><p><img alt="1563264973202" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264973202.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-7"><a href="#案例分析——索引优化No-7" class="headerlink" title="案例分析——索引优化No.7"></a>案例分析——索引优化No.7</h4><p><img alt="1563265240788" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563265240788.png" class="lazyload"></p>
<hr>
<h5 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h5><blockquote>
<p><strong>解决like ‘%字符串%’时索引不被使用的方法？</strong></p>
<p><span style="color:red"><strong>解答：使用覆盖索引 ，查询的字段包含在建立的索引中，且查询的条件字段在索引的起始位置，比如对name进行like，则索引需建立name,email,…(最佳作前缀法则)</strong></span></p>
</blockquote>
<p>【步骤】</p>
<p>【1】建立sql准备数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tbl_user(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(20) DEFAULT NULL,</span><br><span class="line">	age INT(11) DEFAULT NULL,</span><br><span class="line">	email VARCHAR(20) DEFAULT NULL,</span><br><span class="line">	PRIMARY KEY(id)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=UTF8;</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;1aa1&apos;,21,&apos;b@163.com&apos;);</span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;2aa2&apos;,222,&apos;a@163.com&apos;);</span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;3aa3&apos;,265,&apos;c@163.com&apos;);</span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;4aa4&apos;,21,&apos;d@163.com&apos;);</span><br></pre></td></tr></table></figure>



<p>【2】建立索引前explain分析</p>
<p><img alt="1563267108055" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563267108055.png" class="lazyload"></p>
<p><img alt="1563267139590" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563267139590.png" class="lazyload"></p>
<p>以上结果的type都是all，其他sql自行验证</p>
<p>【3】建立索引后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_user_nameAge on tbl_user(name,age);</span><br><span class="line"></span><br><span class="line"># [1] select name,age</span><br><span class="line">explain </span><br><span class="line">select name,age from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563267989874" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563267989874.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># [2] select id</span><br><span class="line">explain </span><br><span class="line">select id from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563268014989" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563268014989.png" class="lazyload"></p>
<p><strong><em>由于id本身为主键，主键自带了主键索引，算是查询的索引字段的默认第一个</em></strong></p>
<p>以此类推,age、id,name、id,name,age、name,age一样type都是index</p>
<p><img alt="1563268439669" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563268439669.png" class="lazyload"></p>
<p>但是select *依然失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">select * from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563268477978" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563268477978.png" class="lazyload"></p>
<p>多了email的字段也会失效，超出了索引字段的范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">select id,name,age,email from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>



<h4 id="案例分析——索引优化No-8"><a href="#案例分析——索引优化No-8" class="headerlink" title="案例分析——索引优化No.8"></a>案例分析——索引优化No.8</h4><p><img alt="1563327288205" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327288205.png" class="lazyload"></p>
<p>不加单引号，会引起数据类型的转换而导致全表扫描（索引失效10大原因中的第3个）</p>
<p><img alt="1563327358493" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327358493.png" class="lazyload"></p>
<p><img alt="字符串单引号" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%95%E5%BC%95%E5%8F%B7.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-9"><a href="#案例分析——索引优化No-9" class="headerlink" title="案例分析——索引优化No.9"></a>案例分析——索引优化No.9</h4><p><img alt="1563327458510" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327458510.png" class="lazyload"></p>
<p><img alt="1563327583485" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327583485.png" class="lazyload"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img alt="1563327838950" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327838950.png" class="lazyload"></p>
<h3 id="3、面试题讲解"><a href="#3、面试题讲解" class="headerlink" title="3、面试题讲解"></a>3、面试题讲解</h3><h4 id="题目sql"><a href="#题目sql" class="headerlink" title="题目sql"></a>题目sql</h4><h5 id="1、建表SQL"><a href="#1、建表SQL" class="headerlink" title="1、建表SQL"></a>1、建表SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test03(</span><br><span class="line">	id INT PRIMARY KEY not null auto_increment,</span><br><span class="line">	c1 char(10),</span><br><span class="line">	c2 char(10),</span><br><span class="line">	c3 char(10),</span><br><span class="line">	c4 char(10),</span><br><span class="line">	c5 char(10)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;a1&apos;,&apos;a2&apos;,&apos;a3&apos;,&apos;a4&apos;,&apos;a5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;b1&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;b4&apos;,&apos;b5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;,&apos;c4&apos;,&apos;c5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;d1&apos;,&apos;d2&apos;,&apos;d3&apos;,&apos;d4&apos;,&apos;d5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;e1&apos;,&apos;e2&apos;,&apos;e3&apos;,&apos;e4&apos;,&apos;e5&apos;);</span><br></pre></td></tr></table></figure>



<h5 id="2、建索引"><a href="#2、建索引" class="headerlink" title="2、建索引"></a>2、建索引</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_c1234 on test03(c1,c2,c3,c4);</span><br><span class="line">show index from test03;</span><br></pre></td></tr></table></figure>



<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>创建了复合索引idx_c1234，根据以下SQL分析索引使用情况</p>
</blockquote>
<h5 id="情况1-——-顺序"><a href="#情况1-——-顺序" class="headerlink" title="情况1 —— 顺序"></a>情况1 —— 顺序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos;;</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos;;</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3=&apos;a3&apos;;</span><br><span class="line"></span><br><span class="line"># 全值匹配</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3=&apos;a3&apos; and c4=&apos;a4&apos;;</span><br></pre></td></tr></table></figure>

<p>都能用到索引</p>
<h5 id="情况2-——乱序"><a href="#情况2-——乱序" class="headerlink" title="情况2 ——乱序"></a>情况2 ——乱序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3=&apos;a3&apos; and c4=&apos;a4&apos;;</span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c4=&apos;a4&apos; and c3=&apos;a3&apos;;</span><br><span class="line">#[3]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c3=&apos;a3&apos; and c2=&apos;a2&apos; and c4=&apos;a4&apos;;</span><br><span class="line">#[4]</span><br><span class="line">explain select * from test03 where c2=&apos;a2&apos; and c1=&apos;a1&apos; and c3=&apos;a3&apos; and c4=&apos;a4&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563330445298" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563330445298.png" class="lazyload"></p>
<p>后面两个字段颠倒  两种情况都能使用索引</p>
<p><strong>【结论】：只要带头大哥不死，后面兄弟还在，即便乱序了，mysql会自己调整顺序都会使用索引，但是尽量按照索引的顺序来，效率比较高。如果兄弟断了，那么就只用到截断前的几个字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c4=&apos;a4&apos; and c3=&apos;a3&apos; and c2=&apos;a2&apos; and c1=&apos;a1&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563330619617" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563330619617.png" class="lazyload"></p>
<p>顺序反过来依然能用到建立的索引，<strong>原因在于mysql本有带有优化器，会对sql语句进行分析优化</strong>，比如1+2+3和3+2+1是一样的</p>
<h5 id="情况3-——-范围"><a href="#情况3-——-范围" class="headerlink" title="情况3 —— 范围"></a>情况3 —— 范围</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3&gt;&apos;a3&apos; and c4=&apos;a4&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563331432697" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563331432697.png" class="lazyload"></p>
<p>c1和c2用上了索引，从c3开始就是range了，c4就没法使用索引了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c4&gt;&apos;a4&apos; and c3=&apos;a3&apos;;</span><br></pre></td></tr></table></figure>

<p>换了个顺序，c1、c2、c3、c4都是用了索引，<strong>mysql会自己调整顺序</strong>，c4被调整到了最后</p>
<h5 id="情况4-——-orderby顺序"><a href="#情况4-——-orderby顺序" class="headerlink" title="情况4 —— orderby顺序"></a>情况4 —— orderby顺序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c4&gt;&apos;a4&apos; </span><br><span class="line">order by c3;</span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; </span><br><span class="line">order by c3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563332191847" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563332191847.png" class="lazyload"></p>
<p><img alt="1563332352149" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563332352149.png" class="lazyload"></p>
<p><strong><em>【建立索引就是为了 查询 和 排序 】</em></strong></p>
<p>[1]   c1、c2使用到了索引，用于查询，c3其实也用到了索引，只不过用在了排序上。</p>
<p>[2] 结果一样，和c4无关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; </span><br><span class="line">order by c4;</span><br></pre></td></tr></table></figure>

<p><img alt="1563332505495" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563332505495.png" class="lazyload"></p>
<p>c1、c2使用了索引，用于查询，但是中间兄弟断了，mysql无法根据我建立的索引进行排序，只能<strong>另起炉灶对c4使用文件排序(using filesort)</strong>，性能下降</p>
<h5 id="情况5-——-orderby乱序"><a href="#情况5-——-orderby乱序" class="headerlink" title="情况5 —— orderby乱序"></a>情况5 —— orderby乱序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c2,c3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563333288174" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563333288174.png" class="lazyload"></p>
<p>c1使用到了索引进行查询，c2和c3也用到部分索引进行排序，<strong>没有using filesort</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c3,c2;</span><br></pre></td></tr></table></figure>

<p><img alt="1563333462648" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563333462648.png" class="lazyload"></p>
<p>和之前对比，发现order by顺序反了，<strong>会有using filesort</strong></p>
<h5 id="情况6-——-orderby-常量乱序"><a href="#情况6-——-orderby-常量乱序" class="headerlink" title="情况6 —— orderby 常量乱序"></a>情况6 —— orderby 常量乱序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; </span><br><span class="line">order by c2,c3;</span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c2,c3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563333682639" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563333682639.png" class="lazyload"></p>
<p>结果一样 ，c1、c2两个字段的索引，但c2、c3用于排序，<strong>没有using filesort</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c3,c2;</span><br><span class="line"></span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c3,c2;</span><br></pre></td></tr></table></figure>

<p><img alt="1563334094031" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563334094031.png" class="lazyload"></p>
<p><strong>原因：</strong></p>
<p><strong><em>一般情况下order by后面不按顺序会出现using filesort</em></strong></p>
<p>但是 [1]中c2 在where里已经是一个常量了，放在order by 后面也是一个常量，相当于<code>order by &#39;a2&#39; , c3</code> ，只用对c3进行排序即可，不会出现using filesort    ，而[2] 会出现using filesort</p>
<h5 id="情况7-——-groupby"><a href="#情况7-——-groupby" class="headerlink" title="情况7 —— groupby"></a>情况7 —— groupby</h5><p><img alt="1563334777364" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563334777364.png" class="lazyload"></p>
<p>group by 乱序后 性能差极了！！！！！</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>where条件定值为常量（查询）、范围是排序后面失效，一般order by是给个范围</p>
<p>group by基本上都需要进行排序（<strong>分组之前必排序</strong>），会导致临时表产生</p>
<p>group by和order by几乎一致</p>
<p><img alt="1563352023243" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563352023243.png" class="lazyload"></p>
<p><img alt="1563352608797" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563352608797.png" class="lazyload"></p>
<p><img alt="总结" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E6%80%BB%E7%BB%93.png" class="lazyload"></p>
<h4 id="索引优化口诀"><a href="#索引优化口诀" class="headerlink" title="索引优化口诀"></a>索引优化口诀</h4><p>全值匹配我最爱，最左前缀要遵守；</p>
<p>带头大哥不能死，中间兄弟不能断；</p>
<p>索引列上少计算，范围之后全失效；</p>
<p>Like百分写最右，覆盖索引不写星；</p>
<p>不等空值还有or，索引失效要少用；</p>
<p>VAR引号不可丢，SQL高级也不难！</p>
<h1 id="3、查询截取分析"><a href="#3、查询截取分析" class="headerlink" title="3、查询截取分析"></a>3、查询截取分析</h1><blockquote>
<p>整体查询截取的分析流程如下：</p>
<p>分析</p>
<p>1、观察，至少跑1天，看看生产的慢SQL情况</p>
<p>2、开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来</p>
<p>3、explain + 慢SQL分析</p>
<p>4、show profile</p>
<p>5、运维经理 or DBA，进行SQL数据库服务器的参数调优</p>
<p>总结：</p>
<p>0、查询优化</p>
<p>1、慢查询的开启捕获</p>
<p>2、explain + 慢SQL分析</p>
<p>3、show profile 查询SQL在Mysql服务器里面的执行细节和生命周期情况</p>
<p>4、SQL数据库服务器的参数调优</p>
</blockquote>
<h2 id="1、查询优化"><a href="#1、查询优化" class="headerlink" title="1、查询优化"></a>1、查询优化</h2><p><img alt="1563435126980" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563435126980.png" class="lazyload"></p>
<h3 id="1、小表驱动大表"><a href="#1、小表驱动大表" class="headerlink" title="1、小表驱动大表"></a>1、小表驱动大表</h3><p>数据库最耗神的操作就是连接查询释放，若一百万次查询每查一次释放一次，数据库会受不了</p>
<p><img alt="1563435403331" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563435403331.png" class="lazyload"></p>
<p><img alt="1563436328039" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563436328039.png" class="lazyload"></p>
<p><img alt="1563436424779" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563436424779.png" class="lazyload"></p>
<h4 id="in和exists"><a href="#in和exists" class="headerlink" title="in和exists"></a>in和exists</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">select * from tbl_emp e </span><br><span class="line">where e.deptId </span><br><span class="line">in (select id from tbl_dept d);</span><br><span class="line"></span><br><span class="line">#[2]</span><br><span class="line">select * from tbl_emp e </span><br><span class="line">where EXISTS (select 1 from tbl_dept d where e.deptId = d.id);</span><br></pre></td></tr></table></figure>





<h3 id="2、order-by关键字优化"><a href="#2、order-by关键字优化" class="headerlink" title="2、order by关键字优化"></a>2、order by关键字优化</h3><p><img alt="1563588187123" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563588187123.png" class="lazyload"></p>
<h4 id="使用index方式排序"><a href="#使用index方式排序" class="headerlink" title="使用index方式排序"></a>使用index方式排序</h4><h5 id="建表SQL"><a href="#建表SQL" class="headerlink" title="建表SQL"></a>建表SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tblA(</span><br><span class="line">	id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,</span><br><span class="line">	age INT,</span><br><span class="line">	birth TIMESTAMP NOT NULL </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into tblA(age,birth) VALUES(22,NOW());</span><br><span class="line">insert into tblA(age,birth) VALUES(23,NOW());</span><br><span class="line">insert into tblA(age,birth) VALUES(24,NOW());</span><br><span class="line"></span><br><span class="line">create index idx_A_ageBirth on tblA(age,birth);</span><br><span class="line"></span><br><span class="line">select * from tblA;</span><br></pre></td></tr></table></figure>

<h5 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h5><p><img alt="1563588804573" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563588804573.png" class="lazyload"></p>
<p><img alt="1563589038772" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563589038772.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from tbla</span><br><span class="line">ORDER BY age asc,birth asc</span><br><span class="line"></span><br><span class="line">#[2]</span><br><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from tbla</span><br><span class="line">ORDER BY age desc,birth desc</span><br></pre></td></tr></table></figure>
<p>两个排序同方向的可以用到索引<br><img alt="1563589150556" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563589150556.png" class="lazyload"></p>
<hr>
<p>【结论】</p>
<p>1、MySQL支持两种方式的排序，FileSort和Index，Index效率高，它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</p>
<p>2、order by满足两种情况，会使用Index方式排序</p>
<ul>
<li><p>[1] order by 语句使用索引最左前列</p>
</li>
<li><p>[2] 使用where子句与order by子句条件列组合满足索引最左前列</p>
</li>
</ul>
<p><span style="color:red"><strong>遵循索引键的最佳作前缀</strong></span></p>
<h4 id="firesort两种算法"><a href="#firesort两种算法" class="headerlink" title="firesort两种算法"></a>firesort两种算法</h4><p><strong>如果不在索引列上，firesort有两种算法：mysql就要启动双路排序和单路排序</strong></p>
<h5 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a>双路排序</h5><p>​        MySQL4.1之前使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p>
<p>​        从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段</p>
<p>​        取一批数据，要对磁盘进行两次扫描，众所周知，I/O是很耗时的，所有在mysql4.1之后，出现了第二中改进的算法，就是单路排序</p>
<h5 id="单路排序"><a href="#单路排序" class="headerlink" title="单路排序"></a>单路排序</h5><p><img alt="1563589954385" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563589954385.png" class="lazyload"></p>
<h5 id="结论和引申"><a href="#结论和引申" class="headerlink" title="结论和引申"></a>结论和引申</h5><p>由于单路是后出的，总体而言好过双路，但是用单路有问题，一次数据拿不完还不如双路排序</p>
<p><img alt="1563590211157" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563590211157.png" class="lazyload"></p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>SQL数据库服务器的参数调优</p>
<p><img alt="1563590274583" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563590274583.png" class="lazyload"></p>
<h5 id="提高order-by的速度"><a href="#提高order-by的速度" class="headerlink" title="提高order by的速度"></a>提高order by的速度</h5><p><img alt="1563590318778" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563590318778.png" class="lazyload"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img alt="1563591106479" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563591106479.png" class="lazyload"></p>
<h3 id="3、group-by关键字优化"><a href="#3、group-by关键字优化" class="headerlink" title="3、group by关键字优化"></a>3、group by关键字优化</h3><p><img alt="1563610157651" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610157651.png" class="lazyload"></p>
<p>其他均和orderby一样</p>
<h2 id="2、慢查询日志"><a href="#2、慢查询日志" class="headerlink" title="2、慢查询日志"></a>2、慢查询日志</h2><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><img alt="1563610215972" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610215972.png" class="lazyload"></p>
<p><img alt="1563610333217" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610333217.png" class="lazyload"></p>
<h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><h4 id="1、查看是否开启了慢查询日志"><a href="#1、查看是否开启了慢查询日志" class="headerlink" title="1、查看是否开启了慢查询日志"></a>1、查看是否开启了慢查询日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES LIKE &apos;%slow_query_log%&apos;;</span><br></pre></td></tr></table></figure>
<p>win10如下：<br><img alt="1563610497080" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610497080.png" class="lazyload"></p>
<p>一般情况在如下目录</p>
<p><img alt="1563610510076" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610510076.png" class="lazyload"></p>
<p>linux如下：<br><img alt="1563610558929" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610558929.png" class="lazyload"></p>
<h4 id="2、开启慢查询日志"><a href="#2、开启慢查询日志" class="headerlink" title="2、开启慢查询日志"></a>2、开启慢查询日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log = 1;</span><br></pre></td></tr></table></figure>

<p><img alt="1563610684640" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610684640.png" class="lazyload"></p>
<p><img alt="1563610777025" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610777025.png" class="lazyload"></p>
<h4 id="3、查看设置慢查询时间"><a href="#3、查看设置慢查询时间" class="headerlink" title="3、查看设置慢查询时间"></a>3、查看设置慢查询时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%long_query_time%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563610913408" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610913408.png" class="lazyload"></p>
<h4 id="4、设置慢查询时间"><a href="#4、设置慢查询时间" class="headerlink" title="4、设置慢查询时间"></a>4、设置慢查询时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global long_query_time = 3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563611079970" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611079970.png" class="lazyload"></p>
<p>设置后满足以下两种情况才能看到变化</p>
<p><img alt="1563611124784" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611124784.png" class="lazyload"></p>
<p>模拟睡眠4秒，测试日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sleep(4);</span><br></pre></td></tr></table></figure>

<p><img alt="1563611454033" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611454033.png" class="lazyload"></p>
<p>linux下</p>
<p><img alt="1563614121741" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563614121741.png" class="lazyload"></p>
<h4 id="5、查询慢查询记录数"><a href="#5、查询慢查询记录数" class="headerlink" title="5、查询慢查询记录数"></a>5、查询慢查询记录数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global status like &apos;%Slow_queries%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563611671609" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611671609.png" class="lazyload"></p>
<p>用来查看当前系统的健康度如何</p>
<h4 id="6、永久设置"><a href="#6、永久设置" class="headerlink" title="6、永久设置"></a>6、永久设置</h4><p>修改my.cnf</p>
<p><img alt="1563611883839" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611883839.png" class="lazyload"></p>
<h3 id="3、分析"><a href="#3、分析" class="headerlink" title="3、分析"></a>3、分析</h3><p>使用MySQL的日志分析工具 <strong>mysqldumpslow</strong>，作为生产环境中分析日志，查找、分析SQL的工具</p>
<h4 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>linux上安装mysql后mysqldumpslow为/usr/bin的命令，可以直接使用</p>
<p><img alt="1563612995357" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563612995357.png" class="lazyload"></p>
<p>windows上安装mysql后使用的是mysqldumpslow.pl，但是需要安装perl环境后（安装ActivePerl），才能执行</p>
<p><img alt="1563613028342" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563613028342.png" class="lazyload"></p>
<p>常见参数</p>
<p><img alt="1563613097870" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563613097870.png" class="lazyload"></p>
<h4 id="2、使用-1"><a href="#2、使用-1" class="headerlink" title="2、使用"></a>2、使用</h4><p>常用参考</p>
<p><img alt="1563613249650" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563613249650.png" class="lazyload"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 localhost-slow.log</span><br></pre></td></tr></table></figure>

<p><img alt="1563614233668" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563614233668.png" class="lazyload"></p>
<p><strong>建议: 为方便 可以结合 | 和 more 使用，否则可能出现爆屏</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log | more</span><br></pre></td></tr></table></figure>





<h2 id="3、批量数据脚本"><a href="#3、批量数据脚本" class="headerlink" title="3、批量数据脚本"></a>3、批量数据脚本</h2><blockquote>
<p>往表里插入1000W数据</p>
</blockquote>
<h3 id="1、建立SQL"><a href="#1、建立SQL" class="headerlink" title="1、建立SQL"></a>1、建立SQL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1] 建立表dept</span><br><span class="line">create table dept(</span><br><span class="line">	id  int PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">	deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,</span><br><span class="line">	dname VARCHAR(20) NOT NULL DEFAULT &quot;&quot;,</span><br><span class="line">	loc VARCHAR(13) NOT NULL DEFAULT &quot;&quot;</span><br><span class="line">)</span><br><span class="line">ENGINE=InnoDB</span><br><span class="line">DEFAULT CHARSET=GBK;</span><br><span class="line"></span><br><span class="line"># [2] 建立表emp</span><br><span class="line">create table emp(</span><br><span class="line">	id  int PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">	empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 COMMENT &apos;编号&apos;,</span><br><span class="line">	ename VARCHAR(20) NOT NULL DEFAULT &quot;&quot; COMMENT &apos;名字&apos;,</span><br><span class="line">	job VARCHAR(9) NOT NULL DEFAULT &quot;&quot; COMMENT &apos;工作&apos;,</span><br><span class="line">	mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 COMMENT &apos;上级编号&apos;,</span><br><span class="line">	hiredate DATE NOT NULL COMMENT &apos;入职时间&apos;,</span><br><span class="line">	sal DECIMAL(7,2) NOT NULL COMMENT &apos;薪水&apos;,</span><br><span class="line">	comm DECIMAL(7,2) NOT NULL COMMENT &apos;红利&apos;,</span><br><span class="line">	deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 COMMENT &apos;部门编号&apos;</span><br><span class="line">)</span><br><span class="line">ENGINE=InnoDB</span><br><span class="line">DEFAULT CHARSET=GBK;</span><br></pre></td></tr></table></figure>

<h3 id="2、设置参数"><a href="#2、设置参数" class="headerlink" title="2、设置参数"></a>2、设置参数</h3><blockquote>
<p>log_bin_trust_function_creators</p>
</blockquote>
<p><img alt="1563615598373" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563615598373.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># [3] 设置参数</span><br><span class="line"># 由于开启慢查询日志，因为我们开启了bin-log，就必须为我们的function指定一个参数</span><br><span class="line">show VARIABLES LIKE &apos;log_bin_trust_function_creators&apos;;</span><br><span class="line"></span><br><span class="line">set global log_bin_trust_function_creators = 1;</span><br></pre></td></tr></table></figure>



<h3 id="3、创建函数"><a href="#3、创建函数" class="headerlink" title="3、创建函数"></a>3、创建函数</h3><p>保证每条数据都不同，随机产生字符串，随机产生部门编号</p>
<h4 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a>随机产生字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建函数</span><br><span class="line"># 改变了mysql由原来用;结束语句改成了$$,因为函数中有多个;在一起</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE char_str VARCHAR(100) DEFAULT &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLNOPQRSTUVWXYZ&apos;;</span><br><span class="line">	DECLARE return_str VARCHAR(255) DEFAULT &apos;&apos;;</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	WHILE i &lt; n </span><br><span class="line">	DO</span><br><span class="line">		SET return_str = CONCAT(return_str,SUBSTRING(char_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">		SET i = i + 1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	RETURN return_str;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>

<h4 id="随机产生部门编号"><a href="#随机产生部门编号" class="headerlink" title="随机产生部门编号"></a>随机产生部门编号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_num() RETURNS INT(5)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET i = FLOOR(10+RAND()*10);</span><br><span class="line">	RETURN i;</span><br><span class="line">END $$</span><br><span class="line">#删除函数</span><br><span class="line">drop FUNCTION rand_num;</span><br></pre></td></tr></table></figure>

<h3 id="4、创建存储过程"><a href="#4、创建存储过程" class="headerlink" title="4、创建存储过程"></a>4、创建存储过程</h3><h4 id="emp表插入数据"><a href="#emp表插入数据" class="headerlink" title="emp表插入数据"></a>emp表插入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_emp(in start INT(10),in max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET autocommit = 0;</span><br><span class="line">	REPEAT</span><br><span class="line">		SET i = i+1;</span><br><span class="line">		INSERT INTO emp(empno,     ename,        job,      mgr,  hiredate, sal, comm,  deptno)</span><br><span class="line">		VALUES         (start+i,rand_string(6),&apos;SALESMAN&apos;,0001,CURDATE(),  2000, 400,   rand_num());</span><br><span class="line">		UNTIL i = max_num</span><br><span class="line">	END REPEAT;</span><br><span class="line">	COMMIT;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>



<h4 id="dept表插入数据"><a href="#dept表插入数据" class="headerlink" title="dept表插入数据"></a>dept表插入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_dept(in start INT(10),in max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET autocommit = 0;</span><br><span class="line">	REPEAT</span><br><span class="line">		SET i = i+1;</span><br><span class="line">		INSERT INTO emp(deptno,     dname,        loc)</span><br><span class="line">		VALUES         (start+i,rand_string(10),rand_string(8));</span><br><span class="line">		UNTIL i = max_num</span><br><span class="line">	END REPEAT;</span><br><span class="line">	COMMIT;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>



<h3 id="5、调用存储过程"><a href="#5、调用存储过程" class="headerlink" title="5、调用存储过程"></a>5、调用存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER ;</span><br><span class="line">call insert_dept(100,10);</span><br><span class="line"></span><br><span class="line">call insert_emp(100001,500000);</span><br><span class="line">call insert_emp(160001,500000);</span><br><span class="line">call insert_emp(1100001,500000);</span><br><span class="line">call insert_emp(1600001,500000);</span><br><span class="line">call insert_emp(2100001,500000);</span><br></pre></td></tr></table></figure>

<p>50W数据时间比较长，2分多钟</p>
<p><img alt="1563693337031" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563693337031.png" class="lazyload"></p>
<h2 id="4、show-profile（-star-star-star-）"><a href="#4、show-profile（-star-star-star-）" class="headerlink" title="4、show profile（:star::star::star:）"></a>4、show profile（:star::star::star:）</h2><h3 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于sql的调优的测量，分析SQL性能</p>
<p><img alt="1563694967549" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563694967549.png" class="lazyload"></p>
<h3 id="2、分析步骤"><a href="#2、分析步骤" class="headerlink" title="2、分析步骤"></a>2、分析步骤</h3><p><img alt="1563695234485" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563695234485.png" class="lazyload"></p>
<h4 id="1、查看当前mysql版本是否支持"><a href="#1、查看当前mysql版本是否支持" class="headerlink" title="1、查看当前mysql版本是否支持"></a>1、查看当前mysql版本是否支持</h4><p>Show profiles是5.0.37之后添加的，要想使用此功能，要确保版本在5.0.37之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看数据库版本</span><br><span class="line">select version();</span><br><span class="line"></span><br><span class="line"># 默认关闭的</span><br><span class="line">show VARIABLES like &apos;profiling&apos;;</span><br><span class="line"># show VARIABLES like &apos;profiling%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563695307056" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563695307056.png" class="lazyload"></p>
<h4 id="2、开启功能"><a href="#2、开启功能" class="headerlink" title="2、开启功能"></a>2、开启功能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set profiling = on;</span><br></pre></td></tr></table></figure>

<p><img alt="1563695378420" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563695378420.png" class="lazyload"></p>
<h4 id="3、运行SQL"><a href="#3、运行SQL" class="headerlink" title="3、运行SQL"></a>3、运行SQL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改下sql_mode ，否则不能用[1] 和[2] ,这里只是打个比方，group by不能这样用</span><br><span class="line">show variables like &quot;sql_mode&quot;;</span><br><span class="line">set sql_mode=&apos;&apos;;</span><br><span class="line">set sql_mode=&apos;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&apos;;</span><br><span class="line">#set sql_mode=&apos;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;</span><br><span class="line"></span><br><span class="line">#[1]</span><br><span class="line">select * from emp group by id%10 limit 150000;</span><br><span class="line">#[2]</span><br><span class="line">select * from emp group by id%10  order by 5;</span><br></pre></td></tr></table></figure>





<h4 id="4、诊断SQL"><a href="#4、诊断SQL" class="headerlink" title="4、诊断SQL"></a>4、诊断SQL</h4><p>执行的sql语句会被记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>

<p><img alt="1563701659351" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563701659351.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#同时查看不同资源开销   根据query_id来查看sql的生命周期</span><br><span class="line">show profile cpu,block io for query 7;</span><br></pre></td></tr></table></figure>

<p><img alt="1563701738671" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563701738671.png" class="lazyload"></p>
<p>常见的参数如下：</p>
<p><img alt="1563702101846" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563702101846.png" class="lazyload"></p>
<p>常见的状态</p>
<table>
<thead>
<tr>
<th><strong>Status</strong></th>
<th><strong>建议</strong></th>
</tr>
</thead>
<tbody><tr>
<td>System lock</td>
<td>确认是由于哪个锁引起的，通常是因为MySQL或InnoDB内核级的锁引起的建议：如果耗时较大再关注即可，一般情况下都还好</td>
</tr>
<tr>
<td>Sending data</td>
<td>从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见备注：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net建议：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量</td>
</tr>
<tr>
<td>Sorting result</td>
<td>正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序建议：创建适当的索引</td>
</tr>
<tr>
<td>Table lock</td>
<td>表级锁，没什么好说的，要么是因为MyISAM引擎表级锁，要么是其他情况显式锁表</td>
</tr>
<tr>
<td>create sort index</td>
<td>当前的SELECT中需要用到临时表在进行ORDER BY排序建议：创建适当的索引</td>
</tr>
<tr>
<td>checking query cache for querychecking privileges on cachedsending cached result to clienstoring result in query cache</td>
<td>和query cache相关的状态，已经多次强烈建议关闭</td>
</tr>
</tbody></table>
<h4 id="5、日常开发需要注意的结论"><a href="#5、日常开发需要注意的结论" class="headerlink" title="5、日常开发需要注意的结论"></a>5、日常开发需要注意的结论</h4><p>避免以下几种情况，需要优化SQL语句</p>
<p><img alt="1563702184744" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563702184744.png" class="lazyload"></p>
<p><img alt="1563710332244" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563710332244.png" class="lazyload"></p>
<h2 id="5、全局查询日志"><a href="#5、全局查询日志" class="headerlink" title="5、全局查询日志"></a>5、全局查询日志</h2><blockquote>
<p>永远不要在生产环境开启这个功能</p>
</blockquote>
<h3 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h3><p>方式一：配置文件启用</p>
<p><img alt="1563719697578" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563719697578.png" class="lazyload"></p>
<p>方式二：</p>
<p><img alt="1563719720626" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563719720626.png" class="lazyload"></p>
<p>可以查看某个时间段的sql语句，时间段故障分析</p>
<p><img alt="1563719852329" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563719852329.png" class="lazyload"></p>
<h1 id="4、MySQL锁机制"><a href="#4、MySQL锁机制" class="headerlink" title="4、MySQL锁机制"></a>4、MySQL锁机制</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p><img alt="1563760231545" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563760231545.png" class="lazyload"></p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>1、对数据操作的类型分</p>
<p>[1] 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</p>
<p>[2] 写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</p>
<p>2、对数据操作的粒度来分</p>
<p>[1] 表锁</p>
<p>[2] 行锁</p>
<h2 id="2、三锁"><a href="#2、三锁" class="headerlink" title="2、三锁"></a>2、三锁</h2><p>从开销、加锁速度、死锁、粒度、并发性能，根据具体应用的特点来说哪种锁更合适</p>
<h3 id="1、表锁（偏读）"><a href="#1、表锁（偏读）" class="headerlink" title="1、表锁（偏读）"></a>1、表锁（偏读）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率高，并发度最低</p>
</blockquote>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL-1"><a href="#建表SQL-1" class="headerlink" title="建表SQL"></a>建表SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table mylock(</span><br><span class="line">	id int not null PRIMARY KEY auto_increment,</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">)ENGINE myisam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into mylock(name) VALUES(&apos;a&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;b&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;c&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;d&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;e&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;f&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * from mylock;</span><br></pre></td></tr></table></figure>





<h5 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h5><p>开启两个session，分别为session1、session2</p>
<p><strong>session1对mylock表加锁时</strong></p>
<p>【1】分别读取mylock和book表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -----------       [ session1 ]     ---------------------</span><br><span class="line"># -----------[ session1对mylock表加读锁时 ]---------------</span><br><span class="line">lock table mylock read;</span><br><span class="line"></span><br><span class="line">select * from mylock;</span><br><span class="line"># session1 不能读其他表，必须释放前面的锁</span><br><span class="line">select * from book;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ------------------[ session2 ]------------------</span><br><span class="line"># ------------session1对mylock表加读锁时--------------</span><br><span class="line"># 可以读所有的表</span><br><span class="line">select * from mylock;</span><br><span class="line">select * from book;</span><br></pre></td></tr></table></figure>

<p><img alt="1563762886163" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563762886163.png" class="lazyload"></p>
<p><img alt="1563762962117" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563762962117.png" class="lazyload"></p>
<p>【2】分别修改mylock表时</p>
<p>session1不能修改mylock表，session2修改表时出现阻塞情况，必须等session1结束后session2才能修改成功</p>
<p><img alt="读锁阻塞" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E8%AF%BB%E9%94%81%E9%98%BB%E5%A1%9E.gif" class="lazyload"></p>
<p><img alt="读锁" data-src="/.cn//Users/MxRanger/Desktop/%E8%AF%BB%E9%94%81.png" class="lazyload"></p>
<h5 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h5><p><strong>session1对mylock表加锁时</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-------------[session1]--------------</span><br><span class="line">#--------------加写锁时------------------</span><br><span class="line">lock table mylock write;</span><br><span class="line"></span><br><span class="line"># 可读</span><br><span class="line">select * from mylock;</span><br><span class="line">#可更改</span><br><span class="line">update mylock set name = &apos;a4&apos; where id = 1;</span><br><span class="line"></span><br><span class="line"># 不能读其他表之前的未释放</span><br><span class="line">select * from book;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#-------------[session2]----------------</span><br><span class="line">#读其他未上锁的表正常</span><br><span class="line">select * from book;</span><br><span class="line"></span><br><span class="line">#阻塞 session1独占查询修改，session2查询都不行，修改也是一样</span><br><span class="line">select * from mylock;</span><br></pre></td></tr></table></figure>



<p><img alt="写锁" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E5%86%99%E9%94%81.png" class="lazyload"></p>
<h5 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h5><p><img alt="读写锁结论" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E8%AF%BB%E5%86%99%E9%94%81%E7%BB%93%E8%AE%BA.png" class="lazyload"></p>
<p><span style="color:red"><strong>简而言之，就是读锁会阻塞写，但是不会阻塞读。写锁会把读和写都阻塞。</strong></span></p>
<p><img alt="读写锁结论2" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E8%AF%BB%E5%86%99%E9%94%81%E7%BB%93%E8%AE%BA2.png" class="lazyload"></p>
<h3 id="2、行锁（偏写）"><a href="#2、行锁（偏写）" class="headerlink" title="2、行锁（偏写）"></a>2、行锁（偏写）</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度也最高</p>
<p><span style="color:red"><strong>InnDB与MyISAM的最大不同两点：一是支持事务；而是采用行级锁</strong></span></p>
</blockquote>
<h4 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h4><h5 id="事务、ACID属性"><a href="#事务、ACID属性" class="headerlink" title="事务、ACID属性"></a>事务、ACID属性</h5><p><img alt="1563849196042" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849196042.png" class="lazyload"></p>
<h5 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h5><p>并发事务处理带来的问题</p>
<h6 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h6><p><img alt="1563849282872" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849282872.png" class="lazyload"></p>
<h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p><img alt="1563849298280" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849298280.png" class="lazyload"></p>
<h6 id="不可重复度"><a href="#不可重复度" class="headerlink" title="不可重复度"></a>不可重复度</h6><p><img alt="1563849324263" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849324263.png" class="lazyload"></p>
<h6 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h6><p><img alt="1563849369136" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849369136.png" class="lazyload"></p>
<p><span style="color:red"><strong>总结：**</strong>脏读是事务A读取到事务B里面修改了数据，幻读是事务A读取到事务B里面新增了数据**</span></p>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p><img alt="1563849571041" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849571041.png" class="lazyload"></p>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建立SQL-3"><a href="#建立SQL-3" class="headerlink" title="建立SQL"></a>建立SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_innodb_lock(</span><br><span class="line">	a int(11),</span><br><span class="line">	b varchar(16)</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">insert into test_innodb_lock VALUES(1,&apos;b2&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(2,&apos;3&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(3,&apos;3000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(4,&apos;4000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(5,&apos;5000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(6,&apos;6000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(7,&apos;7000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(8,&apos;8000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(9,&apos;9000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(1,&apos;b1&apos;);</span><br><span class="line"></span><br><span class="line">create INDEX test_innodb_a_ind on test_innodb_lock(a);</span><br><span class="line"></span><br><span class="line">create INDEX test_innodb_b_ind on test_innodb_lock(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from test_innodb_lock;</span><br></pre></td></tr></table></figure>

<h5 id="行锁基本演示"><a href="#行锁基本演示" class="headerlink" title="行锁基本演示"></a>行锁基本演示</h5><p>【1】首先查看了当前的隔离级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;tx_isolation&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563864436638" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563864436638.png" class="lazyload"></p>
<p>【2】修改同一行</p>
<p>开启两个session会话</p>
<p>两个会话同时设置<code>set autocommit = 0;</code>把自动提交关了</p>
<p>修改某行内容，两个会话同时查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#--------------[session1]-------------</span><br><span class="line">#--------------[1] 修改某行内容</span><br><span class="line">update test_innodb_lock set b = &apos;4005&apos; WHERE a = 4;</span><br><span class="line">select * from test_innodb_lock;</span><br><span class="line"></span><br><span class="line">#--------------[session2]-------------</span><br><span class="line">select * from test_innodb_lock;</span><br></pre></td></tr></table></figure>

<p><img alt="1563864779345" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563864779345.png" class="lazyload"></p>
<p>保证了隔离级别达到的不出现<strong>脏读</strong>的情况，且在session1进行commit而session2没有commit的情况下，session2依然不会读取到修改后的值，保证了不会出现<strong>不可重复读</strong></p>
<p>两个会话都<code>commit;</code>内容一致</p>
<p><img alt="1563864862384" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563864862384.png" class="lazyload"></p>
<p>当session1在修改而没有commit时，session2进行修改同一行，会出现阻塞的情况，直到session1提交才能修改成功</p>
<p><img alt="1563865115947" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563865115947.png" class="lazyload"></p>
<p>【3】修改不同行</p>
<p>不会发生冲突，<strong>大路朝天各走一边</strong></p>
<p><img alt="1563865130783" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563865130783.png" class="lazyload"></p>
<h5 id="索引失效行锁变表锁"><a href="#索引失效行锁变表锁" class="headerlink" title="索引失效行锁变表锁"></a>索引失效行锁变表锁</h5><p>正常情况下：<br><img alt="1563867004784" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867004784.png" class="lazyload"></p>
<p>索引失效情况下：行锁变表锁<br><img alt="1563867120057" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867120057.png" class="lazyload"></p>
<h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p>表中1-6缺少2的情况下</p>
<p><img alt="1563867588304" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867588304.png" class="lazyload"></p>
<p>两个会话都提交后<br><img alt="1563867629535" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867629535.png" class="lazyload"></p>
<p>【结论】<br><img alt="1563867700797" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867700797.png" class="lazyload"></p>
<h5 id="面试题-star-star-star"><a href="#面试题-star-star-star" class="headerlink" title="面试题(:star::star::star:)"></a>面试题(:star::star::star:)</h5><p>如何锁定一行</p>
<p>在sql语句后加上<code>for update</code></p>
<p><img alt="1563867967102" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867967102.png" class="lazyload"></p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><h5 id="Innodb优缺点"><a href="#Innodb优缺点" class="headerlink" title="Innodb优缺点"></a>Innodb优缺点</h5><p><img alt="1563868323949" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868323949.png" class="lazyload"></p>
<h5 id="如何分析行锁定"><a href="#如何分析行锁定" class="headerlink" title="如何分析行锁定"></a>如何分析行锁定</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;innodb_row_lock%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563868485083" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868485083.png" class="lazyload"></p>
<p><img alt="1563868650448" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868650448.png" class="lazyload"></p>
<h5 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h5><p><img alt="1563868717901" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868717901.png" class="lazyload"></p>
<h3 id="3、页锁"><a href="#3、页锁" class="headerlink" title="3、页锁"></a>3、页锁</h3><p><img alt="1563868765523" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868765523.png" class="lazyload"></p>
<h1 id="5、主从复制"><a href="#5、主从复制" class="headerlink" title="5、主从复制"></a>5、主从复制</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>slave从master读取binlog来进行数据同步，主要做多处备份</p>
<p><img alt="1563869815730" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563869815730.png" class="lazyload"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>具体的百度搜吧，一大堆</p>
<hr>
<p>以下不用看</p>
<p>1、mysql版本一致，且互相ping通，服务正常运行</p>
<p>2、</p>
<p><img alt="1563871262129" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871262129.png" class="lazyload"></p>
<p><img alt="1563871272513" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871272513.png" class="lazyload"></p>
<p><img alt="1563871295033" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871295033.png" class="lazyload"></p>
<p><img alt="1563871308785" data-src="http://img.mxranger.cn/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871308785.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础教程</title>
    <url>/2019/12/12/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h3 id="1、数据库的好处"><a href="#1、数据库的好处" class="headerlink" title="1、数据库的好处"></a>1、数据库的好处</h3><p>持久化数据到本地<br>可以实现结构化查询，方便管理</p>
<h3 id="2、数据库相关概念"><a href="#2、数据库相关概念" class="headerlink" title="2、数据库相关概念"></a>2、数据库相关概念</h3><p>DB:database：存储数据的“仓库”。它保存了一系列有组织的数据。</p>
<p>DBMS：数据库管理系统（Database Management System）。数据库是通过DBMS创建和操作的容器</p>
<ul>
<li>基于共享文件系统的DBMS（Access）</li>
<li>基于客户机-服务器（CS）的DBMS （MySQL、Oracle、SqlServer）</li>
</ul>
<p>SQL：结构化查询语言（Structure Query Language）：专门用来与数据库通信的语言。</p>
<p>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等</p>
<p><img alt="1560403616380" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560403616380.png" class="lazyload"></p>
<h3 id="3、数据库存储数据的特点"><a href="#3、数据库存储数据的特点" class="headerlink" title="3、数据库存储数据的特点"></a>3、数据库存储数据的特点</h3><p>​    1、将数据放到表中，表再放到库中<br>​    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>​    3、<strong>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</strong><br>​    4、<strong>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</strong><br>​    5、<strong>表中的数据是按行存储的，每一行类似于java中的“对象”。</strong></p>
<h2 id="2、mysql使用"><a href="#2、mysql使用" class="headerlink" title="2、mysql使用"></a>2、mysql使用</h2><h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a>1、登录</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>通过mysql自带的客户端，只限于root用户</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>将mysql文件夹下的bin目录添加到环境变量中，cmd中输入</p>
<p><code>-h:host  -P:port -u:user -p:password</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 3306 -u root -p</span><br></pre></td></tr></table></figure>

<p>输入密码</p>
<p><img alt="1560404879953" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560404879953.png" class="lazyload"></p>
<h3 id="2、SQL的常见命令"><a href="#2、SQL的常见命令" class="headerlink" title="2、SQL的常见命令"></a>2、SQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line"></span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line"></span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">	列名 列类型,</span><br><span class="line">	列名 列类型，</span><br><span class="line">	。。。</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br></pre></td></tr></table></figure>



<h3 id="3、mysql语法规范"><a href="#3、mysql语法规范" class="headerlink" title="3、mysql语法规范"></a>3、mysql语法规范</h3><p>1、不区分大小写,但建议关键字大写，表名、列名小写<br>2、每条命令最好用分号结尾<br>3、每条命令根据需要，可以进行缩进 或换行<br>4、注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字</span><br><span class="line">单行注释：-- 注释文字  必须加空格</span><br><span class="line">多行注释：/* 注释文字  */</span><br></pre></td></tr></table></figure>

<h3 id="4、SQL的语言分类"><a href="#4、SQL的语言分类" class="headerlink" title="4、SQL的语言分类"></a>4、SQL的语言分类</h3><p>DQL（Data Query Language）：数据查询语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select</span><br></pre></td></tr></table></figure>
<p>DML(Data Manipulate Language):数据操作语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 、update、delete</span><br></pre></td></tr></table></figure>
<p>DDL（Data Define Languge）：数据定义语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create、drop、alter</span><br></pre></td></tr></table></figure>
<p>TCL（Transaction Control Language）：事务控制语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit、rollback</span><br></pre></td></tr></table></figure>



<h2 id="3、DQL语言学习"><a href="#3、DQL语言学习" class="headerlink" title="3、DQL语言学习"></a>3、DQL语言学习</h2><blockquote>
<p>Data Query Language —— 数据查询语言</p>
</blockquote>
<p>准备数据，字段介绍</p>
<p><img alt="1560407441118" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560407441118.png" class="lazyload"></p>
<h3 id="1、基础查询"><a href="#1、基础查询" class="headerlink" title="1、基础查询"></a>1、基础查询</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>select 查询列表 from 表名;</p>
<p>类似java中的<code>System.out.println(...)</code>打印</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、查询列表可以是：表中的字段、常量值、表达式、函数<br>2、查询的结果是一个虚拟的表格</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#推荐指定某个数据库</span><br><span class="line">USE myemployees;</span><br></pre></td></tr></table></figure>
<p>1、查询表中的单个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name FROM employees;</span><br></pre></td></tr></table></figure>
<p>2、查询表中的多个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,salary,email FROM employees;</span><br></pre></td></tr></table></figure>
<p>3、查询表中的所有字段<br>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    `employee_id`,</span><br><span class="line">    `first_name`,</span><br><span class="line">    `last_name`,</span><br><span class="line">    `phone_number`,</span><br><span class="line">    `last_name`,</span><br><span class="line">    `job_id`,</span><br><span class="line">    `phone_number`,</span><br><span class="line">    `job_id`,</span><br><span class="line">    `salary`,</span><br><span class="line">    `commission_pct`,</span><br><span class="line">    `manager_id`,</span><br><span class="line">    `department_id`,</span><br><span class="line">    `hiredate` </span><br><span class="line">FROM</span><br><span class="line">    employees ;</span><br></pre></td></tr></table></figure>
<p>方式二： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure>


<p> 4、查询常量值</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100;</span><br><span class="line">SELECT &apos;john&apos;;</span><br></pre></td></tr></table></figure>


<p> 5、查询表达式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98;</span><br><span class="line">SELECT 100*98;</span><br></pre></td></tr></table></figure>



<p> 6、查询mysql版本函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>



<p> 7、起别名<br> ①便于理解<br> ②如果要查询的字段有重名的情况，使用别名可以区分开来</p>
<p>方式一：使用as</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line">SELECT last_name AS 姓,first_name AS 名 FROM employees;</span><br></pre></td></tr></table></figure>

<p>方式二：使用空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name 姓,first_name 名 FROM employees;</span><br></pre></td></tr></table></figure>

<p>案例：查询salary，显示结果为 out put</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary AS &quot;out put&quot; FROM employees;</span><br></pre></td></tr></table></figure>



<p>8、去重 使用DISTINCT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工表中涉及到的所有的部门编号</span><br><span class="line">SELECT DISTINCT department_id FROM employees;</span><br></pre></td></tr></table></figure>



<p>9、+号的作用</p>
<p>java中的+号：<br>①运算符，两个操作数都为数值型<br>②连接符，只要有一个操作数为字符串</p>
<p>mysql中的+号：<br>仅仅只有一个功能：运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 100+90; 两个操作数都为数值型，则做加法运算</span><br><span class="line">select &apos;123&apos;+90;只要其中一方为字符型，试图将字符型数值转换成数值型.如果转换成功，则继续做加法运算</span><br><span class="line">select &apos;john&apos;+90;	如果转换失败，则将字符型数值转换成0</span><br><span class="line">select null+10; 只要其中一方为null，则结果肯定为null</span><br></pre></td></tr></table></figure>



<p>10、concat作用<br>案例：查询员工名和姓连接成一个字段，并显示为 姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) AS 结果;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">	CONCAT(last_name,first_name) AS 姓名</span><br><span class="line">FROM</span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>显示表departments的结构，并查询其中的全部数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc departments;</span><br></pre></td></tr></table></figure>



<p>显示出表employees中的全部job_id（不能重复）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct job_id from employees;</span><br></pre></td></tr></table></figure>



<p>显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(`first_name`,&apos;,&apos;,`last_name`,&apos;,&apos;,`job_id`,&apos;,&apos;,IFNULL(commission_pct,0)) as out_put</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<p><img alt="1560409611290" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560409611290.png" class="lazyload"></p>
<h3 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	查询列表</span><br><span class="line">from</span><br><span class="line">	表名</span><br><span class="line">where</span><br><span class="line">	筛选条件;</span><br></pre></td></tr></table></figure>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1、按条件表达式筛选</p>
<p>简单条件运算符：<code>&gt;</code> <code>&lt;</code>  <code>=</code>  <code>!=</code>  <code>&lt;&gt; (等同于!=)</code>  <code>&gt;=</code>  <code>&lt;=</code></p>
<p>2、按逻辑表达式筛选<br>逻辑运算符：<br>作用：用于连接条件表达式<br><code>&amp;&amp;</code> <code>||</code> <code>!</code>    <code>and</code> <code>or</code> <code>not</code></p>
<p>3、模糊查询<br><code>like</code> <code>between and</code> <code>in</code> <code>is null</code></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>1、按条件表达式筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询工资&gt;12000的员工信息</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary&gt;12000;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#案例2：查询部门编号不等于90号的员工名和部门编号</span><br><span class="line">SELECT </span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	department_id&lt;&gt;90;</span><br></pre></td></tr></table></figure>

<p>2、按逻辑表达式筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary&gt;=10000 AND salary&lt;=20000;</span><br><span class="line">#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	#department_id&gt;90 or department_id&lt;110 OR salary&gt;15000;</span><br><span class="line">	NOT(department_id&gt;=90 AND  department_id&lt;=110) OR salary&gt;15000;</span><br></pre></td></tr></table></figure>



<p>3、模糊查询<br><code>like</code> <code>between and</code> <code>in</code> <code>is null</code> <code>is not null</code></p>
<p>【1】like</p>
<blockquote>
<p>一般和通配符搭配使用，%表示任意个数的任意字符(但是不包含null)<br>    通配符：<br>    % 任意多个字符,包含0个字符<br>    _ 任意单个字符</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询员工名中包含字符a的员工信息</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	last_name like &apos;%a%&apos;;#abc</span><br><span class="line">	</span><br><span class="line">#案例2：查询员工名中第三个字符为e，第五个字符为n的员工名和工资</span><br><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &apos;__e_n%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：查询员工名中第二个字符为_的员工名</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	last_name</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &apos;_$_%&apos; ESCAPE &apos;$&apos;;</span><br></pre></td></tr></table></figure>



<p>【2】between and</p>
<blockquote>
<p>①使用between and 可以提高语句的简洁度<br>②包含临界值<br>③两个临界值不要调换顺序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询员工编号在100到120之间的员工信息</span><br><span class="line"># --------------------方式一 -------------</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	employee_id &gt;= 100 AND employee_id&lt;=120;</span><br><span class="line">#----------------------方式二 -----------</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	employee_id BETWEEN 100 AND 120;</span><br></pre></td></tr></table></figure>



<p>【3】in</p>
<blockquote>
<p>含义：判断某字段的值是否属于in列表中的某一项<br>特点：<br>    ①使用in提高语句简洁度<br>    ②in列表的值类型必须一致或兼容（类似隐式转换）<br>    ③in列表中不支持通配符，必须强制指定某个值，原因在于in就是等号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</span><br><span class="line"># -----------方式一（繁琐）--------------</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	job_id = &apos;IT_PROT&apos; OR job_id = &apos;AD_VP&apos; OR JOB_ID =&apos;AD_PRES&apos;;</span><br><span class="line"></span><br><span class="line">#-----------方式二（简洁）-------</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	job_id IN( &apos;IT_PROT&apos; ,&apos;AD_VP&apos;,&apos;AD_PRES&apos;);</span><br></pre></td></tr></table></figure>

<p>【4】is null</p>
<blockquote>
<p>=或&lt;&gt;不能用于判断null值<br>is null或is not null 可以判断null值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>【5】安全等于 <code>&lt;=&gt;</code></p>
<blockquote>
<p>可以判断null值，也可以判断普通值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct &lt;=&gt;NULL;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#案例2：查询工资为12000的员工信息</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line"></span><br><span class="line">WHERE </span><br><span class="line">	salary &lt;=&gt; 12000;</span><br></pre></td></tr></table></figure>

<p>【总结】</p>
<p>IS NULL:仅仅可以判断NULL值，可读性较高，建议使用<br>&lt;=&gt;    :既可以判断NULL值，又可以判断普通的数值，可读性较低</p>
<p>【6】面试题</p>
<p>1、表内容如下</p>
<p><img alt="1560413964860" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560413964860.png" class="lazyload"></p>
<p><code>select * from test;</code>和<code>select * from where name like &#39;%%&#39;;</code>查询结果是否一样？</p>
<p>select * from test结果如下：</p>
<p><img alt="1560414017635" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560414017635.png" class="lazyload"></p>
<p>select * from where name like ‘%%’结果如下：</p>
<p><img alt="1560414039763" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560414039763.png" class="lazyload"></p>
<p><strong>%表示任意个数的任意字符(但是不包含null)</strong></p>
<h3 id="3、排序查询"><a href="#3、排序查询" class="headerlink" title="3、排序查询"></a>3、排序查询</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表名</span><br><span class="line">【where  筛选条件】</span><br><span class="line">order by 排序的字段或表达式;</span><br></pre></td></tr></table></figure>



<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1、asc代表的是升序，可以省略，desc代表的是降序</p>
<p>2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段</p>
<p>3、order by子句在查询语句的最后面，除了limit子句</p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1、按单个字段排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees ORDER BY salary DESC;</span><br></pre></td></tr></table></figure>
<p>2、添加筛选条件再排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询部门编号&gt;=90的员工信息，并按员工编号降序</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id&gt;=90</span><br><span class="line">ORDER BY employee_id DESC;</span><br></pre></td></tr></table></figure>

<p>3、按表达式排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息 按年薪降序</span><br><span class="line"></span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;</span><br></pre></td></tr></table></figure>

<p>4、按别名排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息 按年薪升序</span><br><span class="line"></span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY 年薪 ASC;</span><br></pre></td></tr></table></figure>
<p>5、按函数排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工名，并且按名字的长度降序</span><br><span class="line"></span><br><span class="line">SELECT LENGTH(last_name),last_name </span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY LENGTH(last_name) DESC;</span><br></pre></td></tr></table></figure>
<p>6、按多个字段排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息，要求先按工资降序，再按employee_id升序</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC,employee_id ASC;</span><br></pre></td></tr></table></figure>



<h3 id="4、常见函数"><a href="#4、常见函数" class="headerlink" title="4、常见函数"></a>4、常见函数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>1、隐藏了实现细节  2、提高代码的重用性</p>
<p>调用：select 函数名(实参列表) from 表;</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>叫什么（函数名）、干什么（函数功能）</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>1、单行函数<br>    如 concat、length、ifnull等<br>2、分组函数<br>    功能：做统计使用，又称为统计函数、聚合函数、组函数</p>
<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><h5 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h5><h6 id="1、length-获取参数值的字节个数"><a href="#1、length-获取参数值的字节个数" class="headerlink" title="1、length 获取参数值的字节个数"></a>1、length 获取参数值的字节个数</h6><p>获取字节个数(utf-8一个汉字代表3个字节，gbk为2个字节)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&apos;john&apos;);</span><br><span class="line">SELECT LENGTH(&apos;张三丰hahaha&apos;);</span><br><span class="line"># 查看当前字符集</span><br><span class="line">SHOW VARIABLES LIKE &apos;%char%&apos;</span><br></pre></td></tr></table></figure>
<h6 id="2、concat-拼接字符串"><a href="#2、concat-拼接字符串" class="headerlink" title="2、concat 拼接字符串"></a>2、concat 拼接字符串</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(last_name,&apos;_&apos;,first_name) 姓名 FROM employees;</span><br></pre></td></tr></table></figure>
<h6 id="3、upper、lower"><a href="#3、upper、lower" class="headerlink" title="3、upper、lower"></a>3、upper、lower</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&apos;john&apos;);</span><br><span class="line">SELECT LOWER(&apos;joHn&apos;);</span><br><span class="line">#示例：将姓变大写，名变小写，然后拼接</span><br><span class="line">SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;</span><br></pre></td></tr></table></figure>

<h6 id="4、substr、substring"><a href="#4、substr、substring" class="headerlink" title="4、substr、substring"></a>4、substr、substring</h6><p><span style="color:red"><strong>注意：索引从1开始</strong></span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#截取从指定索引处后面所有字符</span><br><span class="line">SELECT SUBSTR(&apos;李莫愁爱上了陆展元&apos;,7)  out_put;</span><br><span class="line"></span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">SELECT SUBSTR(&apos;李莫愁爱上了陆展元&apos;,1,3) out_put;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来</span><br><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&apos;_&apos;,LOWER(SUBSTR(last_name,2)))  out_put</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h6 id="5、instr"><a href="#5、instr" class="headerlink" title="5、instr"></a>5、instr</h6><p>返回子串第一次出现的索引，如果找不到返回0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&apos;杨不殷六侠悔爱上了殷六侠&apos;,&apos;殷六侠&apos;) AS out_put;</span><br></pre></td></tr></table></figure>
<h6 id="6、trim"><a href="#6、trim" class="headerlink" title="6、trim"></a>6、trim</h6><p>只去前后空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(TRIM(&apos;    张翠山    &apos;)) AS out_put;</span><br><span class="line"></span><br><span class="line">SELECT TRIM(&apos;aa&apos; FROM &apos;aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&apos;)  AS out_put;</span><br></pre></td></tr></table></figure>

<h6 id="7、lpad"><a href="#7、lpad" class="headerlink" title="7、lpad"></a>7、lpad</h6><p>用指定的字符实现左填充指定长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&apos;殷素素&apos;,、10,&apos;*&apos;) AS out_put;</span><br></pre></td></tr></table></figure>

<h6 id="8、rpad"><a href="#8、rpad" class="headerlink" title="8、rpad"></a>8、rpad</h6><p>用指定的字符实现右填充指定长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT RPAD(&apos;殷素素&apos;,12,&apos;ab&apos;) AS out_put;</span><br></pre></td></tr></table></figure>



<h6 id="9、replace-替换"><a href="#9、replace-替换" class="headerlink" title="9、replace 替换"></a>9、replace 替换</h6><p>有多个则都替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&apos;周芷若周芷若周芷若周芷若张无忌爱上了周芷若&apos;,&apos;周芷若&apos;,&apos;赵敏&apos;) AS out_put;</span><br></pre></td></tr></table></figure>





<h5 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h5><h6 id="1、round-四舍五入"><a href="#1、round-四舍五入" class="headerlink" title="1、round     四舍五入"></a>1、round     四舍五入</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">SELECT ROUND(1.567,2);</span><br></pre></td></tr></table></figure>
<h6 id="2、ceil-向上取整-返回-gt-该参数的最小整数"><a href="#2、ceil-向上取整-返回-gt-该参数的最小整数" class="headerlink" title="2、ceil         向上取整,返回&gt;=该参数的最小整数"></a>2、ceil         向上取整,返回&gt;=该参数的最小整数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CEIL(-1.02);</span><br></pre></td></tr></table></figure>
<h6 id="3、floor-向下取整，返回-lt-该参数的最大整数"><a href="#3、floor-向下取整，返回-lt-该参数的最大整数" class="headerlink" title="3、floor     向下取整，返回&lt;=该参数的最大整数"></a>3、floor     向下取整，返回&lt;=该参数的最大整数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FLOOR(-9.99);</span><br></pre></td></tr></table></figure>
<h6 id="4、truncate-截断"><a href="#4、truncate-截断" class="headerlink" title="4、truncate 截断"></a>4、truncate 截断</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRUNCATE(1.69999,1);</span><br></pre></td></tr></table></figure>
<h6 id="5、mod取余"><a href="#5、mod取余" class="headerlink" title="5、mod取余"></a>5、mod取余</h6><p>mod(a,b) ： <code>a-a/b*b</code><br>mod(-10,-3):-10- (-10)/(-3)*（-3）=-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MOD(10,-3);</span><br><span class="line">SELECT 10%3;</span><br></pre></td></tr></table></figure>



<h5 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h5><p><img alt="1560432443390" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560432443390.png" class="lazyload"></p>
<h6 id="1、now-返回当前系统日期-时间"><a href="#1、now-返回当前系统日期-时间" class="headerlink" title="1、now 返回当前系统日期+时间"></a>1、now 返回当前系统日期+时间</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW(); #2019-06-13 21:18:30</span><br></pre></td></tr></table></figure>
<h6 id="2、curdate-返回当前系统日期，不包含时间"><a href="#2、curdate-返回当前系统日期，不包含时间" class="headerlink" title="2、curdate 返回当前系统日期，不包含时间"></a>2、curdate 返回当前系统日期，不包含时间</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE(); #2019-06-13</span><br></pre></td></tr></table></figure>
<h6 id="3、curtime-返回当前时间，不包含日期"><a href="#3、curtime-返回当前时间，不包含日期" class="headerlink" title="3、curtime 返回当前时间，不包含日期"></a>3、curtime 返回当前时间，不包含日期</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURTIME(); #21:18:30</span><br></pre></td></tr></table></figure>
<h6 id="4、可以获取指定的部分，年、月、日、小时、分钟、秒"><a href="#4、可以获取指定的部分，年、月、日、小时、分钟、秒" class="headerlink" title="4、可以获取指定的部分，年、月、日、小时、分钟、秒"></a>4、可以获取指定的部分，年、月、日、小时、分钟、秒</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">SELECT YEAR(&apos;1998-1-1&apos;) 年;</span><br><span class="line"></span><br><span class="line">SELECT  YEAR(hiredate) 年 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br></pre></td></tr></table></figure>
<h6 id="5、str-to-date-将字符通过指定的格式转换成日期"><a href="#5、str-to-date-将字符通过指定的格式转换成日期" class="headerlink" title="5、str_to_date 将字符通过指定的格式转换成日期"></a>5、str_to_date 将字符通过指定的格式转换成日期</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&apos;1998-3-2&apos;,&apos;%Y-%m-%d&apos;) AS out_put;</span><br><span class="line"></span><br><span class="line">#案例：查询入职日期为1992--4-3的员工信息</span><br><span class="line">SELECT * FROM employees WHERE hiredate = &apos;1992-4-3&apos;;</span><br><span class="line">#自定义格式化</span><br><span class="line">SELECT * FROM employees WHERE hiredate = STR_TO_DATE(&apos;4-3 1992&apos;,&apos;%c-%d %Y&apos;);</span><br></pre></td></tr></table></figure>
<h6 id="7、date-format-将日期转换成字符"><a href="#7、date-format-将日期转换成字符" class="headerlink" title="7、date_format 将日期转换成字符"></a>7、date_format 将日期转换成字符</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;) AS out_put;</span><br><span class="line"></span><br><span class="line">#案例：查询有奖金的员工名和入职日期(xx月/xx日 xx年)</span><br><span class="line">SELECT last_name,DATE_FORMAT(hiredate,&apos;%m月/%d日 %y年&apos;) 入职日期</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<h5 id="四、其他函数"><a href="#四、其他函数" class="headerlink" title="四、其他函数"></a>四、其他函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br><span class="line">SELECT DATABASE();</span><br><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure>



<h5 id="五、流程控制函数"><a href="#五、流程控制函数" class="headerlink" title="五、流程控制函数"></a>五、流程控制函数</h5><h6 id="1、if函数：-if-else-的效果"><a href="#1、if函数：-if-else-的效果" class="headerlink" title="1、if函数： if else 的效果"></a>1、if函数： if else 的效果</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(10&lt;5,&apos;大&apos;,&apos;小&apos;);</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct,IF(commission_pct IS NULL,&apos;没奖金，呵呵&apos;,&apos;有奖金，嘻嘻&apos;) 备注</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h6 id="2、case函数"><a href="#2、case函数" class="headerlink" title="2、case函数"></a>2、case函数</h6><p>【使用一】 switch case 的效果(适合等值判断)</p>
<p>java中写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量或表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>：语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:语句n;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>mysql中写法：（存储过程使用语句）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case [要判断的字段或表达式]</span><br><span class="line">when 常量1 then 要显示的值1或语句1;</span><br><span class="line">when 常量2 then 要显示的值2或语句2;</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>查询员工的工资，要求</p>
<p>部门号=30，显示的工资为1.1倍<br>部门号=40，显示的工资为1.2倍<br>部门号=50，显示的工资为1.3倍<br>其他部门，显示的工资为原工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">（CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END） AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<p>【使用二】类似于 多重if（适合区间判断）</p>
<p>mysql中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">。。。</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>案例：查询员工的工资的情况<br>如果工资&gt;20000,显示A级别<br>如果工资&gt;15000,显示B级别<br>如果工资&gt;10000，显示C级别<br>否则，显示D级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">WHEN salary&gt;20000 THEN &apos;A&apos;</span><br><span class="line">WHEN salary&gt;15000 THEN &apos;B&apos;</span><br><span class="line">WHEN salary&gt;10000 THEN &apos;C&apos;</span><br><span class="line">ELSE &apos;D&apos;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560435493790" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560435493790.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示系统时间(注：日期+时间)</span><br><span class="line">#SELECT NOW();</span><br><span class="line"></span><br><span class="line"># 查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</span><br><span class="line">select employee_id,last_name,salary,salary*12 as &apos;new salary&apos;</span><br><span class="line">from employees;</span><br><span class="line"></span><br><span class="line">#将员工的姓名按首字母排序，并写出姓名的长度（length）</span><br><span class="line">select last_name,LENGTH(last_name)</span><br><span class="line">from employees</span><br><span class="line">ORDER BY UPPER(SUBSTR(last_name,1,1));</span><br><span class="line"></span><br><span class="line"># 4、</span><br><span class="line">SELECT CONCAT(last_name , &apos; earns &apos; , salary , &apos; monthly but wants &apos;,salary*3)</span><br><span class="line">AS &apos;Dream Salary&apos;</span><br><span class="line">from employees</span><br><span class="line">WHERE salary=24000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5、</span><br><span class="line">SELECT last_name,job_id as job,</span><br><span class="line">CASE job_id</span><br><span class="line">when &apos;AD_PRES&apos; then &apos;A&apos;</span><br><span class="line">when &apos;ST_MAN&apos; then &apos;B&apos;</span><br><span class="line">when &apos;IT_PROG&apos; then &apos;C&apos;</span><br><span class="line">when &apos;SA_REP&apos; then &apos;D&apos;</span><br><span class="line">when &apos;ST_CLERK&apos; then &apos;E&apos;</span><br><span class="line">END</span><br><span class="line">AS grade</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<h3 id="5、分组函数"><a href="#5、分组函数" class="headerlink" title="5、分组函数"></a>5、分组函数</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>用作统计使用，又称为聚合函数或统计函数或组函数</p>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><p>sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>1、sum、avg一般用于处理数值型<br>   max、min、count可以处理任何类型<br>2、以上分组函数都忽略null值</p>
<p>3、可以和distinct搭配实现去重的运算</p>
<p>4、count函数的单独介绍<br>一般使用count(*)用作统计行数</p>
<p>5、和分组函数一同查询的字段要求是group by后的字段</p>
<h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><p>1、简单使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br><span class="line">SELECT AVG(salary) FROM employees;</span><br><span class="line">SELECT MIN(salary) FROM employees;</span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>2、支持的类型</p>
<p>sum、avg一般用于处理数值型，max、min、count可以处理任何类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(last_name) ,AVG(last_name) FROM employees;</span><br><span class="line">SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(last_name),MIN(last_name) FROM employees;</span><br><span class="line">SELECT MAX(hiredate),MIN(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line"># count()只计算不为null的个数</span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT COUNT(last_name) FROM employees;</span><br></pre></td></tr></table></figure>

<p>3、忽略null值</p>
<p>以下分组函数都忽略null值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT commission_pct FROM employees;</span><br></pre></td></tr></table></figure>

<p>4、和distinct搭配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure>



<p>5、count函数详细介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">#一般统计行数，针对所有字段，比如某一行有一个列为空，但是其他列不为空，也算</span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line"></span><br><span class="line">#count参数为常量值，相当于加了一列常量，依然统计行数</span><br><span class="line">SELECT COUNT(1) FROM employees;</span><br></pre></td></tr></table></figure>

<p><strong><em>效率：</em></strong><br><strong>MYISAM存储引擎下  ，<code>COUNT(*)</code>的效率高</strong><br><strong>INNODB存储引擎下，<code>COUNT(*)</code>和COUNT(1)的效率差不多，比COUNT(字段)要高一些</strong></p>
<p>6、和分组函数一同查询的字段有限制</p>
<p>和分组函数一同查询的字段要求是group by后的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#写法不对，AVG为一个值，employee_id为一个列</span><br><span class="line">SELECT AVG(salary),employee_id  FROM employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560478111853" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560478111853.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.查询公司员工工资的最大值，最小值，平均值，总和</span><br><span class="line"></span><br><span class="line">SELECT MAX(salary) 最大值,MIN(salary) 最小值,AVG(salary) 平均值,SUM(salary) 和</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）</span><br><span class="line"></span><br><span class="line">SELECT MAX(hiredate) 最大,MIN(hiredate) 最小,(MAX(hiredate)-MIN(hiredate))/1000/3600/24 DIFFRENCE</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) DIFFRENCE</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(&apos;1995-2-7&apos;,&apos;1995-2-6&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.查询部门编号为90的员工个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM employees WHERE department_id = 90;</span><br></pre></td></tr></table></figure>







<h3 id="6、分组查询"><a href="#6、分组查询" class="headerlink" title="6、分组查询"></a>6、分组查询</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【where 筛选条件】</span><br><span class="line">group by 分组的字段</span><br><span class="line">【order by 排序的字段】;</span><br></pre></td></tr></table></figure>



<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>1、和分组函数一同查询的字段必须是group by后出现的字段<br>2、筛选分为两类：分组前筛选和分组后筛选</p>
<table>
<thead>
<tr>
<th></th>
<th>数据源</th>
<th>位置</th>
<th>连接的关键字</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>group by前</td>
<td>where</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>group by后</td>
<td>having</td>
</tr>
</tbody></table>
<p>问题1：分组函数做筛选能不能放在where后面<br>答：不能</p>
<p>问题2：where——group by——having<br>一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率</p>
<p>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用</p>
<h4 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h4><h5 id="1、简单分组"><a href="#1、简单分组" class="headerlink" title="1、简单分组"></a>1、简单分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询每个工种的员工平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line">#案例2：查询每个位置的部门个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br></pre></td></tr></table></figure>

<h5 id="2、分组前的筛选"><a href="#2、分组前的筛选" class="headerlink" title="2、分组前的筛选"></a>2、分组前的筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询邮箱中包含a字符的 每个部门的最高工资</span><br><span class="line"></span><br><span class="line">SELECT MAX(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &apos;%a%&apos;</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的每个领导手下员工的平均工资</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure>



<h5 id="3、分组后筛选"><a href="#3、分组后筛选" class="headerlink" title="3、分组后筛选"></a>3、分组后筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询哪个部门的员工个数&gt;5</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING COUNT(*)&gt;5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line"></span><br><span class="line">SELECT job_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</span><br><span class="line"></span><br><span class="line">SELECT manager_id,MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id&gt;102</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary)&gt;5000;</span><br></pre></td></tr></table></figure>



<h5 id="4、添加排序"><a href="#4、添加排序" class="headerlink" title="4、添加排序"></a>4、添加排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</span><br><span class="line"></span><br><span class="line">SELECT job_id,MAX(salary) m</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING m&gt;6000</span><br><span class="line">ORDER BY m ;</span><br></pre></td></tr></table></figure>

<h5 id="5、按多个字段分组"><a href="#5、按多个字段分组" class="headerlink" title="5、按多个字段分组"></a>5、按多个字段分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个工种每个部门的最低工资,并按最低工资降序</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),job_id,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br><span class="line">ORDER BY MIN(salary) DESC;</span><br></pre></td></tr></table></figure>



<h3 id="7、连接查询"><a href="#7、连接查询" class="headerlink" title="7、连接查询"></a>7、连接查询</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p>
<p>笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行</p>
<p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p>
<h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><p>按年代分类</p>
<ul>
<li>sql92标准:仅仅支持内连接</li>
<li>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</li>
</ul>
<p><span style="color:red">mysql没有全外连接</span></p>
<p>按功能分类<br>内连接：<br>等值连接、非等值连接、自连接</p>
<p>外连接：<br>左外连接、右外连接、全外连接</p>
<p>交叉连接</p>
<h4 id="sql92标准使用"><a href="#sql92标准使用" class="headerlink" title="sql92标准使用"></a>sql92标准使用</h4><h5 id="1、等值连接"><a href="#1、等值连接" class="headerlink" title="1、等值连接"></a>1、等值连接</h5><blockquote>
<p>① 多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③ 多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询女神名和对应的男神名</span><br><span class="line">SELECT NAME,boyName </span><br><span class="line">FROM boys,beauty</span><br><span class="line">WHERE beauty.boyfriend_id= boys.id;</span><br><span class="line"></span><br><span class="line">#案例2：查询员工名和对应的部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees,departments</span><br><span class="line">WHERE employees.`department_id`=departments.`department_id`;</span><br></pre></td></tr></table></figure>



<h5 id="2、为表起别名"><a href="#2、为表起别名" class="headerlink" title="2、为表起别名"></a>2、为表起别名</h5><p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</p>
<p>两个表的顺序可以调换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工名、工种号、工种名</span><br><span class="line"></span><br><span class="line">SELECT e.last_name,e.job_id,j.job_title</span><br><span class="line">FROM employees  e,jobs j</span><br><span class="line">WHERE e.`job_id`=j.`job_id`;</span><br></pre></td></tr></table></figure>



<h5 id="3、加筛选"><a href="#3、加筛选" class="headerlink" title="3、加筛选"></a>3、加筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询有奖金的员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,commission_pct</span><br><span class="line"></span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`commission_pct` IS NOT NULL;</span><br><span class="line"></span><br><span class="line">#案例2：查询城市名中第二个字符为o的部门名和城市名</span><br><span class="line"></span><br><span class="line">SELECT department_name,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id` = l.`location_id`</span><br><span class="line">AND city LIKE &apos;_o%&apos;;</span><br></pre></td></tr></table></figure>



<h5 id="4、加分组"><a href="#4、加分组" class="headerlink" title="4、加分组"></a>4、加分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询每个城市的部门个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY city;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span><br><span class="line">SELECT department_name,d.`manager_id`,MIN(salary)</span><br><span class="line">FROM departments d,employees e</span><br><span class="line">WHERE d.`department_id`=e.`department_id`</span><br><span class="line">AND commission_pct IS NOT NULL</span><br><span class="line">GROUP BY department_name,d.`manager_id`</span><br></pre></td></tr></table></figure>

<h5 id="5、加排序"><a href="#5、加排序" class="headerlink" title="5、加排序"></a>5、加排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class="line"></span><br><span class="line">SELECT job_title,COUNT(*)</span><br><span class="line">FROM employees e,jobs j</span><br><span class="line">WHERE e.`job_id`=j.`job_id`</span><br><span class="line">GROUP BY job_title</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br></pre></td></tr></table></figure>

<h5 id="6、实现三表连接"><a href="#6、实现三表连接" class="headerlink" title="6、实现三表连接"></a>6、实现三表连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,departmen t_name,city</span><br><span class="line">FROM employees e,departments d,locations l</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND d.`location_id`=l.`location_id`</span><br><span class="line">AND city LIKE &apos;s%&apos;</span><br><span class="line"></span><br><span class="line">ORDER BY department_name DESC;</span><br></pre></td></tr></table></figure>



<h5 id="7、非等值连接"><a href="#7、非等值连接" class="headerlink" title="7、非等值连接"></a>7、非等值连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询员工的工资和工资级别</span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e,job_grades g</span><br><span class="line">WHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br></pre></td></tr></table></figure>



<h5 id="8、自连接"><a href="#8、自连接" class="headerlink" title="8、自连接"></a>8、自连接</h5><p>自己连接自己</p>
<p><img alt="1560498906057" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560498906057.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">案例：查询 员工名和上级的名称</span><br><span class="line"></span><br><span class="line">SELECT e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure>

<h4 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560499245000" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560499245000.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.显示所有员工的姓名，部门号和部门名称。</span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">SELECT last_name,d.department_id,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id` = d.`department_id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.查询90号部门员工的job_id和90号部门的location_id</span><br><span class="line"></span><br><span class="line">SELECT job_id,location_id</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`department_id`=90;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.	选择所有有奖金的员工的</span><br><span class="line">last_name , department_name , location_id , city</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT last_name , department_name , l.location_id , city</span><br><span class="line">FROM employees e,departments d,locations l</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">AND d.location_id=l.location_id</span><br><span class="line">AND e.commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.选择city在Toronto工作的员工的</span><br><span class="line">last_name , job_id , department_id , department_name </span><br><span class="line"></span><br><span class="line">SELECT last_name , job_id , d.department_id , department_name </span><br><span class="line">FROM employees e,departments d ,locations l</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">AND d.location_id=l.location_id</span><br><span class="line">AND city = &apos;Toronto&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.查询每个工种、每个部门的部门名、工种名和最低工资</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT department_name,job_title,MIN(salary) 最低工资</span><br><span class="line">FROM employees e,departments d,jobs j</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`job_id`=j.`job_id`</span><br><span class="line">GROUP BY department_name,job_title;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.查询每个国家下的部门个数大于2的国家编号</span><br><span class="line"></span><br><span class="line">SELECT country_id,COUNT(*) 部门个数</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY country_id</span><br><span class="line">HAVING 部门个数&gt;2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#7、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式</span><br><span class="line">employees	Emp#	manager	Mgr#</span><br><span class="line">kochhar		101	king	100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT e.last_name employees,e.employee_id &quot;Emp#&quot;,m.last_name manager,m.employee_id &quot;Mgr#&quot;</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.manager_id = m.employee_id</span><br><span class="line">AND e.last_name=&apos;kochhar&apos;;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="sql99标准使用"><a href="#sql99标准使用" class="headerlink" title="sql99标准使用"></a>sql99标准使用</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名 【连接类型】</span><br><span class="line">join 表2 别名 </span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组】</span><br><span class="line">【having 筛选条件】</span><br><span class="line">【order by 排序列表】</span><br></pre></td></tr></table></figure>
<h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><p>内连接：inner<br>外连接：左外:left 【outer】、右外：right 【outer】、全外：full【outer】<br>交叉连接：cross </p>
<h5 id="1、内连接使用"><a href="#1、内连接使用" class="headerlink" title="1、内连接使用"></a>1、内连接使用</h5><h6 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">inner join 表2 别名</span><br><span class="line">on 连接条件;</span><br></pre></td></tr></table></figure>

<h6 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h6><p>等值、非等值、自连接</p>
<h6 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h6><p>①添加排序、分组、筛选<br>②inner可以省略<br>③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p>
<h6 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1.查询员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM departments d</span><br><span class="line"> JOIN  employees e</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2.查询名字中包含e的员工名和工种名（添加筛选）</span><br><span class="line">SELECT last_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN jobs j</span><br><span class="line">ON e.`job_id`=  j.`job_id`</span><br><span class="line">WHERE e.`last_name` LIKE &apos;%e%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3. 查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</span><br><span class="line"></span><br><span class="line">#①查询每个城市的部门个数</span><br><span class="line">#②在①结果上筛选满足条件的</span><br><span class="line">SELECT city,COUNT(*) 部门个数</span><br><span class="line">FROM departments d</span><br><span class="line">INNER JOIN locations l</span><br><span class="line">ON d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY city</span><br><span class="line">HAVING COUNT(*)&gt;3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</span><br><span class="line"></span><br><span class="line">#①查询每个部门的员工个数</span><br><span class="line">SELECT COUNT(*),department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.`department_id`=d.`department_id`</span><br><span class="line">GROUP BY department_name</span><br><span class="line"></span><br><span class="line">#② 在①结果上筛选员工个数&gt;3的记录，并排序</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.`department_id`=d.`department_id`</span><br><span class="line">GROUP BY department_name</span><br><span class="line">HAVING COUNT(*)&gt;3</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br><span class="line"></span><br><span class="line">#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d ON e.`department_id`=d.`department_id`</span><br><span class="line">INNER JOIN jobs j ON e.`job_id` = j.`job_id`</span><br><span class="line"></span><br><span class="line">ORDER BY department_name DESC;</span><br></pre></td></tr></table></figure>





<h6 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的工资级别</span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e</span><br><span class="line"> JOIN job_grades g</span><br><span class="line"> ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #查询工资级别的个数&gt;20的个数，并且按工资级别降序</span><br><span class="line"> SELECT COUNT(*),grade_level</span><br><span class="line">FROM employees e</span><br><span class="line"> JOIN job_grades g</span><br><span class="line"> ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`</span><br><span class="line"> GROUP BY grade_level</span><br><span class="line"> HAVING COUNT(*)&gt;20</span><br><span class="line"> ORDER BY grade_level DESC;</span><br></pre></td></tr></table></figure>

<h6 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.`manager_id`= m.`employee_id`;</span><br><span class="line"></span><br><span class="line"> #查询姓名中包含字符k的员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.`manager_id`= m.`employee_id`</span><br><span class="line">WHERE e.`last_name` LIKE &apos;%k%&apos;;</span><br></pre></td></tr></table></figure>



<h5 id="2、外连接使用"><a href="#2、外连接使用" class="headerlink" title="2、外连接使用"></a>2、外连接使用</h5><p> 应用场景：用于查询一个表中有，另一个表没有的记录</p>
<p> 特点：<br> 1、外连接的查询结果为主表中的所有记录。如果从表中有和它匹配的，则显示匹配的值。如果从表中没有和它匹配的，则显示null</p>
<p>外连接查询结果=内连接结果+主表中有而从表没有的记录</p>
<p> 2、左外连接，left join左边的是主表<br>    右外连接，right join右边的是主表</p>
<p> 3、左外和右外交换两个表的顺序，可以实现同样的效果 </p>
<p> 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入：查询男朋友 不在男神表的的女神名</span><br><span class="line"> #左外连接</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM boys bo</span><br><span class="line"> LEFT OUTER JOIN beauty b</span><br><span class="line"> ON b.`boyfriend_id` = bo.`id`</span><br><span class="line"> WHERE b.`id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #案例1：查询哪个部门没有员工</span><br><span class="line"> #左外</span><br><span class="line"> SELECT d.*,e.employee_id</span><br><span class="line"> FROM departments d</span><br><span class="line"> LEFT OUTER JOIN employees e</span><br><span class="line"> ON d.`department_id` = e.`department_id`</span><br><span class="line"> WHERE e.`employee_id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #右外</span><br><span class="line">SELECT d.*,e.employee_id</span><br><span class="line"> FROM employees e</span><br><span class="line"> RIGHT OUTER JOIN departments d</span><br><span class="line"> ON d.`department_id` = e.`department_id`</span><br><span class="line"> WHERE e.`employee_id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #全外	mysql没有全外连接</span><br><span class="line"> USE girls;</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> FULL OUTER JOIN boys bo</span><br><span class="line"> ON b.`boyfriend_id` = bo.id;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> #交叉连接	笛卡尔乘积</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> CROSS JOIN boys bo;</span><br></pre></td></tr></table></figure>



<h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><p>图示内外连接</p>
<p><img alt="1560566711450" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566711450.png" class="lazyload"></p>
<p><img alt="1560566734011" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566734011.png" class="lazyload"></p>
<p><strong><em>sql92和sql99：</em></strong></p>
<p> 功能：sql99支持的较多<br> 可读性：sql99实现连接条件和筛选条件的分离，可读性较高</p>
<h4 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560577215475" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560577215475.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT b.id,b.name,bo.*</span><br><span class="line">FROM beauty b</span><br><span class="line">LEFT OUTER JOIN boys bo</span><br><span class="line">ON b.`boyfriend_id` = bo.`id`</span><br><span class="line">WHERE b.`id`&gt;3;</span><br><span class="line">#二、查询哪个城市没有部门</span><br><span class="line"></span><br><span class="line">SELECT city</span><br><span class="line">FROM departments d</span><br><span class="line">RIGHT OUTER JOIN locations l </span><br><span class="line">ON d.`location_id`=l.`location_id`</span><br><span class="line">WHERE  d.`department_id` IS NULL;</span><br><span class="line"></span><br><span class="line">#三、查询部门名为SAL或IT的员工信息</span><br><span class="line"></span><br><span class="line">SELECT e.*,d.department_name,d.`department_id`</span><br><span class="line">FROM departments  d</span><br><span class="line">LEFT JOIN employees e</span><br><span class="line">ON d.`department_id` = e.`department_id`</span><br><span class="line">WHERE d.`department_name` IN(&apos;SAL&apos;,&apos;IT&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM departments</span><br><span class="line">WHERE `department_name` IN(&apos;SAL&apos;,&apos;IT&apos;);</span><br></pre></td></tr></table></figure>



<h3 id="8、子查询"><a href="#8、子查询" class="headerlink" title="8、子查询"></a>8、子查询</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询</p>
<h4 id="分类-6"><a href="#分类-6" class="headerlink" title="分类"></a>分类</h4><p>按子查询出现的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select后面：</span><br><span class="line">		仅仅支持标量子查询</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">from后面：</span><br><span class="line">		支持表子查询</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">where或having后面：★</span><br><span class="line">		标量子查询（单行） √</span><br><span class="line">		列子查询  （多行） √</span><br><span class="line">		行子查询</span><br><span class="line"></span><br><span class="line">exists后面（相关子查询）</span><br><span class="line">		表子查询</span><br></pre></td></tr></table></figure>



<p>按结果集的行列数不同：<br>    标量子查询（结果集只有一行一列）<br>    列子查询（结果集只有一列多行）<br>    行子查询（结果集有一行多列）<br>    表子查询（结果集一般为多行多列）</p>
<h4 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h4><h5 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、标量子查询（单行子查询）</span><br><span class="line">2、列子查询（多行子查询）</span><br><span class="line"></span><br><span class="line">3、行子查询（多列多行）</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">①子查询放在小括号内</span><br><span class="line">②子查询一般放在条件的右侧</span><br><span class="line">③标量子查询，一般搭配着单行操作符使用</span><br><span class="line">&gt; &lt; &gt;= &lt;= = &lt;&gt;</span><br><span class="line"></span><br><span class="line">列子查询，一般搭配着多行操作符使用</span><br><span class="line">in、any/some、all</span><br><span class="line"></span><br><span class="line">④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</span><br></pre></td></tr></table></figure>



<p>1、标量子查询（一行一列一个值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：谁的工资比 Abel 高?</span><br><span class="line"></span><br><span class="line">#①查询Abel的工资</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &apos;Abel&apos;</span><br><span class="line"></span><br><span class="line">#②查询员工的信息，满足 salary&gt;①结果</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line"></span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = &apos;Abel&apos;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</span><br><span class="line"></span><br><span class="line">#①查询141号员工的job_id</span><br><span class="line">SELECT job_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id = 141</span><br><span class="line"></span><br><span class="line">#②查询143号员工的salary</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id = 143</span><br><span class="line"></span><br><span class="line">#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = (</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id = 141</span><br><span class="line">) AND salary&gt;(</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id = 143</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class="line"></span><br><span class="line">#①查询公司的 最低工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询last_name,job_id和salary，要求salary=①</span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例4：查询 最低工资大于50号部门 的 最低工资的部门id和其最低工资</span><br><span class="line"></span><br><span class="line">#①查询50号部门的最低工资</span><br><span class="line">SELECT  MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 50</span><br><span class="line"></span><br><span class="line">#②查询每个部门的最低工资</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#③ 在②基础上筛选，满足min(salary)&gt;①</span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary)&gt;(</span><br><span class="line">	SELECT  MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE department_id = 50</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>2、列子查询（多行子查询）★</p>
<p><img alt="1560585303384" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560585303384.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：返回location_id是1400或1700的部门中的所有员工姓名</span><br><span class="line"></span><br><span class="line">#①查询location_id是1400或1700的部门编号</span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments</span><br><span class="line">WHERE location_id IN(1400,1700)</span><br><span class="line"></span><br><span class="line">#②查询员工姓名，要求部门号是①列表中的某一个</span><br><span class="line"></span><br><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id  IN(</span><br><span class="line">#WHERE department_id = ANY(</span><br><span class="line">#WHERE department_id &lt;&gt; ALL(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">	FROM departments</span><br><span class="line">	WHERE location_id IN(1400,1700)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">#①查询job_id为‘IT_PROG’部门任一工资</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ANY(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ALL(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MIN( salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br></pre></td></tr></table></figure>

<p>3、行子查询（结果集一行多列或多行多列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工编号最小并且工资最高的员工信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM employees</span><br><span class="line">WHERE (employee_id,salary)=(</span><br><span class="line">	SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#①查询最小的员工编号</span><br><span class="line">SELECT MIN(employee_id)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询最高工资</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#③查询员工信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id=(</span><br><span class="line">	SELECT MIN(employee_id)</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">)AND salary=(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h5 id="select后面"><a href="#select后面" class="headerlink" title="select后面"></a>select后面</h5><p>仅仅支持标量子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的员工个数</span><br><span class="line"></span><br><span class="line">#相当于主查询每查一行都会获取d.`department_id`的常量值，然后利用这个常量值去子查询里面统计人数</span><br><span class="line">SELECT d.*,(</span><br><span class="line"></span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.department_id = d.`department_id`</span><br><span class="line"> ) 个数</span><br><span class="line"> FROM departments d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #案例2：查询员工号=102的部门名</span><br><span class="line"></span><br><span class="line">SELECT (</span><br><span class="line">	SELECT department_name,e.department_id</span><br><span class="line">	FROM departments d</span><br><span class="line">	INNER JOIN employees e</span><br><span class="line">	ON d.department_id=e.department_id</span><br><span class="line">	WHERE e.employee_id=102</span><br><span class="line">	</span><br><span class="line">) 部门名;</span><br></pre></td></tr></table></figure>





<h5 id="from后面"><a href="#from后面" class="headerlink" title="from后面"></a>from后面</h5><p>将子查询结果充当一张表，要求必须起别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的平均工资的工资等级</span><br><span class="line">#①查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">SELECT * FROM job_grades;</span><br><span class="line"></span><br><span class="line">#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line"></span><br><span class="line">SELECT  ag_dep.*,g.`grade_level`</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line">INNER JOIN job_grades g</span><br><span class="line">ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</span><br></pre></td></tr></table></figure>

<h5 id="exists后面（相关子查询）"><a href="#exists后面（相关子查询）" class="headerlink" title="exists后面（相关子查询）"></a>exists后面（相关子查询）</h5><p>语法：<br>exists(完整的查询语句)<br>结果：1或0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);</span><br><span class="line"></span><br><span class="line">#案例1：查询有员工的部门名</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.`department_id` IN(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line"></span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE d.`department_id`=e.`department_id`</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：查询没有女朋友的男神信息</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line"></span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE bo.id NOT IN(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty b</span><br><span class="line">	WHERE bo.`id`=b.`boyfriend_id`</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560608516119" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560608516119.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	查询和Zlotkey相同部门的员工姓名和工资</span><br><span class="line"></span><br><span class="line">#①查询Zlotkey的部门</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &apos;Zlotkey&apos;</span><br><span class="line"></span><br><span class="line">#②查询部门号=①的姓名和工资</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = (</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = &apos;Zlotkey&apos;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#2.查询工资比公司平均工资高的员工的员工号，姓名和工资。</span><br><span class="line"></span><br><span class="line">#①查询平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询工资&gt;①的员工号，姓名和工资。</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line"></span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资</span><br><span class="line">#①查询各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#②连接①结果集和employees表，进行筛选</span><br><span class="line">SELECT employee_id,last_name,salary,e.department_id</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">) ag_dep</span><br><span class="line">ON e.department_id = ag_dep.department_id</span><br><span class="line">WHERE salary&gt;ag_dep.ag ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.	查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</span><br><span class="line">#①查询姓名中包含字母u的员工的部门</span><br><span class="line"></span><br><span class="line">SELECT  DISTINCT department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%u%&apos;</span><br><span class="line"></span><br><span class="line">#②查询部门号=①中的任意一个的员工号和姓名</span><br><span class="line">SELECT last_name,employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN(</span><br><span class="line">	SELECT  DISTINCT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name LIKE &apos;%u%&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5. 查询在部门的location_id为1700的部门工作的员工的员工号</span><br><span class="line"></span><br><span class="line">#①查询location_id为1700的部门</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments </span><br><span class="line">WHERE location_id  = 1700</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②查询部门号=①中的任意一个的员工号</span><br><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id =ANY(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">	FROM departments </span><br><span class="line">	WHERE location_id  = 1700</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#6.查询管理者是King的员工姓名和工资</span><br><span class="line"></span><br><span class="line">#①查询姓名为king的员工编号</span><br><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name  = &apos;K_ing&apos;</span><br><span class="line"></span><br><span class="line">#②查询哪个员工的manager_id = ①</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id IN(</span><br><span class="line">	SELECT employee_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name  = &apos;K_ing&apos;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#7.查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#①查询最高工资</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询工资=①的姓.名</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(first_name,last_name) &quot;姓.名&quot;</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>经典案例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 查询工资最低的员工信息: last_name, salary</span><br><span class="line"></span><br><span class="line">#①查询最低的工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询last_name,salary，要求salary=①</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 2. 查询平均工资最低的部门信息</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">#②查询①结果上的最低平均工资</span><br><span class="line">SELECT MIN(ag)</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line"></span><br><span class="line">#③查询哪个部门的平均工资=②</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)=(</span><br><span class="line">	SELECT MIN(ag)</span><br><span class="line">	FROM (</span><br><span class="line">		SELECT AVG(salary) ag,department_id</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">	) ag_dep</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#④查询部门信息</span><br><span class="line"></span><br><span class="line">SELECT d.*</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.`department_id`=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING AVG(salary)=(</span><br><span class="line">		SELECT MIN(ag)</span><br><span class="line">		FROM (</span><br><span class="line">			SELECT AVG(salary) ag,department_id</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">		) ag_dep</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#②求出最低平均工资的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line"></span><br><span class="line">#③查询部门信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments</span><br><span class="line">WHERE department_id=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY AVG(salary) </span><br><span class="line">	LIMIT 1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3. 查询平均工资最低的部门信息和该部门的平均工资</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">#②求出最低平均工资的部门编号</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line">#③查询部门信息</span><br><span class="line">SELECT d.*,ag</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY AVG(salary) </span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line">) ag_dep</span><br><span class="line">ON d.`department_id`=ag_dep.department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4. 查询平均工资最高的 job 信息</span><br><span class="line">#①查询最高的job的平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id</span><br><span class="line">ORDER BY AVG(salary) DESC</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line">#②查询job信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM jobs</span><br><span class="line">WHERE job_id=(</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY job_id</span><br><span class="line">	ORDER BY AVG(salary) DESC</span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"># 5. 查询平均工资高于公司平均工资的部门有哪些?</span><br><span class="line"></span><br><span class="line">#①查询平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#③筛选②结果集，满足平均工资&gt;①</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)&gt;(</span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 6. 查询出公司中所有 manager 的详细信息.</span><br><span class="line">#①查询所有manager的员工编号</span><br><span class="line">SELECT DISTINCT manager_id</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询详细信息，满足employee_id=①</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id =ANY(</span><br><span class="line">	SELECT DISTINCT manager_id</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少</span><br><span class="line"></span><br><span class="line">#①查询各部门的最高工资中最低的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY MAX(salary)</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②查询①结果的那个部门的最低工资</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary) ,department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY MAX(salary)</span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"># 8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</span><br><span class="line">#①查询平均工资最高的部门编号</span><br><span class="line">SELECT </span><br><span class="line">    department_id </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">ORDER BY AVG(salary) DESC </span><br><span class="line">LIMIT 1 </span><br><span class="line"></span><br><span class="line">#②将employees和departments连接查询，筛选条件是①</span><br><span class="line">    SELECT </span><br><span class="line">        last_name, d.department_id, email, salary </span><br><span class="line">    FROM</span><br><span class="line">        employees e </span><br><span class="line">        INNER JOIN departments d </span><br><span class="line">            ON d.manager_id = e.employee_id </span><br><span class="line">    WHERE d.department_id = </span><br><span class="line">        (SELECT </span><br><span class="line">            department_id </span><br><span class="line">        FROM</span><br><span class="line">            employees </span><br><span class="line">        GROUP BY department_id </span><br><span class="line">        ORDER BY AVG(salary) DESC </span><br><span class="line">        LIMIT 1) ;</span><br></pre></td></tr></table></figure>





<h3 id="9、分页查询"><a href="#9、分页查询" class="headerlink" title="9、分页查询"></a>9、分页查询</h3><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
<h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【join type join 表2】</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by 排序的字段】</span><br><span class="line">limit 【offset,】size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset要显示条目的起始索引（起始索引从0开始）</span><br><span class="line">size 要显示的条目个数</span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>①limit语句放在查询语句的最后<br>②公式<br>要显示的页数 page，每页的条目数size</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">limit (page-1)*size,size;</span><br></pre></td></tr></table></figure>



<h4 id="使用-7"><a href="#使用-7" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询前五条员工信息</span><br><span class="line">SELECT * FROM  employees LIMIT 0,5;</span><br><span class="line">SELECT * FROM  employees LIMIT 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询第11条——第25条</span><br><span class="line">SELECT * FROM  employees LIMIT 10,15;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：有奖金的员工信息，并且工资较高的前10名显示出来</span><br><span class="line">SELECT </span><br><span class="line">    * </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 ;</span><br></pre></td></tr></table></figure>



<h3 id="10、查询大练习"><a href="#10、查询大练习" class="headerlink" title="10、查询大练习"></a>10、查询大练习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、查询每个专业的学生人数</span><br><span class="line">SELECT majorid,COUNT(*)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY majorid;</span><br><span class="line"></span><br><span class="line">#二、查询参加考试的学生中，每个学生的平均分、最高分</span><br><span class="line">SELECT AVG(score),MAX(score),studentno</span><br><span class="line">FROM result</span><br><span class="line">GROUP BY studentno;</span><br><span class="line"></span><br><span class="line">#三、查询姓张的每个学生的最低分大于60的学号、姓名</span><br><span class="line">SELECT s.studentno,s.`studentname`,MIN(score)</span><br><span class="line">FROM student s</span><br><span class="line">JOIN result r</span><br><span class="line">ON s.`studentno`=r.`studentno`</span><br><span class="line">WHERE s.`studentname` LIKE &apos;张%&apos;</span><br><span class="line">GROUP BY s.`studentno`</span><br><span class="line">HAVING MIN(score)&gt;60;</span><br><span class="line">#四、查询每个专业生日在“1988-1-1”后的学生姓名、专业名称</span><br><span class="line"></span><br><span class="line">SELECT m.`majorname`,s.`studentname`</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m</span><br><span class="line">ON m.`majorid`=s.`majorid`</span><br><span class="line">WHERE DATEDIFF(borndate,&apos;1988-1-1&apos;)&gt;0</span><br><span class="line">GROUP BY m.`majorid`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#五、查询每个专业的男生人数和女生人数分别是多少</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),sex,majorid</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY sex,majorid;</span><br><span class="line">#六、查询专业和张翠山一样的学生的最低分</span><br><span class="line">#①查询张翠山的专业编号</span><br><span class="line">SELECT majorid</span><br><span class="line">FROM student</span><br><span class="line">WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">#②查询编号=①的所有学生编号</span><br><span class="line">SELECT studentno</span><br><span class="line">FROM student</span><br><span class="line">WHERE majorid=(</span><br><span class="line">	SELECT majorid</span><br><span class="line">	FROM student</span><br><span class="line">	WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">#②查询最低分</span><br><span class="line">SELECT MIN(score)</span><br><span class="line">FROM result</span><br><span class="line">WHERE studentno IN(</span><br><span class="line"></span><br><span class="line">	SELECT studentno</span><br><span class="line">	FROM student</span><br><span class="line">	WHERE majorid=(</span><br><span class="line">		SELECT majorid</span><br><span class="line">		FROM student</span><br><span class="line">		WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#七、查询大于60分的学生的姓名、密码、专业名</span><br><span class="line"></span><br><span class="line">SELECT studentname,loginpwd,majorname</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m ON s.majorid=  m.majorid</span><br><span class="line">JOIN result r ON s.studentno=r.studentno</span><br><span class="line">WHERE r.score&gt;60;</span><br><span class="line">#八、按邮箱位数分组，查询每组的学生个数</span><br><span class="line">SELECT COUNT(*),LENGTH(email)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY LENGTH(email);</span><br><span class="line">#九、查询学生名、专业名、分数</span><br><span class="line"></span><br><span class="line">SELECT studentname,score,majorname</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m ON s.majorid=  m.majorid</span><br><span class="line">LEFT JOIN result r ON s.studentno=r.studentno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#十、查询哪个专业没有学生，分别用左连接和右连接实现</span><br><span class="line">#左</span><br><span class="line">SELECT m.`majorid`,m.`majorname`,s.`studentno`</span><br><span class="line">FROM major m</span><br><span class="line">LEFT JOIN student s ON m.`majorid` = s.`majorid`</span><br><span class="line">WHERE s.`studentno` IS NULL;</span><br><span class="line"></span><br><span class="line">#右</span><br><span class="line">SELECT m.`majorid`,m.`majorname`,s.`studentno`</span><br><span class="line">FROM student s</span><br><span class="line">RIGHT JOIN  major m ON m.`majorid` = s.`majorid`</span><br><span class="line">WHERE s.`studentno` IS NULL;</span><br><span class="line">#十一、查询没有成绩的学生人数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM student s</span><br><span class="line">LEFT JOIN result r ON s.`studentno` = r.`studentno`</span><br><span class="line">WHERE r.`id` IS NULL</span><br></pre></td></tr></table></figure>

<h3 id="11、union联合查询"><a href="#11、union联合查询" class="headerlink" title="11、union联合查询"></a>11、union联合查询</h3><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>
<h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p>
<h4 id="特点：★"><a href="#特点：★" class="headerlink" title="特点：★"></a>特点：★</h4><p>1、要求多条查询语句的查询列数是一致的！<br>2、<strong>要求多条查询语句的查询的每一列的类型和顺序最好一致</strong><br>3、union关键字默认去重，如果使用union all 可以包含重复项</p>
<h4 id="使用-8"><a href="#使用-8" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees WHERE email LIKE &apos;%a%&apos; OR department_id&gt;90;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees  WHERE email LIKE &apos;%a%&apos;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees  WHERE department_id&gt;90;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息</span><br><span class="line">SELECT id,cname FROM t_ca WHERE csex=&apos;男&apos;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT t_id,tname FROM t_ua WHERE tGender=&apos;male&apos;;</span><br></pre></td></tr></table></figure>







<h2 id="4、DML语言学习"><a href="#4、DML语言学习" class="headerlink" title="4、DML语言学习"></a>4、DML语言学习</h2><blockquote>
<p>Data Manipulate Language —— 数据操作语言</p>
<p>insert 、update、delete</p>
</blockquote>
<h3 id="1、插入语句"><a href="#1、插入语句" class="headerlink" title="1、插入语句"></a>1、插入语句</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名(列名,...) </span><br><span class="line">values(值1,...);</span><br></pre></td></tr></table></figure>

<h5 id="使用-9"><a href="#使用-9" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM beauty;</span><br><span class="line">#1.插入的值的类型要与列的类型一致或兼容</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&apos;唐艺昕&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br><span class="line"></span><br><span class="line">#2.为空的列可以赋值null，也可以不对其列赋值</span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&apos;唐艺昕&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,sex,phone)</span><br><span class="line">VALUES(15,&apos;娜扎&apos;,&apos;女&apos;,&apos;1388888888&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.列的顺序可以调换</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&apos;蒋欣&apos;,&apos;女&apos;,16,&apos;110&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.列数和值的个数必须一致</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&apos;关晓彤&apos;,&apos;女&apos;,17,&apos;110&apos;);</span><br><span class="line"></span><br><span class="line">#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致   </span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(18,&apos;张飞&apos;,&apos;男&apos;,NULL,&apos;119&apos;,NULL,NULL);</span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">set 列名=值,列名=值,...</span><br></pre></td></tr></table></figure>

<h5 id="使用-10"><a href="#使用-10" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">SET id=19,NAME=&apos;刘涛&apos;,phone=&apos;999&apos;;</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1、方式一支持插入多行,方式二不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(23,&apos;唐艺昕1&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2)</span><br><span class="line">,(24,&apos;唐艺昕2&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2)</span><br><span class="line">,(25,&apos;唐艺昕3&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br></pre></td></tr></table></figure>



<p>2、方式一支持子查询，方式二不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT 26,&apos;宋茜&apos;,&apos;11809866&apos;;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">(</span><br><span class="line">    SELECT id,boyname,&apos;1234567&apos;</span><br><span class="line">	FROM boys WHERE id&lt;3;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>方式一使用较多</p>
<h3 id="2、修改语句"><a href="#2、修改语句" class="headerlink" title="2、修改语句"></a>2、修改语句</h3><h4 id="1、修改单表的记录★"><a href="#1、修改单表的记录★" class="headerlink" title="1、修改单表的记录★"></a>1、修改单表的记录★</h4><h5 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 列 = 新值,列 = 新值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="使用-11"><a href="#使用-11" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.修改单表的记录</span><br><span class="line">#案例1：修改beauty表中姓唐的女神的电话为13899888899</span><br><span class="line"></span><br><span class="line">UPDATE beauty SET phone = &apos;13899888899&apos;</span><br><span class="line">WHERE NAME LIKE &apos;唐%&apos;;</span><br><span class="line"></span><br><span class="line">#案例2：修改boys表中id好为2的名称为张飞，魅力值 10</span><br><span class="line">UPDATE boys SET boyname=&apos;张飞&apos;,usercp=10</span><br><span class="line">WHERE id=2;</span><br></pre></td></tr></table></figure>



<h4 id="2、修改多表的记录【补充】"><a href="#2、修改多表的记录【补充】" class="headerlink" title="2、修改多表的记录【补充】"></a>2、修改多表的记录【补充】</h4><h5 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql92语法：</span><br><span class="line">update 表1 别名,表2 别名</span><br><span class="line">set 列=值,...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 列=值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="使用-12"><a href="#使用-12" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例 1：修改张无忌的女朋友的手机号为114</span><br><span class="line"></span><br><span class="line">UPDATE boys bo</span><br><span class="line">INNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`</span><br><span class="line">SET b.`phone`=&apos;114&apos;,bo.`userCP`=1000</span><br><span class="line">WHERE bo.`boyName`=&apos;张无忌&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：修改没有男朋友的女神的男朋友编号都为2号</span><br><span class="line"></span><br><span class="line">UPDATE boys bo</span><br><span class="line">RIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`</span><br><span class="line">SET b.`boyfriend_id`=2</span><br><span class="line">WHERE bo.`id` IS NULL;</span><br><span class="line"></span><br><span class="line">SELECT * FROM boys;</span><br></pre></td></tr></table></figure>



<h3 id="3、删除语句"><a href="#3、删除语句" class="headerlink" title="3、删除语句"></a>3、删除语句</h3><h4 id="方式一：delete"><a href="#方式一：delete" class="headerlink" title="方式一：delete"></a>方式一：delete</h4><h5 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h5><p>1、单表的删除【★】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 筛选条件;</span><br></pre></td></tr></table></figure>

<p>2、多表的删除【补充】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql92语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line"></span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>
<h5 id="使用-13"><a href="#使用-13" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">======================单表删除==================</span><br><span class="line">#案例：删除手机号以9结尾的女神信息</span><br><span class="line"></span><br><span class="line">DELETE FROM beauty WHERE phone LIKE &apos;%9&apos;;</span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：删除张无忌的女朋友的信息</span><br><span class="line"></span><br><span class="line">DELETE b</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`</span><br><span class="line">WHERE bo.`boyName`=&apos;张无忌&apos;;</span><br><span class="line"></span><br><span class="line">======================多表删除==================</span><br><span class="line">#案例：删除黄晓明的信息以及他女朋友的信息</span><br><span class="line">DELETE b,bo</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`</span><br><span class="line">WHERE bo.`boyName`=&apos;黄晓明&apos;;</span><br></pre></td></tr></table></figure>



<h4 id="方式二：truncate"><a href="#方式二：truncate" class="headerlink" title="方式二：truncate"></a>方式二：truncate</h4><p>清除表所有数据</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><p>1、delete 可以加where 条件，truncate不能加</p>
<p>2、truncate删除，效率高一丢丢</p>
<p><strong>3、假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</strong></p>
<p>4、truncate删除没有返回值，delete删除有返回值</p>
<p>5、truncate删除不能回滚，delete删除可以回滚.</p>
<h3 id="4、练习"><a href="#4、练习" class="headerlink" title="4、练习"></a>4、练习</h3><p><img alt="1560740250627" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560740250627.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	运行以下脚本创建表my_employees</span><br><span class="line"></span><br><span class="line">USE myemployees;</span><br><span class="line">CREATE TABLE my_employees(</span><br><span class="line">	Id INT(10),</span><br><span class="line">	First_name VARCHAR(10),</span><br><span class="line">	Last_name VARCHAR(10),</span><br><span class="line">	Userid VARCHAR(10),</span><br><span class="line">	Salary DOUBLE(10,2)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE users(</span><br><span class="line">	id INT,</span><br><span class="line">	userid VARCHAR(10),</span><br><span class="line">	department_id INT</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#2.	显示表my_employees的结构</span><br><span class="line">DESC my_employees;</span><br><span class="line"></span><br><span class="line">#3.	向my_employees表中插入下列数据</span><br><span class="line">ID	FIRST_NAME	LAST_NAME	USERID	SALARY</span><br><span class="line">1	patel		Ralph		Rpatel	895</span><br><span class="line">2	Dancs		Betty		Bdancs	860</span><br><span class="line">3	Biri		Ben		Bbiri	1100</span><br><span class="line">4	Newman		Chad		Cnewman	750</span><br><span class="line">5	Ropeburn	Audrey		Aropebur	1550</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">VALUES(1,&apos;patel&apos;,&apos;Ralph&apos;,&apos;Rpatel&apos;,895),</span><br><span class="line">(2,&apos;Dancs&apos;,&apos;Betty&apos;,&apos;Bdancs&apos;,860),</span><br><span class="line">(3,&apos;Biri&apos;,&apos;Ben&apos;,&apos;Bbiri&apos;,1100),</span><br><span class="line">(4,&apos;Newman&apos;,&apos;Chad&apos;,&apos;Cnewman&apos;,750),</span><br><span class="line">(5,&apos;Ropeburn&apos;,&apos;Audrey&apos;,&apos;Aropebur&apos;,1550);</span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">SELECT 1,&apos;patel&apos;,&apos;Ralph&apos;,&apos;Rpatel&apos;,895 UNION</span><br><span class="line">SELECT 2,&apos;Dancs&apos;,&apos;Betty&apos;,&apos;Bdancs&apos;,860 UNION</span><br><span class="line">SELECT 3,&apos;Biri&apos;,&apos;Ben&apos;,&apos;Bbiri&apos;,1100 UNION</span><br><span class="line">SELECT 4,&apos;Newman&apos;,&apos;Chad&apos;,&apos;Cnewman&apos;,750 UNION</span><br><span class="line">SELECT 5,&apos;Ropeburn&apos;,&apos;Audrey&apos;,&apos;Aropebur&apos;,1550;</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line">#4.	 向users表中插入数据</span><br><span class="line">1	Rpatel	10</span><br><span class="line">2	Bdancs	10</span><br><span class="line">3	Bbiri	20</span><br><span class="line">4	Cnewman	30</span><br><span class="line">5	Aropebur	40</span><br><span class="line"></span><br><span class="line">INSERT INTO users</span><br><span class="line">VALUES(1,&apos;Rpatel&apos;,10),</span><br><span class="line">(2,&apos;Bdancs&apos;,10),</span><br><span class="line">(3,&apos;Bbiri&apos;,20);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.将3号员工的last_name修改为“drelxer”</span><br><span class="line">UPDATE my_employees SET last_name=&apos;drelxer&apos; WHERE id = 3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.将所有工资少于900的员工的工资修改为1000</span><br><span class="line">UPDATE my_employees SET salary=1000 WHERE salary&lt;900;</span><br><span class="line"></span><br><span class="line">#7.将userid 为Bbiri的user表和my_employees表的记录全部删除</span><br><span class="line"></span><br><span class="line">DELETE u,e</span><br><span class="line">FROM users u</span><br><span class="line">JOIN my_employees e ON u.`userid`=e.`Userid`</span><br><span class="line">WHERE u.`userid`=&apos;Bbiri&apos;;</span><br><span class="line"></span><br><span class="line">#8.删除所有数据</span><br><span class="line"></span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line">DELETE FROM users;</span><br><span class="line">#9.检查所作的修正</span><br><span class="line"></span><br><span class="line">SELECT * FROM my_employees;</span><br><span class="line">SELECT * FROM users;</span><br><span class="line"></span><br><span class="line">#10.清空表my_employees</span><br><span class="line">TRUNCATE TABLE my_employees;</span><br></pre></td></tr></table></figure>











<h2 id="5、DDL语言学习"><a href="#5、DDL语言学习" class="headerlink" title="5、DDL语言学习"></a>5、DDL语言学习</h2><blockquote>
<p>Data Define Languge —— 数据定义语言</p>
</blockquote>
<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>一、库的管理<br>创建、修改、删除<br>二、表的管理<br>创建、修改、删除</p>
<p>创建： create<br>修改： alter<br>删除： drop</p>
<p>数据库的位置</p>
<p><img alt="1560924243469" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560924243469.png" class="lazyload"></p>
<h3 id="2、库的管理"><a href="#2、库的管理" class="headerlink" title="2、库的管理"></a>2、库的管理</h3><h4 id="1、库的创建"><a href="#1、库的创建" class="headerlink" title="1、库的创建"></a>1、库的创建</h4><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database  [if not exists]库名;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<p>创建库Books</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS books ;</span><br></pre></td></tr></table></figure>



<h4 id="2、库的修改"><a href="#2、库的修改" class="headerlink" title="2、库的修改"></a>2、库的修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME DATABASE books TO 新库名;	#废弃</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<p>更改库的字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE books CHARACTER SET gbk;</span><br></pre></td></tr></table></figure>



<h4 id="3、库的删除"><a href="#3、库的删除" class="headerlink" title="3、库的删除"></a>3、库的删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS books;</span><br></pre></td></tr></table></figure>



<h3 id="3、表的管理"><a href="#3、表的管理" class="headerlink" title="3、表的管理"></a>3、表的管理</h3><h4 id="1、表的创建"><a href="#1、表的创建" class="headerlink" title="1、表的创建"></a>1、表的创建</h4><h5 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">create [if not exist] table 表名(</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	...</span><br><span class="line">	列名 列的类型【(长度) 约束】</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="使用-14"><a href="#使用-14" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：创建表Book</span><br><span class="line"></span><br><span class="line">CREATE TABLE book(</span><br><span class="line">	id INT,#编号</span><br><span class="line">	bName VARCHAR(20),#图书名</span><br><span class="line">	price DOUBLE,#价格</span><br><span class="line">	authorId  INT,#作者编号</span><br><span class="line">	publishDate DATETIME#出版日期</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看表结构</span><br><span class="line">DESC book;</span><br><span class="line"></span><br><span class="line">#案例：创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author(</span><br><span class="line">	id INT,</span><br><span class="line">	au_name VARCHAR(20),</span><br><span class="line">	nation VARCHAR(10)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">#查看表结构</span><br><span class="line">DESC author;</span><br></pre></td></tr></table></figure>





<h4 id="2、表的修改"><a href="#2、表的修改" class="headerlink" title="2、表的修改"></a>2、表的修改</h4><h5 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</span><br></pre></td></tr></table></figure>

<h5 id="使用-15"><a href="#使用-15" class="headerlink" title="使用"></a>使用</h5><p>1、修改列名<code>CHANGE</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE [表名] CHANGE COLUMN [原列名] [新列名] [列名类型];</span><br><span class="line"></span><br><span class="line">ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</span><br></pre></td></tr></table></figure>

<p>2、修改列的类型或约束<code>MODIFY</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</span><br></pre></td></tr></table></figure>
<p>3、添加新列<code>ADD</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE author ADD COLUMN annual DOUBLE;</span><br></pre></td></tr></table></figure>
<p>4、删除列<code>DROP</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book_author DROP COLUMN  annual;</span><br></pre></td></tr></table></figure>

<p>5、修改表名<code>RENAME</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE author RENAME TO book_author;</span><br><span class="line"></span><br><span class="line">DESC book;</span><br></pre></td></tr></table></figure>



<h4 id="3、表的删除"><a href="#3、表的删除" class="headerlink" title="3、表的删除"></a>3、表的删除</h4><h5 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS 表明;</span><br></pre></td></tr></table></figure>



<h5 id="使用-16"><a href="#使用-16" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS book_author;</span><br><span class="line"></span><br><span class="line">#查看所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">#通用的写法：</span><br><span class="line"># 删库名 + 创建库名 </span><br><span class="line">DROP DATABASE IF EXISTS 旧库名;</span><br><span class="line">CREATE DATABASE 新库名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS 旧表名;</span><br><span class="line">CREATE TABLE  表名();</span><br></pre></td></tr></table></figure>



<h4 id="4、表的复制"><a href="#4、表的复制" class="headerlink" title="4、表的复制"></a>4、表的复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO author VALUES</span><br><span class="line">(1,&apos;村上春树&apos;,&apos;日本&apos;),</span><br><span class="line">(2,&apos;莫言&apos;,&apos;中国&apos;),</span><br><span class="line">(3,&apos;冯唐&apos;,&apos;中国&apos;),</span><br><span class="line">(4,&apos;金庸&apos;,&apos;中国&apos;);</span><br></pre></td></tr></table></figure>

<p>1、仅仅复制表的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy LIKE author;</span><br></pre></td></tr></table></figure>
<p>2、复制表的结构+数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT * FROM author;</span><br></pre></td></tr></table></figure>
<p>3、只复制部分数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy3</span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author </span><br><span class="line">WHERE nation=&apos;中国&apos;;</span><br></pre></td></tr></table></figure>

<p>4、仅仅复制某些字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy4 </span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author</span><br><span class="line">WHERE 0;	#让where的条件置为0</span><br></pre></td></tr></table></figure>

<h3 id="4、练习-1"><a href="#4、练习-1" class="headerlink" title="4、练习"></a>4、练习</h3><p><img alt="1560995258950" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560995258950.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	创建表dept1</span><br><span class="line">NAME	NULL?	TYPE</span><br><span class="line">id		INT(7)</span><br><span class="line">NAME		VARCHAR(25)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USE test;</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept1(</span><br><span class="line">	id INT(7),</span><br><span class="line">	NAME VARCHAR(25)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#2.	将表departments中的数据插入新表dept2中</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept2</span><br><span class="line">SELECT department_id,department_name</span><br><span class="line">FROM myemployees.departments;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.	创建表emp5</span><br><span class="line">NAME	NULL?	TYPE</span><br><span class="line">id		INT(7)</span><br><span class="line">First_name	VARCHAR (25)</span><br><span class="line">Last_name	VARCHAR(25)</span><br><span class="line">Dept_id		INT(7)</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp5(</span><br><span class="line">id INT(7),</span><br><span class="line">first_name VARCHAR(25),</span><br><span class="line">last_name VARCHAR(25),</span><br><span class="line">dept_id INT(7)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.	将列Last_name的长度增加到50</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);</span><br><span class="line">#5.	根据表employees创建employees2</span><br><span class="line"></span><br><span class="line">CREATE TABLE employees2 LIKE myemployees.employees;</span><br><span class="line"></span><br><span class="line">#6.	删除表emp5</span><br><span class="line">DROP TABLE IF EXISTS emp5;</span><br><span class="line"></span><br><span class="line">#7.	将表employees2重命名为emp5</span><br><span class="line"></span><br><span class="line">ALTER TABLE employees2 RENAME TO emp5;</span><br><span class="line"></span><br><span class="line">#8.在表dept和emp5中添加新列test_column，并检查所作的操作</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp5 ADD COLUMN test_column INT;</span><br><span class="line">#9.直接删除表emp5中的列 dept_id</span><br><span class="line">DESC emp5;</span><br><span class="line">ALTER TABLE emp5 DROP COLUMN test_column;</span><br></pre></td></tr></table></figure>

<h3 id="5、常见数据类型"><a href="#5、常见数据类型" class="headerlink" title="5、常见数据类型"></a>5、常见数据类型</h3><h4 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>1、数值型<br>    整型<br>    小数：定点数、浮点数<br>2、字符型<br>    较短的文本：char、varchar<br>    较长的文本：text、blob（较长的二进制数据）</p>
<p>日期型：</p>
<h4 id="2、整型"><a href="#2、整型" class="headerlink" title="2、整型"></a>2、整型</h4><h5 id="分类-7"><a href="#分类-7" class="headerlink" title="分类"></a>分类</h5><table>
<thead>
<tr>
<th></th>
<th>tinyint</th>
<th>smallint</th>
<th>mediumint</th>
<th>int/integer</th>
<th>bigint</th>
</tr>
</thead>
<tbody><tr>
<td>字节</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<h5 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h5><p>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值（5.7不插入，亲测）<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p>
<h5 id="使用-17"><a href="#使用-17" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#1.如何设置无符号和有符号</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS tab_int;</span><br><span class="line">CREATE TABLE tab_int(</span><br><span class="line">	t1 INT(7) ZEROFILL,</span><br><span class="line">	t2 INT(7) ZEROFILL </span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC tab_int;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES(-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(-123456,-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(2147483648,4294967296);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES(123,123);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_int;</span><br></pre></td></tr></table></figure>



<h4 id="3、小数"><a href="#3、小数" class="headerlink" title="3、小数"></a>3、小数</h4><h5 id="分类-8"><a href="#分类-8" class="headerlink" title="分类"></a>分类</h5><p>1.浮点型<br>float(M,D)、double(M,D)<br>2.定点型<br>dec(M，D)、decimal(M,D)</p>
<h5 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h5><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p>
<p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p>
<p>③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p>
<h5 id="使用-18"><a href="#使用-18" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE if EXISTS tab_float;</span><br><span class="line">#M：整数部位+小数部位	D：小数部位</span><br><span class="line">CREATE TABLE tab_float(</span><br><span class="line">	f1 FLOAT(5,2),</span><br><span class="line">	f2 DOUBLE(5,2),</span><br><span class="line">	f3 DECIMAL(5,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_float;</span><br><span class="line">INSERT INTO tab_float VALUES(123.4,123.4,123.4);</span><br><span class="line">SELECT * FROM tab_float;</span><br></pre></td></tr></table></figure>

<p><img alt="1560999089824" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560999089824.png" class="lazyload"></p>
<h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
<h4 id="4、字符型"><a href="#4、字符型" class="headerlink" title="4、字符型"></a>4、字符型</h4><p>较短的文本：char、varchar</p>
<p>其他：</p>
<p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p>
<p>较长的文本：text、blob(较大的二进制)</p>
<p>特点：</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char    char(M)</td>
<td>最大的字符数，可以省略，默认为1</td>
<td>固定长度的字符</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td>varchar varchar(M)</td>
<td>最大的字符数，不可以省略</td>
<td>可变长度的字符</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody></table>
<p>若设置char为2时，插入的数据必须&lt;=2个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_float(</span><br><span class="line">	id INT,</span><br><span class="line">	name CHAR(2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into test_float</span><br><span class="line">-- VALUES(1,&apos;123&apos;); 	#插入123会报错</span><br><span class="line">VALUES(1,&apos;12&apos;);	-- 正确</span><br><span class="line"></span><br><span class="line">SELECT * from test_float;</span><br></pre></td></tr></table></figure>

<h4 id="5、Enum枚举类型"><a href="#5、Enum枚举类型" class="headerlink" title="5、Enum枚举类型"></a>5、Enum枚举类型</h4><p>要求插入的值必须属于列表中指定的值之一<br>如果列表成员为1-255，则需要1个字节存储。如果列表成员为255-65535，则需要2个字节存储。最多需要65535个成员！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_char(</span><br><span class="line">	c1 ENUM(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_char VALUES(&apos;a&apos;);</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;b&apos;);</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;c&apos;);</span><br><span class="line">-- INSERT INTO tab_char VALUES(&apos;m&apos;);	-- 插入错误</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;A&apos;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_char;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>结果会将大写变成小写</p>
<p><img alt="1561014495446" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014495446.png" class="lazyload"></p>
<h4 id="6、set类型"><a href="#6、set类型" class="headerlink" title="6、set类型"></a>6、set类型</h4><p>和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_set(</span><br><span class="line">	s1 SET(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_set VALUES(&apos;a&apos;);</span><br><span class="line">INSERT INTO tab_set VALUES(&apos;A,B&apos;);</span><br><span class="line">INSERT INTO tab_set VALUES(&apos;a,c,d&apos;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>结果会将大写变成小写，存储多个数据<br><img alt="1561014348114" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014348114.png" class="lazyload"></p>
<h4 id="7、日期型"><a href="#7、日期型" class="headerlink" title="7、日期型"></a>7、日期型</h4><p><img alt="1561014587100" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014587100.png" class="lazyload"></p>
<p><img alt="1561014664165" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014664165.png" class="lazyload"></p>
<h5 id="分类-9"><a href="#分类-9" class="headerlink" title="分类"></a>分类</h5><p>date只保存日期<br>time 只保存时间<br>year只保存年</p>
<p>datetime保存日期+时间<br>timestamp保存日期+时间</p>
<h5 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h5><table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th>时区等的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000——9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<h5 id="使用-19"><a href="#使用-19" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 TIMESTAMP</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_date VALUES(NOW(),NOW());</span><br><span class="line">SET time_zone=&apos;+9:00&apos;;	-- 修改时区</span><br><span class="line">SELECT * FROM tab_date;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><code>TIMESTAMP</code>收拾去影响</p>
<p><img alt="1561015012652" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561015012652.png" class="lazyload"></p>
<h3 id="6、常见约束"><a href="#6、常见约束" class="headerlink" title="6、常见约束"></a>6、常见约束</h3><h4 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h4><p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p>
<h4 id="分类-10"><a href="#分类-10" class="headerlink" title="分类"></a>分类</h4><p>六大约束</p>
<ul>
<li><p>NOT NULL：非空，用于保证该字段的值不能为空</p>
<p>  比如姓名、学号等</p>
</li>
<li><p>DEFAULT:默认，用于保证该字段有默认值</p>
<p>  比如性别</p>
</li>
<li><p>PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空</p>
<p>  比如学号、员工编号等</p>
</li>
<li><p>UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空</p>
<p>  比如座位号</p>
</li>
<li><p>CHECK:检查约束【mysql中不支持】</p>
<p>  比如年龄、性别</p>
</li>
<li><p>FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p>
<pre><code>在从表添加外键约束，用于引用主表中某列的值</code></pre><p>  比如学生表的专业编号，员工表的部门编号，员工表的工种编号</p>
</li>
</ul>
<p>添加约束的时机：</p>
<ul>
<li>创建表时</li>
<li>修改表时</li>
</ul>
<p>约束的添加分类：</p>
<ul>
<li><p>列级约束：六大约束语法上都支持，但外键约束没有效果</p>
</li>
<li><p>表级约束：除了非空、默认，其他的都支持</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型 列级约束,</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	表级约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>主键和唯一的大对比：</p>
<p>| |保证唯一性|  是否允许为空 |   一个表中可以有多少个  | 是否允许组合|<br>| —- | —- | —- | —- |<br>|主键|    √    |    ×    |    至多有1个      |     √，但不推荐|<br>|唯一|    √    |    √    |    可以有多个     |     √，但不推荐|<br>外键：<br>    1、要求在从表设置外键关系<br>    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>    3、主表的关联列必须是一个key（一般是主键或唯一）<br>    4、插入数据时，先插入主表，再插入从表。删除数据时，先删除从表，再删除主表</p>
<p>可以通过以下两种方式来删除主表的记录<br><strong>方式一：级联删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>
<p><strong>方式二：级联置空</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</span><br></pre></td></tr></table></figure>



<h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><p>修改表时添加或删除约束</p>
<p>1、非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加非空</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 not null;</span><br><span class="line">删除非空</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
<p>2、默认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加默认</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 default 值;</span><br><span class="line">删除默认</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
<p>3、主键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加主键</span><br><span class="line">alter table 表名 add【 constraint 约束名】 primary key(字段名);</span><br><span class="line">删除主键</span><br><span class="line">alter table 表名 drop primary key;</span><br></pre></td></tr></table></figure>
<p>4、唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加唯一</span><br><span class="line">alter table 表名 add【 constraint 约束名】 unique(字段名);</span><br><span class="line">删除唯一</span><br><span class="line">alter table 表名 drop index 索引名;</span><br></pre></td></tr></table></figure>
<p>5、外键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加外键</span><br><span class="line">alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;</span><br><span class="line">删除外键</span><br><span class="line">alter table 表名 drop foreign key 约束名;</span><br></pre></td></tr></table></figure>





<h4 id="使用-20"><a href="#使用-20" class="headerlink" title="使用"></a>使用</h4><h5 id="1、创建表时添加约束"><a href="#1、创建表时添加约束" class="headerlink" title="1、创建表时添加约束"></a>1、创建表时添加约束</h5><h6 id="1、添加列级约束"><a href="#1、添加列级约束" class="headerlink" title="1、添加列级约束"></a>1、添加列级约束</h6><p>直接在字段名和类型后面追加 约束类型即可。</p>
<p>只支持：默认、非空、主键、唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE students;</span><br><span class="line">DROP TABLE stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,#主键</span><br><span class="line">	stuName VARCHAR(20) NOT NULL UNIQUE,#非空</span><br><span class="line">    -- 检查	也可以用in,CHECK(gender in(&apos;男&apos;&apos;女&apos;))</span><br><span class="line">	gender CHAR(1) CHECK(gender=&apos;男&apos; OR gender =&apos;女&apos;),</span><br><span class="line">	seat INT UNIQUE,#唯一</span><br><span class="line">	age INT DEFAULT  18,#默认约束</span><br><span class="line">	majorId INT REFERENCES major(id)#外键</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE major(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	majorName VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<h6 id="2、添加表级约束"><a href="#2、添加表级约束" class="headerlink" title="2、添加表级约束"></a>2、添加表级约束</h6><p>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名) </p>
<p>约束名自己起，不支持非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT,</span><br><span class="line">	</span><br><span class="line">	CONSTRAINT pk PRIMARY KEY(id),#主键</span><br><span class="line">	CONSTRAINT uq UNIQUE(seat),#唯一键</span><br><span class="line">	CONSTRAINT ck CHECK(gender =&apos;男&apos; OR gender  = &apos;女&apos;),#检查</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<p>通用写法：</p>
<p>一般外键用表级约束写，其余的用列级约束写。外键的约束名<code>fk_表名1_表名2</code>，表示foreign key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	sex CHAR(1),</span><br><span class="line">	age INT DEFAULT 18,</span><br><span class="line">	seat INT UNIQUE,</span><br><span class="line">	majorid INT,</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>组合主键：</p>
<p>约束名(列名1，列名2，….)</p>
<h5 id="2、修改表时添加约束"><a href="#2、修改表时添加约束" class="headerlink" title="2、修改表时添加约束"></a>2、修改表时添加约束</h5><p><strong>1、添加列级约束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br></pre></td></tr></table></figure>
<p><strong>2、添加表级约束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br></pre></td></tr></table></figure>

<h6 id="使用-21"><a href="#使用-21" class="headerlink" title="使用"></a>使用</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT</span><br><span class="line">)</span><br><span class="line">DESC stuinfo;</span><br><span class="line">#1.添加非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;</span><br><span class="line">#2.添加默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;</span><br><span class="line">#3.添加主键</span><br><span class="line">#①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line">#②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD PRIMARY KEY(id);</span><br><span class="line"></span><br><span class="line">#4.添加唯一</span><br><span class="line"></span><br><span class="line">#①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</span><br><span class="line">#②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD UNIQUE(seat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.添加外键</span><br><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorId) REFERENCES major(majorid);</span><br></pre></td></tr></table></figure>



<h5 id="3、修改表时删除约束"><a href="#3、修改表时删除约束" class="headerlink" title="3、修改表时删除约束"></a>3、修改表时删除约束</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.删除非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</span><br><span class="line"></span><br><span class="line">#2.删除默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT ;</span><br><span class="line"></span><br><span class="line">#3.删除主键</span><br><span class="line">ALTER TABLE stuinfo DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">#4.删除唯一</span><br><span class="line">ALTER TABLE stuinfo DROP INDEX seat;</span><br><span class="line"></span><br><span class="line">#5.删除外键</span><br><span class="line">ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<h5 id="4、练习-2"><a href="#4、练习-2" class="headerlink" title="4、练习"></a>4、练习</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.向表emp2的id列中添加PRIMARY KEY约束（my_emp_id_pk）</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line">ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);</span><br><span class="line"></span><br><span class="line">#2.	向表dept2的id列中添加PRIMARY KEY约束（my_dept_id_pk）</span><br><span class="line"></span><br><span class="line">#3.	向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。</span><br><span class="line">ALTER TABLE emp2 ADD COLUMN dept_id INT;</span><br><span class="line">ALTER TABLE emp2 ADD CONSTRAINT fk_emp2_dept2 FOREIGN KEY(dept_id) REFERENCES dept2(id);</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th></th>
<th>位置</th>
<th>支持的约束类型</th>
<th>是否可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>所有列的下面</td>
<td>默认和非空不支持，其他支持</td>
<td>可以（主键没有效果）</td>
</tr>
</tbody></table>
<h3 id="7、标识列"><a href="#7、标识列" class="headerlink" title="7、标识列"></a>7、标识列</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>又称为自增长列，可以不用手动的插入值，系统提供默认的序列值</p>
<p><strong>mysql不能设置起始值，可以设置步长</strong></p>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型（INT、float、double）<br>4、标识列可以通过 <code>SET auto_increment_increment=3;</code>设置步长<br>可以通过 手动插入值，设置起始值</p>
<h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><h5 id="1、创建表时设置自增长列"><a href="#1、创建表时设置自增长列" class="headerlink" title="1、创建表时设置自增长列"></a>1、创建表时设置自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表(</span><br><span class="line">	字段名 字段类型 约束 auto_increment</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="2、修改表时设置自增长列"><a href="#2、修改表时设置自增长列" class="headerlink" title="2、修改表时设置自增长列"></a>2、修改表时设置自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束 auto_increment</span><br></pre></td></tr></table></figure>
<h5 id="3、删除自增长列"><a href="#3、删除自增长列" class="headerlink" title="3、删除自增长列"></a>3、删除自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束</span><br></pre></td></tr></table></figure>

<h4 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS tab_identity;</span><br><span class="line">CREATE TABLE tab_identity(</span><br><span class="line">	id INT  ,</span><br><span class="line">	NAME FLOAT UNIQUE AUTO_INCREMENT,</span><br><span class="line">	seat INT </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">TRUNCATE TABLE tab_identity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_identity(id,NAME) VALUES(NULL,&apos;john&apos;);</span><br><span class="line">INSERT INTO tab_identity(NAME) VALUES(&apos;lucy&apos;);</span><br><span class="line">SELECT * FROM tab_identity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &apos;%auto_increment%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET auto_increment_increment=3;	#设置步长</span><br></pre></td></tr></table></figure>













<h2 id="6、TCL语言学习"><a href="#6、TCL语言学习" class="headerlink" title="6、TCL语言学习"></a>6、TCL语言学习</h2><blockquote>
<p>Transaction Control Language —— 事务控制语言</p>
</blockquote>
<h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>​        在mysql中的数据用各种不同的技术存储在文件（或内存）中。通过<code>show engines；</code>来查看mysql支持的存储引擎。</p>
<p>​        在mysql中用的最多的存储引擎有：innodb，myisam,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>
<h4 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h4><p>1、原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>2、一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
<p>3、隔离性（Isolation）<br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>4、持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
<h3 id="2、事务的创建"><a href="#2、事务的创建" class="headerlink" title="2、事务的创建"></a>2、事务的创建</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</li>
</ul>
<p>delete from 表 where id =1;</p>
<ul>
<li>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用</li>
</ul>
<p>手动设置关闭事务<code>set autocommit=0;</code></p>
<p>使用<code>SHOW VARIABLES LIKE &#39;autocommit&#39;;</code>查看语句是否开启事务</p>
<h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤1：开启事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">start transaction;可选的</span><br><span class="line">步骤2：编写事务中的sql语句(select insert update delete)</span><br><span class="line">语句1;</span><br><span class="line">语句2;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">步骤3：结束事务</span><br><span class="line">commit;提交事务</span><br><span class="line">rollback;回滚事务</span><br></pre></td></tr></table></figure>



<h4 id="使用-22"><a href="#使用-22" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;#可以省略</span><br><span class="line">#编写一组事务的语句</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;张无忌&apos;;</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;赵敏&apos;;</span><br><span class="line"></span><br><span class="line">#结束事务	二选一</span><br><span class="line">ROLLBACK;</span><br><span class="line">#commit;</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

<h3 id="3、事务隔离级别"><a href="#3、事务隔离级别" class="headerlink" title="3、事务隔离级别"></a>3、事务隔离级别</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>​        对于同时运行的多个事务, 当这些事务访问<strong>数据库中相同的数据</strong>时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务T1, T2, <strong>T1 读取了已经被T2 更新但还没有被提交的字段</strong>. 之后, 若T2 回滚, T1读取的内容就是临时且无效的.</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后T2 在该表中插入了一些新的行. 之后, 如果T1 再次读取同一个表, 就会多出几行.</li>
</ul>
<p>​        <strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p>
<p>​        <strong>一个事务与其他事务隔离的程度称为隔离级别.</strong> 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.</p>
<h4 id="4-种事务隔离级别"><a href="#4-种事务隔离级别" class="headerlink" title="4 种事务隔离级别"></a>4 种事务隔离级别</h4><p>数据库提供的4 种事务隔离级别</p>
<p><img alt="1561098719029" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561098719029.png" class="lazyload"></p>
<p>​        Oracle 支持的2 种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED<br>​        Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>讲得很好<a href="https://www.bilibili.com/video/av49181542/?p=137" target="_blank" rel="noopener">https://www.bilibili.com/video/av49181542/?p=137</a></p>
<p>每启动一个mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量<code>@@tx_isolation</code>, 表示当前的事务隔离级别.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看当前隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line">设置当前mySQL 连接的隔离级别:</span><br><span class="line">set transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">设置数据库系统的全局的隔离级别:</span><br><span class="line"># set session|global transaction isolation level 隔离级别;</span><br><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>隔离级别，由上往下级别越来越高</p>
<p>x：不能避免    √：避免</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted:读未提交</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>read committed：读已提交</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>repeatable read：可重复读</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>serializable：串行化</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>mysql中默认 第三个隔离级别 repeatable read<br>oracle中默认第二个隔离级别 read committed</p>
<h3 id="4、savepoint"><a href="#4、savepoint" class="headerlink" title="4、savepoint"></a>4、savepoint</h3><p>用来回滚到某个保存点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id=25;</span><br><span class="line">SAVEPOINT a;#设置保存点</span><br><span class="line">DELETE FROM account WHERE id=28;</span><br><span class="line">ROLLBACK TO a;#回滚到保存点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

<h3 id="5、truncate和delete的区别"><a href="#5、truncate和delete的区别" class="headerlink" title="5、truncate和delete的区别"></a>5、truncate和delete的区别</h3><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>回滚之后数据还在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">DELETE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>



<h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>回滚之后数据不在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">TRUNCATE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>







<h2 id="7、视图"><a href="#7、视图" class="headerlink" title="7、视图"></a>7、视图</h2><h3 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h3><p>虚拟表，和普通表一样使用。mysql5.1版本出现的新特性，是通过表动态生成的数据。</p>
<p>比如：舞蹈班和普通班级的对比</p>
<p><strong>案例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询姓张的学生名和专业名</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.`majorid`= m.`id`</span><br><span class="line">WHERE s.`stuname` LIKE &apos;张%&apos;;</span><br><span class="line"></span><br><span class="line">-- ========================================================</span><br><span class="line">CREATE VIEW v1</span><br><span class="line">AS</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.`majorid`= m.`id`;</span><br><span class="line"></span><br><span class="line">-- 方便使用</span><br><span class="line">SELECT * FROM v1 WHERE stuname LIKE &apos;张%&apos;;</span><br></pre></td></tr></table></figure>


<p><strong>应用场景：</strong></p>
<ul>
<li><p>多个地方用到同样的查询结果</p>
</li>
<li><p>该查询结果使用的sql语句较复杂</p>
</li>
</ul>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><h4 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h4 id="使用-23"><a href="#使用-23" class="headerlink" title="使用"></a>使用</h4><p>1、查询姓名中包含a字符的员工名、部门名和工种信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#①创建</span><br><span class="line">CREATE VIEW myv1</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d ON e.department_id  = d.department_id</span><br><span class="line">JOIN jobs j ON j.job_id  = e.job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②使用</span><br><span class="line">SELECT * FROM myv1 WHERE last_name LIKE &apos;%a%&apos;;</span><br></pre></td></tr></table></figure>


<p>2、查询各部门的平均工资级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①创建视图查看每个部门的平均工资</span><br><span class="line">CREATE VIEW myv2</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#②使用</span><br><span class="line">SELECT myv2.`ag`,g.grade_level</span><br><span class="line">FROM myv2</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON myv2.`ag` BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br></pre></td></tr></table></figure>


<p>3、询平均工资最低的部门信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br></pre></td></tr></table></figure>
<p>4、查询平均工资最低的部门名和工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT d.*,m.ag</span><br><span class="line">FROM myv3 m</span><br><span class="line">JOIN departments d</span><br><span class="line">ON m.`department_id`=d.`department_id`;</span><br></pre></td></tr></table></figure>

<h4 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW emp_v1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,salary,email</span><br><span class="line">FROM employees</span><br><span class="line">WHERE phone_number LIKE &apos;011%&apos;;</span><br><span class="line"></span><br><span class="line">#二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW emp_v2</span><br><span class="line">AS</span><br><span class="line">SELECT MAX(salary) mx_dep,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT d.*,m.mx_dep</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN emp_v2 m</span><br><span class="line">ON m.department_id = d.`department_id`;</span><br></pre></td></tr></table></figure>







<h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><h4 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h4><h5 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view  视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h5 id="使用-24"><a href="#使用-24" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM myv3 </span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure>

<h4 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h4><h5 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h5><p>类似表的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as </span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h5 id="使用-25"><a href="#使用-25" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure>



<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图名,视图名,...;</span><br><span class="line">DROP VIEW emp_v1,emp_v2,myv3;</span><br></pre></td></tr></table></figure>

<h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 方式一</span><br><span class="line">DESC myv3;</span><br><span class="line">-- 方式二</span><br><span class="line">SHOW CREATE VIEW myv3;</span><br></pre></td></tr></table></figure>



<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图中数据的增删改，和DML类似</p>
<p>对视图进行增删改，对应的原始表也会进行增删改，数据同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) &quot;annual salary&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">#1.插入</span><br><span class="line">INSERT INTO myv1 VALUES(&apos;张飞&apos;,&apos;zf@qq.com&apos;);</span><br><span class="line"></span><br><span class="line">#2.修改</span><br><span class="line">UPDATE myv1 SET last_name = &apos;张无忌&apos; WHERE last_name=&apos;张飞&apos;;</span><br><span class="line"></span><br><span class="line">#3.删除</span><br><span class="line">DELETE FROM myv1 WHERE last_name = &apos;张无忌&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>具备以下特点的视图不允许更新（基本上全部了）</strong><br>①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT MAX(salary) m,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">UPDATE myv1 SET m=9000 WHERE department_id=10;</span><br></pre></td></tr></table></figure>

<p>②常量视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv2</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT &apos;john&apos; NAME;</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv2;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">UPDATE myv2 SET NAME=&apos;lucy&apos;;</span><br></pre></td></tr></table></figure>




<p>③Select中包含子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资</span><br><span class="line">FROM departments;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line">UPDATE myv3 SET 最高工资=100000;</span><br></pre></td></tr></table></figure>

<p>④join</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv4</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d</span><br><span class="line">ON e.department_id  = d.department_id;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv4;</span><br><span class="line">UPDATE myv4 SET last_name  = &apos;张飞&apos; WHERE last_name=&apos;Whalen&apos;;</span><br><span class="line">INSERT INTO myv4 VALUES(&apos;陈真&apos;,&apos;xxxx&apos;);</span><br></pre></td></tr></table></figure>


<p>⑤from一个不能更新的视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv5</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv5;</span><br><span class="line"></span><br><span class="line">UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;</span><br></pre></td></tr></table></figure>

<p>⑥where子句的子查询引用了from子句中的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv6</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,email,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN(</span><br><span class="line">	SELECT  manager_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE manager_id IS NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv6;</span><br><span class="line">UPDATE myv6 SET salary=10000 WHERE last_name = &apos;k_ing&apos;;</span><br></pre></td></tr></table></figure>





<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><h4 id="视图的好处"><a href="#视图的好处" class="headerlink" title="视图的好处"></a>视图的好处</h4><p>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>
<table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>是否实际占用物理空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>增删改查，只是一般不能增删改</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
<h2 id="8、变量"><a href="#8、变量" class="headerlink" title="8、变量"></a>8、变量</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>系统变量：全局变量、会话变量</p>
<p>自定义变量：用户变量、局部变量</p>
<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>说明：变量由系统定义，不是用户定义，属于服务器层面<br><span style="color:red"><strong>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别</strong></span><br>使用步骤：<br>1、查看所有系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show [global|session] variables;</span><br></pre></td></tr></table></figure>
<p>2、查看满足条件的部分系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show [global|session] variables like &apos;%char%&apos;;</span><br></pre></td></tr></table></figure>
<p>3、查看指定的系统变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@[global|session].系统变量名;</span><br></pre></td></tr></table></figure>
<p>4、为某个系统变量赋值<br>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set [global|session] 系统变量名=值;</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@[global|session].系统变量名=值;</span><br></pre></td></tr></table></figure>

<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">#②查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">#③查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line"></span><br><span class="line">#④为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit=0;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure>



<h4 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h4><p>作用域：针对于当前会话（连接）有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line"></span><br><span class="line">#②查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">#③查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line"></span><br><span class="line">#④为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation=&apos;read-uncommitted&apos;;</span><br><span class="line">SET SESSION tx_isolation=&apos;read-committed&apos;;</span><br></pre></td></tr></table></figure>



<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p>
<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>作用域：针对于当前会话（连接）有效，作用域同于会话变量</p>
<p><strong>应用在任何地方，也就是<code>begin</code> <code>end</code>里面/外面</strong></p>
<p>赋值操作符：<code>=</code>或<code>:=</code></p>
<p>①声明并初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set可以用两种方式</span><br><span class="line">SET @变量名=值;</span><br><span class="line">SET @变量名:=值;</span><br><span class="line"></span><br><span class="line">#select只能用:=</span><br><span class="line">SELECT @变量名:=值;</span><br></pre></td></tr></table></figure>

<p>②赋值（更新变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">	SET @变量名=值;</span><br><span class="line">	SET @变量名:=值;</span><br><span class="line">	SELECT @变量名:=值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO @变量名</span><br><span class="line">	FROM 表;</span><br></pre></td></tr></table></figure>

<p>③使用（查看变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @变量名;</span><br></pre></td></tr></table></figure>

<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、创建name变量赋值并打印</span><br><span class="line">set @name=&apos;john&apos;;</span><br><span class="line">set @name=100;</span><br><span class="line">select @name;</span><br><span class="line"></span><br><span class="line"># 2、创建count变量并将employees的总个数赋给ocunt后打印</span><br><span class="line">set @count=1;</span><br><span class="line">select COUNT(*) into @count</span><br><span class="line">from employees;</span><br><span class="line">SELECT @count;</span><br></pre></td></tr></table></figure>







<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>作用域：仅仅在定义它的begin end块中有效</p>
<p>应用在 begin end中的第一句话</p>
<p>使用步骤：<br>1、声明<br>2、赋值</p>
<p>①声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 类型;</span><br><span class="line">DECLARE 变量名 类型 【DEFAULT 值】;</span><br></pre></td></tr></table></figure>

<p>②赋值（更新变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">	SET 局部变量名=值;</span><br><span class="line">	SET 局部变量名:=值;</span><br><span class="line">	SELECT 局部变量名:=值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO 具备变量名</span><br><span class="line">	FROM 表;</span><br><span class="line">#③使用（查看变量的值）</span><br><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>用户变量和局部变量的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：声明两个变量，求和并打印</span><br><span class="line"></span><br><span class="line">#用户变量</span><br><span class="line">SET @m=1;</span><br><span class="line">SET @n=1;</span><br><span class="line">SET @sum=@m+@n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"></span><br><span class="line">#局部变量	会报错，没有放在begin end中</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 1;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line">SET SUM=m+n;</span><br><span class="line">SELECT SUM;</span><br></pre></td></tr></table></figure>







<h2 id="9、存储过程和函数"><a href="#9、存储过程和函数" class="headerlink" title="9、存储过程和函数"></a>9、存储过程和函数</h2><p>存储过程和函数：类似于java中的方法</p>
<p>好处：<br>1、提高代码的重用性<br>2、简化操作</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<h4 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(参数列表)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	存储过程体（一组合法的SQL语句）</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong><br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)</p>
<p>参数模式：<br>in：该参数可以作为输入，也就是该<strong>参数需要调用方传入值</strong><br>out：该参数可以作为输出，也就是该参数可以作为<strong>返回值</strong><br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p>
<p>2、如果存储过程体仅仅只有一句话，begin end可以省略(类似循环语句一句话省略括号)<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br><code>delimiter 结束标记</code><br>案例：<br><code>delimiter $</code></p>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(实参列表);</span><br></pre></td></tr></table></figure>



<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：drop procedure 存储过程名</span><br></pre></td></tr></table></figure>



<h5 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>





<h4 id="使用-26"><a href="#使用-26" class="headerlink" title="使用"></a>使用</h4><h5 id="1、空参列表"><a href="#1、空参列表" class="headerlink" title="1、空参列表"></a>1、空参列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：插入到admin表中五条记录</span><br><span class="line"></span><br><span class="line">SELECT * FROM admin;</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp1()</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO admin(username,`password`) </span><br><span class="line">	VALUES(&apos;john1&apos;,&apos;0000&apos;),(&apos;lily&apos;,&apos;0000&apos;),(&apos;rose&apos;,&apos;0000&apos;),(&apos;jack&apos;,&apos;0000&apos;),(&apos;tom&apos;,&apos;0000&apos;);</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#调用 navicat不加$</span><br><span class="line">CALL myp1()</span><br></pre></td></tr></table></figure>



<h5 id="2、带in模式参数"><a href="#2、带in模式参数" class="headerlink" title="2、带in模式参数"></a>2、带in模式参数</h5><p><strong>案例1：创建存储过程实现 根据女神名，查询对应的男神信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create PROCEDURE search(in girl_name VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	select b1.* ,b2.boyName</span><br><span class="line">	from beauty b1</span><br><span class="line">	join boys b2</span><br><span class="line">	on b1.boyfriend_id = b2.id</span><br><span class="line">	WHERE b1.`name` = girl_name;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call search(&apos;赵敏&apos;)</span><br></pre></td></tr></table></figure>



<p><strong>案例2 ：创建存储过程实现，用户是否登录成功</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE result INT DEFAULT 0;#声明并初始化</span><br><span class="line">	</span><br><span class="line">	SELECT COUNT(*) INTO result#赋值</span><br><span class="line">	FROM admin</span><br><span class="line">	WHERE admin.username = username</span><br><span class="line">	AND admin.password = PASSWORD;</span><br><span class="line">	</span><br><span class="line">	SELECT IF(result&gt;0,&apos;成功&apos;,&apos;失败&apos;);#使用</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp3(&apos;张飞&apos;,&apos;8888&apos;)</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img alt="1561429038620" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429038620.png" class="lazyload"><br><img alt="1561429053798" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429053798.png" class="lazyload"></p>
<h5 id="3、in-amp-out-模式参数"><a href="#3、in-amp-out-模式参数" class="headerlink" title="3、in &amp; out 模式参数"></a>3、in &amp; out 模式参数</h5><p><strong>案例1：根据输入的女神名，返回对应的男神名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create PROCEDURE search1(in girl_name VARCHAR(20) , out boy_name VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	select b2.boyName into boy_name</span><br><span class="line">	from beauty b1</span><br><span class="line">	join boys b2</span><br><span class="line">	on b1.boyfriend_id = b2.id</span><br><span class="line">	WHERE b1.`name` = girl_name;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call search1(&apos;赵敏&apos;,@boy_name)</span><br><span class="line">select @boy_name</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img alt="1561429397840" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429397840.png" class="lazyload"></p>
<p><strong>案例2：根据输入的女神名，返回对应的男神名和魅力值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT boys.boyname ,boys.usercp INTO boyname,usercp</span><br><span class="line">	FROM boys </span><br><span class="line">	RIGHT JOIN</span><br><span class="line">	beauty b ON b.boyfriend_id = boys.id</span><br><span class="line">	WHERE b.name=beautyName ;</span><br><span class="line">	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp7(&apos;小昭&apos;,@name,@cp)$</span><br></pre></td></tr></table></figure>

<h5 id="4、inout模式参数"><a href="#4、inout模式参数" class="headerlink" title="4、inout模式参数"></a>4、inout模式参数</h5><p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SET a=a*2;</span><br><span class="line">	SET b=b*2;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">SET @m=10$</span><br><span class="line">SET @n=20$</span><br><span class="line">CALL myp8(@m,@n)$</span><br><span class="line">SELECT @m,@n$</span><br></pre></td></tr></table></figure>



<h4 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h4><p>1、创建存储过程实现传入用户名和密码，插入到admin表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO admin(admin.username,PASSWORD)</span><br><span class="line">	VALUES(username,loginpwd);</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>2、创建存储过程实现传入女神编号，返回女神名称和女神电话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">	SELECT b.name ,b.phone INTO NAME,phone</span><br><span class="line">	FROM beauty b</span><br><span class="line">	WHERE b.id = id;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>3、创建存储存储过程或函数实现传入两个女神生日，返回大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT DATEDIFF(birth1,birth2) INTO result;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>4、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT DATE_FORMAT(mydate,&apos;%y年%m月%d日&apos;) INTO strDate;</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro4(NOW(),@str)</span><br><span class="line">SELECT @str</span><br></pre></td></tr></table></figure>


<p>5、创建存储过程或函数实现传入女神名称，返回：女神 and 男神  格式的字符串<br>如 传入 ：小昭<br>返回： 小昭 AND 张无忌</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE test_pro5</span><br><span class="line">CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT CONCAT(beautyName,&apos; and &apos;,IFNULL(boyName,&apos;null&apos;)) INTO str</span><br><span class="line">	FROM boys bo</span><br><span class="line">	RIGHT JOIN beauty b ON b.boyfriend_id = bo.id</span><br><span class="line">	WHERE b.name=beautyName;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	SET str=</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro5(&apos;赵敏&apos;,@str)</span><br><span class="line">SELECT @str</span><br></pre></td></tr></table></figure>

<p><img alt="1561446772615" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561446772615.png" class="lazyload"></p>
<p>6、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE test_pro6</span><br><span class="line">CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT * FROM beauty LIMIT startIndex,size;</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro6(3,5)</span><br></pre></td></tr></table></figure>



<p>7、删除存储过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE p1;</span><br><span class="line">DROP PROCEDURE p2,p3;#× 不支持多个删除</span><br></pre></td></tr></table></figure>


<p>8、查看存储过程的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>





<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<p>区别：</p>
<p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p>
<h4 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">	函数体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型</p>
<p>2.函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议</p>
<p>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记</p>
<h5 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(参数列表)</span><br></pre></td></tr></table></figure>



<h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION myf3;</span><br></pre></td></tr></table></figure>
<p>在mysql的proc表中会有创建的存储过程和函数<br><img alt="1561448603681" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561448603681.png" class="lazyload"></p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION myf3;</span><br></pre></td></tr></table></figure>



<h4 id="使用-27"><a href="#使用-27" class="headerlink" title="使用"></a>使用</h4><p>1、无参返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 案例1：返回公司的员工个数</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf1() <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">DECLARE</span> c <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;<span class="comment">#定义局部变量</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> c<span class="comment">#赋值</span></span><br><span class="line">	<span class="keyword">FROM</span> employees;</span><br><span class="line">	RETURN c;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf1()$</span><br></pre></td></tr></table></figure>



<p>2、有参返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例1：根据部门名，返回该部门的平均工资</span><br><span class="line">delimiter $</span><br><span class="line">CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	SET @sal=0;#定义用户变量 </span><br><span class="line">	SELECT salary INTO @sal   #赋值</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = empName;</span><br><span class="line">	</span><br><span class="line">	RETURN @sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf2(&apos;Kochhar&apos;) $</span><br><span class="line"></span><br><span class="line"># =============================================</span><br><span class="line"></span><br><span class="line">#案例2：根据部门名，返回该部门的平均工资</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE sal DOUBLE ;</span><br><span class="line">	SELECT AVG(salary) INTO sal</span><br><span class="line">	FROM employees e</span><br><span class="line">	JOIN departments d ON e.department_id = d.department_id</span><br><span class="line">	WHERE d.department_name=deptName;</span><br><span class="line">	RETURN sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf3(&apos;IT&apos;)$</span><br></pre></td></tr></table></figure>



<p>3、求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、创建函数，实现传入两个float，返回二者之和</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE SUM FLOAT DEFAULT 0;</span><br><span class="line">	SET SUM=num1+num2;</span><br><span class="line">	RETURN SUM;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT test_fun1(1,2)$</span><br></pre></td></tr></table></figure>









<h2 id="10、流程控制结构"><a href="#10、流程控制结构" class="headerlink" title="10、流程控制结构"></a>10、流程控制结构</h2><h3 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h3><h4 id="1、if结构"><a href="#1、if结构" class="headerlink" title="1、if结构"></a>1、if结构</h4><h5 id="if函数语法"><a href="#if函数语法" class="headerlink" title="if函数语法"></a>if函数语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件,值1，值2)</span><br></pre></td></tr></table></figure>

<p>如果条件成立，则if返回值1，否则返回值2</p>
<p>功能：实现简单的双分支，应用在任何地方</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @num = 0;</span><br><span class="line">SELECT if(@num,&apos;true&apos;,&apos;false&apos;);</span><br></pre></td></tr></table></figure>

<p><img alt="1561519881501" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519881501.png" class="lazyload"></p>
<h5 id="if结构语法"><a href="#if结构语法" class="headerlink" title="if结构语法"></a>if结构语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">....</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br><span class="line">功能：类似于多重if</span><br></pre></td></tr></table></figure>

<p>只能应用在begin end 中</p>
<h5 id="使用-28"><a href="#使用-28" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ch CHAR DEFAULT &apos;A&apos;;</span><br><span class="line">	IF score&gt;90 THEN SET ch=&apos;A&apos;;</span><br><span class="line">	ELSEIF score&gt;80 THEN SET ch=&apos;B&apos;;</span><br><span class="line">	ELSEIF score&gt;60 THEN SET ch=&apos;C&apos;;</span><br><span class="line">	ELSE SET ch=&apos;D&apos;;</span><br><span class="line">	END IF;</span><br><span class="line">	RETURN ch;</span><br><span class="line">END</span><br><span class="line">SELECT test_if(87)</span><br></pre></td></tr></table></figure>

<p><img alt="1561519907951" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519907951.png" class="lazyload"></p>
<h4 id="2、case结构"><a href="#2、case结构" class="headerlink" title="2、case结构"></a>2、case结构</h4><h5 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h5><p>情况1：类似于java中的switch，一般用于实现等值判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 变量|表达式</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end case</span><br></pre></td></tr></table></figure>



<p>情况2：类似于java中的多重if语句，一般用于实现区间判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end case</span><br></pre></td></tr></table></figure>



<h5 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h5><p>1、可以作为表达式，[嵌套在其他语句中使用](# 2、case函数)，可以放在任何地方，<code>BEGIN END</code>中或者<code>BEGIN END</code>的外面</p>
<p>2、可以作为独立的语句去使用，只能放在<code>BEGIN END</code>中</p>
<p>3、<code>ELSE</code>可以省略，如果<code>ELSE</code>省略了，并且所有<code>WHEN</code>条件都不满足，则返回NULL</p>
<h5 id="使用-29"><a href="#使用-29" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：创建函数，实现传入成绩，</span><br><span class="line">#如果成绩&gt;90,返回A，</span><br><span class="line">#如果成绩&gt;80,返回B，</span><br><span class="line">#如果成绩&gt;60,返回C，</span><br><span class="line">#否则返回D</span><br><span class="line"></span><br><span class="line">create PROCEDURE test_case(IN score INT)</span><br><span class="line">BEGIN</span><br><span class="line">	case </span><br><span class="line">	WHEN score&gt;=90 AND score &lt;= 100 THEN SELECT &apos;A&apos;;</span><br><span class="line">	WHEN score &gt;= 80 THEN SELECT &apos;B&apos;;</span><br><span class="line">	WHEN score &gt;= 60 THEN SELECT &apos;C&apos;; </span><br><span class="line">	ELSE SELECT &apos;D&apos;;</span><br><span class="line">	END CASE;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call test_case(59)</span><br></pre></td></tr></table></figure>

<p><img alt="1561519331629" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519331629.png" class="lazyload"></p>
<h3 id="2、循环"><a href="#2、循环" class="headerlink" title="2、循环"></a>2、循环</h3><p>分类：<br>while、loop、repeat</p>
<p>循环控制：</p>
<p>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环</p>
<h4 id="1、while-使用较多"><a href="#1、while-使用较多" class="headerlink" title="1、while(使用较多)"></a>1、while(使用较多)</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[标签:] while 循环条件 do</span><br><span class="line">	循环体;</span><br><span class="line">end while [标签];</span><br></pre></td></tr></table></figure>



<h4 id="2、loop"><a href="#2、loop" class="headerlink" title="2、loop"></a>2、loop</h4><p>无条件死循环</p>
<h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【标签:】loop</span><br><span class="line">	循环体;</span><br><span class="line">end loop 【标签】;</span><br></pre></td></tr></table></figure>

<p>可以用来模拟简单的死循环</p>
<h4 id="3、repeat"><a href="#3、repeat" class="headerlink" title="3、repeat"></a>3、repeat</h4><p>类似java中的do…while…    先执行后判断</p>
<h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【标签：】repeat</span><br><span class="line">	循环体;</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat 【标签】;</span><br></pre></td></tr></table></figure>



<h4 id="使用-30"><a href="#使用-30" class="headerlink" title="使用"></a>使用</h4><p>1、没有添加循环控制语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录</span><br><span class="line"># 分开执行</span><br><span class="line">DROP PROCEDURE pro_while1</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	WHILE i&lt;=insertCount DO</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;Rose&apos;,i),&apos;666&apos;);</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">CALL pro_while1(100)</span><br></pre></td></tr></table></figure>



<p>2、添加leave语句</p>
<p>使用leave必须要对循环起一个别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止</span><br><span class="line">TRUNCATE TABLE admin</span><br><span class="line">DROP PROCEDURE test_while1</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line">		IF i&gt;=20 THEN LEAVE a;</span><br><span class="line">		END IF;</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE a;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure>

<p><img alt="1562207994395" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562207994395.png" class="lazyload"></p>
<p>3、添加iterate语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</span><br><span class="line">TRUNCATE TABLE admin</span><br><span class="line">DROP PROCEDURE test_while1</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		SET i=i+1;</span><br><span class="line">		IF MOD(i,2)!=0 THEN ITERATE a;</span><br><span class="line">		END IF;</span><br><span class="line">		</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line">		</span><br><span class="line">	END WHILE a;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure>



<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>已知表stringcontent，向该表插入指定个数的，随机的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stringcontent;</span><br><span class="line">CREATE TABLE stringcontent(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	content VARCHAR(20)</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line">DELIMITER</span><br><span class="line">CREATE PROCEDURE test_randstr_insert(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	DECLARE str VARCHAR(26) DEFAULT &apos;abcdefghijklmnopqrstuvwxyz&apos;;</span><br><span class="line">	DECLARE startIndex INT;#代表初始索引</span><br><span class="line">	DECLARE len INT;#代表截取的字符长度</span><br><span class="line">	WHILE i&lt;=insertcount DO</span><br><span class="line">		SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26</span><br><span class="line">		SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）</span><br><span class="line">		INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">CALL test_randstr_insert(10)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法</title>
    <url>/2019/12/12/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、稀疏数组和队列"><a href="#一、稀疏数组和队列" class="headerlink" title="一、稀疏数组和队列"></a>一、稀疏数组和队列</h1><h2 id="1、稀疏数组（sparsearray）"><a href="#1、稀疏数组（sparsearray）" class="headerlink" title="1、稀疏数组（sparsearray）"></a>1、稀疏数组（sparsearray）</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img alt="1564217081634" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564217081634.png" class="lazyload"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​        当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是:</p>
<p>1)记录数组一共有几行几列，有多少个不同的值</p>
<p>2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<p><img alt="1564217192689" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564217192689.png" class="lazyload"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img alt="1564217279345" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564217279345.png" class="lazyload"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sparearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName sparearray</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/27</span></span><br><span class="line"><span class="comment"> * Time      15:37</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      1、稀疏数组的组成 + 数组复原</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpareArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//---------------------------建立稀疏数组------------------------------</span></span><br><span class="line">        <span class="comment">//[0]创建11*11二维数据</span></span><br><span class="line">        <span class="keyword">int</span> chessArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历原始数据</span></span><br><span class="line">        System.out.println(<span class="string">"----------遍历原始数据-------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : rows)&#123;</span><br><span class="line">                System.out.print(e + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---------------二维数组转稀疏数组---------------------------</span></span><br><span class="line">        <span class="comment">//[1] 遍历得到非0数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : rows)&#123;</span><br><span class="line">                <span class="keyword">if</span> (e!= <span class="number">0</span>)</span><br><span class="line">                    sum +=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(sum);</span></span><br><span class="line">        <span class="comment">//[2]创建稀疏数组 并赋值</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j]!= <span class="number">0</span>)&#123;</span><br><span class="line">                    sparseArr[index][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[index][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[index][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                    index += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------遍历稀疏数组-------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"行\t列\t值"</span>);</span><br><span class="line">        <span class="comment">//[3]遍历稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : sparseArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : rows)&#123;</span><br><span class="line">                System.out.print(e + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------复原-----------------------------------</span></span><br><span class="line">        <span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line"><span class="comment">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h2><p><img alt="1564220167546" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564220167546.png" class="lazyload"></p>
<h3 id="1、模拟普通队列"><a href="#1、模拟普通队列" class="headerlink" title="1、模拟普通队列"></a>1、模拟普通队列</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><img alt="1564220179900" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564220179900.png" class="lazyload"></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ArrayQueueDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/27</span></span><br><span class="line"><span class="comment"> * Time      16:54</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 顺序表   用数组实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">//接收用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span>(loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">//退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//模拟队列，顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列  默认指针都为-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//队列头前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;<span class="comment">//队列尾，指向队列最后一个数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定front+1 和 rear之间打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=(front+<span class="number">1</span>);i&lt;=rear;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队  rear入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//满了</span></span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//rear后移</span></span><br><span class="line">        arr[rear] = data;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队    front出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[++front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上漏洞较为明显，不能循环使用</p>
<p><img alt="1564221117008" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564221117008.png" class="lazyload"></p>
<h3 id="2、模拟环形队列"><a href="#2、模拟环形队列" class="headerlink" title="2、模拟环形队列"></a>2、模拟环形队列</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>对前面的数组模拟队列的优化，充分利用数组.因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img alt="1564299842480" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564299842480.png" class="lazyload"></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName CircleArrayQueue</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/28</span></span><br><span class="line"><span class="comment"> * Time      15:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//测试一把</span></span><br><span class="line">        System.out.println(<span class="string">"测试数组模拟环形队列的案例~~~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个环形队列</span></span><br><span class="line">        CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>); <span class="comment">//说明设置4, 其队列的有效数据最大是3</span></span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s: 显示队列\t e:退出\t a:添加\t g:去除\th:头数据"</span>);</span><br><span class="line"></span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//最大容量</span></span><br><span class="line">    <span class="comment">//front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素</span></span><br><span class="line">    <span class="comment">//front 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="comment">//rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line">    <span class="comment">//rear 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//模拟队列，顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列  默认指针都为-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        front = <span class="number">0</span>;<span class="comment">//队列头</span></span><br><span class="line">        rear = <span class="number">0</span>;<span class="comment">//队列尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队  rear入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rear为最后一个元素后的空元素位置填充</span></span><br><span class="line">        arr[rear] = data;</span><br><span class="line">        <span class="comment">//rear向后移</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队    front出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line">        <span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line">        <span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line">        <span class="keyword">int</span> data = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span> ) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 思路：从front开始遍历，遍历多少个元素,剔除最后一个空位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=front ;i&lt;= front + size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            System.out.print(arr[i % maxSize] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front ) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>链表（Linked List）是有序的列表，但是它在内存中是存储如下</p>
<p><img alt="1564299967545" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564299967545.png" class="lazyload"></p>
<h2 id="2、单链表"><a href="#2、单链表" class="headerlink" title="2、单链表"></a>2、单链表</h2><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>使用带head头的<strong>单向链表</strong>实现 –水浒英雄排行榜管理</p>
<p>【1】完成对英雄人物的<strong>增删改查</strong>操作</p>
<p>【2】第一种方法在添加英雄时，直接添加到链表的尾部</p>
<p>【3】<strong>第二种方式在添加英雄时</strong>，根据排名将英雄插入到指定位置<br> (如果有这个排名，则添加失败，并给出提示)</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p><img alt="1564536750418" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564536750418.png" class="lazyload"></p>
<h4 id="编号顺序添加"><a href="#编号顺序添加" class="headerlink" title="编号顺序添加"></a>编号顺序添加</h4><p><img alt="1564536804884" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564536804884.png" class="lazyload"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img alt="1564536820112" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564536820112.png" class="lazyload"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName SingleLinkListDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/28</span></span><br><span class="line"><span class="comment"> * Time      16:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SingleLinkList list = <span class="keyword">new</span> SingleLinkList();</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"1"</span>,<span class="string">"1"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"2"</span>,<span class="string">"2"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"3"</span>,<span class="string">"3"</span>));</span><br><span class="line"></span><br><span class="line">        list.list();</span><br><span class="line">        System.out.println(<span class="string">"-----------删除2---------------------"</span>);</span><br><span class="line">        list.del(<span class="number">2</span>);</span><br><span class="line">        list.list();</span><br><span class="line">        System.out.println(<span class="string">"-----------新增4---------------------"</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"4"</span>,<span class="string">"4"</span>));</span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------修改4---------------------"</span>);</span><br><span class="line">        list.update(<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"8"</span>,<span class="string">"8"</span>));</span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------排序添加2---------------------"</span>);</span><br><span class="line">        list.addByOrder(<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"4"</span>,<span class="string">"4"</span>));</span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SingleLinkList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode headNode = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHeadNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">//1. 找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HeroNode node = headNode;</span><br><span class="line">        <span class="keyword">while</span> (node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//不是链表的最后</span></span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">                heroNode.next = temp.next;</span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断flag 的值</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123; <span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">            System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(headNode.next == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"空列表"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示是否找到该节点</span></span><br><span class="line"></span><br><span class="line">        HeroNode tmp = headNode.next;</span><br><span class="line">        <span class="keyword">while</span> (tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.no == newHeroNode.no)&#123;</span><br><span class="line">                tmp.name = newHeroNode.name;</span><br><span class="line">                tmp.nickname = newHeroNode.nickname;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode pre = headNode;</span><br><span class="line">        HeroNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pre.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.next.no==no)&#123;</span><br><span class="line">                <span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                next = pre.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123; <span class="comment">//找到</span></span><br><span class="line">            <span class="comment">//可以删除</span></span><br><span class="line">            pre.next = next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(headNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = headNode.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移， 一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><h4 id="1、求单链表中有效节点个数"><a href="#1、求单链表中有效节点个数" class="headerlink" title="1、求单链表中有效节点个数"></a><strong>1、求单链表中有效节点个数</strong></h4><p>遍历一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123; <span class="comment">//空链表</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//定义一个辅助的变量, 这里我们没有统计头节点</span></span><br><span class="line">	HeroNode cur = head.next;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		cur = cur.next; <span class="comment">//遍历</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、查找单链表中的倒数第k个结点"><a href="#2、查找单链表中的倒数第k个结点" class="headerlink" title="2、查找单链表中的倒数第k个结点"></a><strong>2、查找单链表中的倒数第k个结点</strong></h4><p>遍历原链表，采用头插法到新链表中，再换头</p>
<p><img alt="1564538202223" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564538202223.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">		HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">		<span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line">		<span class="comment">//动脑筋</span></span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">			next = cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">			cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">			reverseHead.next = cur; <span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">			cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">		head.next = reverseHead.next;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、从尾到头打印单链表"><a href="#3、从尾到头打印单链表" class="headerlink" title="3、从尾到头打印单链表"></a><strong>3、从尾到头打印单链表</strong></h4><p>采用栈的方式打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式2：</span></span><br><span class="line">    <span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            HeroNode node = stack.pop();</span><br><span class="line">            System.out.println(node.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、双向链表"><a href="#3、双向链表" class="headerlink" title="3、双向链表"></a>3、双向链表</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>使用带head头的<strong>双向链**</strong>表**实现 –水浒英雄排行榜</p>
<p>管理单向链表的缺点分析: </p>
<p>1)单向链表，<strong>查找的方向只能是一个方向</strong>，而双向链<br> 表可以向前或者向后查找。</p>
<p>2)单向链表不能自我删除，需要靠辅助节点 ，而双向 链表，则可以<strong>自我删除</strong>，所以前面我们单链表删除 时节点，总是找到temp,temp是待删除节点的前一个节点.</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img alt="1564542184718" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564542184718.png" class="lazyload"></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName DoubleLinkedListDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/31</span></span><br><span class="line"><span class="comment"> * Time      10:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        System.out.println(<span class="string">"双向链表的测试"</span>);</span><br><span class="line">        <span class="comment">// 先创建节点</span></span><br><span class="line">        HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">// 创建一个双向链表</span></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"公孙胜"</span>, <span class="string">"入云龙"</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">"修改后的链表情况"</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表的方法</span></span><br><span class="line">    <span class="comment">// 显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个节点到双向链表的最后.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">// 形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span></span><br><span class="line">    <span class="comment">// 只是 节点类型改成 HeroNode2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line">        <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到</span></span><br><span class="line">            System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从双向链表中删除一个节点,</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1 对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line">    <span class="comment">// 2 找到后，自我删除即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;<span class="comment">// 空链表</span></span><br><span class="line">            System.out.println(<span class="string">"链表为空，无法删除"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp = head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 找到</span></span><br><span class="line">            <span class="comment">// 可以删除</span></span><br><span class="line">            <span class="comment">// temp.next = temp.next.next;[单向链表]</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">// 这里我们的代码有问题?</span></span><br><span class="line">            <span class="comment">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next; <span class="comment">// 指向下一个节点, 默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre; <span class="comment">// 指向前一个节点, 默认为null</span></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、约瑟夫（Josephu）"><a href="#4、约瑟夫（Josephu）" class="headerlink" title="4、约瑟夫（Josephu）"></a>4、约瑟夫（Josephu）</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Josephu(约瑟夫、约瑟夫环) 问题</strong></p>
<p>Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p><strong>提示</strong>：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
<h3 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h3><p><img alt="1564542413937" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564542413937.png" class="lazyload"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img alt="1564542563525" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564542563525.png" class="lazyload"></p>
<p><img alt="1564543721713" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564543721713.png" class="lazyload"></p>
<p><img alt="1564543756409" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564543756409.png" class="lazyload"></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName JosepHu</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/31</span></span><br><span class="line"><span class="comment"> * Time      11:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JosepHu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">125</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">125</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">        <span class="comment">//String str = "7*2*2-5+1-5+3-3";</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个first节点,当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nums 做一个数据校验</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>; <span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">// 使用for来创建我们的环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">// 如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">                curBoy = first; <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);<span class="comment">//</span></span><br><span class="line">                boy.setNext(first);<span class="comment">//</span></span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前的环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment">     *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment">     *            表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     *            表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">"参数输入有误， 请重新输入"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123; <span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小孩报数前，先让 first 和  helper 移动 k - 1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈</span></span><br><span class="line">        <span class="comment">//这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper == first) &#123; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line">            <span class="comment">//这时将first指向的小孩节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>, first.getNo());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>1、栈的英文为(stack)</p>
<p>2、栈是一个<strong>先入后出</strong>(FILO-First In Last Out)的有序列表。</p>
<p>3、栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</p>
<p>4、根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
<p><img alt="1566870789729" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566870789729.png" class="lazyload"></p>
<p><img alt="1566870793286" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566870793286.png" class="lazyload"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1)子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。   </p>
<p>2)处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</p>
<p>3)表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</p>
<p>4)二叉树的遍历。</p>
<p>5)图形的深度优先(depth一first)搜索法。</p>
<h2 id="2、数组模拟栈"><a href="#2、数组模拟栈" class="headerlink" title="2、数组模拟栈"></a>2、数组模拟栈</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img alt="1566870928332" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566870928332.png" class="lazyload"></p>
<p>实现 栈的 思路分析</p>
<ol>
<li><p>使用数组来模拟栈</p>
</li>
<li><p>定义一个 top  来表示栈顶，初始化 为  -1</p>
</li>
<li><p><strong>入栈</strong>的操作，当有数据加入到栈时， top++;  stack[top] = data;</p>
</li>
<li><p><strong>出栈</strong>的操作， int value = stack[top]; top–, return value</p>
</li>
</ol>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.invoke.empty.Empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ArrayStackDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/8/27</span></span><br><span class="line"><span class="comment"> * Time      9:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        stack.list();</span><br><span class="line"></span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxsize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组模拟栈，数据就放在该数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">//默认为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxsize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxsize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">"栈满了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"栈空了"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> data = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"栈空了"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从栈顶打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">this</span>.stack[i] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1566871784948" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566871784948.png" class="lazyload"></p>
<h2 id="3、模拟计算器"><a href="#3、模拟计算器" class="headerlink" title="3、模拟计算器"></a>3、模拟计算器</h2><p><img alt="1566961103417" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566961103417.png" class="lazyload"></p>
<h2 id="4、表达式"><a href="#4、表达式" class="headerlink" title="4、表达式"></a>4、表达式</h2><h3 id="1、前缀（波兰）"><a href="#1、前缀（波兰）" class="headerlink" title="1、前缀（波兰）"></a>1、前缀（波兰）</h3><p>1)前缀表达式的运算符位于操作数之前</p>
<p>2)举例说明：(3+4)×5-6 对应的前缀表达式就是*- × + 3 4 56</p>
<p>相当于数的先序遍历（根、左、右）</p>
<h4 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h4><p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<p><img alt="1567041903733" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567041903733.png" class="lazyload"></p>
<h3 id="2、中缀"><a href="#2、中缀" class="headerlink" title="2、中缀"></a>2、中缀</h3><p>1、中缀表达式就是<strong>常见的运算表达式</strong>，如(3+4)×5-6</p>
<p>2、中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，<span style="color:red"><strong>因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)</strong></span></p>
<h3 id="3、后缀（逆波兰）"><a href="#3、后缀（逆波兰）" class="headerlink" title="3、后缀（逆波兰）"></a>3、后缀（逆波兰）</h3><p>1、后缀表达式又称<strong>逆波兰表达式</strong>,与前缀表达式相似，只是运算符位于操作数之后</p>
<p>2、中举例说明： (3+4)×5-6 对应的后缀表达式就是 <strong>3</strong> <strong>4 + 5 × 6</strong> <strong>–</strong></p>
<h4 id="计算过程-1"><a href="#计算过程-1" class="headerlink" title="计算过程"></a>计算过程</h4><p><strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素<br>和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<p><img alt="1567042134351" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567042134351.png" class="lazyload"></p>
<h2 id="5、逆波兰计算器"><a href="#5、逆波兰计算器" class="headerlink" title="5、逆波兰计算器"></a>5、逆波兰计算器</h2><p><strong>思路过程如上计算过程</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName RPNDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/8/29</span></span><br><span class="line"><span class="comment"> * Time      9:34</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 逆波兰式(Reverse Polish notation,RPN,或逆波兰记法)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPNDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义逆波兰表达式(3+4)*5-6  =&gt; 3 4 + 5 × 6 -</span></span><br><span class="line">        String suffixExpression = <span class="string">"3 4 + 5 × 6 - "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、将表达式放到ArrayList中</span></span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、将ArrayList传递给一个方法，配合栈完成计算</span></span><br><span class="line">        System.out.println(<span class="string">"最终结果::"</span>+calcuate(rpnList));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span></span>&#123;</span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(split);</span><br><span class="line">        <span class="comment">//list.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcuate</span><span class="params">(List&lt;String&gt; rpnList)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String num1;</span><br><span class="line">        String num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0;i &lt; rpnList.size();i++)&#123;</span></span><br><span class="line">        <span class="keyword">for</span> (String item : rpnList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOper(item))&#123;<span class="comment">//数值压栈</span></span><br><span class="line">                System.out.println(<span class="string">"!::"</span>+item);</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(item);</span><br><span class="line">                num1 = stack.pop();</span><br><span class="line">                num2 = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> res = cal(Integer.parseInt(num1), Integer.parseInt(num2), item);</span><br><span class="line"></span><br><span class="line">                stack.push(String.valueOf(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.parseInt(stack.pop());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"+"</span>.equals(val) ||  <span class="string">"-"</span>.equals(val) || <span class="string">"×"</span>.equals(val) || <span class="string">"/"</span>.equals(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,String oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"×"</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、中缀转后缀"><a href="#6、中缀转后缀" class="headerlink" title="6、中缀转后缀"></a>6、中缀转后缀</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 <strong>中缀表达式转成后缀表达式</strong>。</p>
<p><strong>具体步骤如下:</strong></p>
<ol>
<li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p>
</li>
<li><p>从左至右扫描中缀表达式；</p>
</li>
<li><p>遇到操作数时，将其压s2；</p>
</li>
<li><p>遇到运算符时，比较其与s1栈顶运算符的优先级：</p>
<ol>
<li>如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1；</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；  </li>
</ol>
</li>
<li><p>遇到括号时：</p>
<ol>
<li>如果是左括号“(”，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li><p>重复步骤2至5，直到表达式的最右边</p>
</li>
<li><p>将s1中剩余的运算符依次弹出并压入s2</p>
</li>
<li><p>依次弹出s2中的元素并输出，<strong>结果的逆序即为中缀表达式对应的后缀表达式</strong></p>
</li>
</ol>
<p><img alt="1567049578081" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567049578081.png" class="lazyload"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName InfixConvertSuffix</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/8/29</span></span><br><span class="line"><span class="comment"> * Time      10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfixConvertSuffixDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String infixExpression = <span class="string">"( 1 + ( ( 2 + 3 ) × 4 ) ) - 5 "</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = calc(infixExpression);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最终结果::"</span>);</span><br><span class="line">        list.forEach(System.out::print);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">calc</span><span class="params">( String infixExpression)</span></span>&#123;</span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">//运算符</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//操作符</span></span><br><span class="line"></span><br><span class="line">        String[] split = infixExpression.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(split);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"("</span>.equals(item))&#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">")"</span>.equals(item))&#123;</span><br><span class="line">                System.out.println(<span class="string">"右括号"</span>);</span><br><span class="line">                <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止</span></span><br><span class="line">                <span class="comment">//将这一对括号丢弃</span></span><br><span class="line">                String curItem = s1.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!<span class="string">"("</span>.equals(curItem))&#123;</span><br><span class="line">                    s2.add(curItem);</span><br><span class="line">                    curItem = s1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//操作数</span></span><br><span class="line">                <span class="comment">//如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈</span></span><br><span class="line">                <span class="keyword">if</span> (s1.size() == <span class="number">0</span> || <span class="string">"("</span>.equals(s1.peek()))&#123;</span><br><span class="line">                    s1.push(item);</span><br><span class="line">                &#125;<span class="keyword">else</span>  <span class="keyword">if</span> (priority(item) &gt; priority(s1.peek()))&#123; <span class="comment">//否则，若优先级比栈顶运算符的高，也将运算符压入s1</span></span><br><span class="line"></span><br><span class="line">                    s1.push(item);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* System.out.println("\n======s1========");</span></span><br><span class="line"><span class="comment">            s1.forEach(System.out::print);</span></span><br><span class="line"><span class="comment">            System.out.println("\n======s2========");</span></span><br><span class="line"><span class="comment">            s2.forEach(System.out::print);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"+"</span>.equals(val) ||  <span class="string">"-"</span>.equals(val) || <span class="string">"×"</span>.equals(val) || <span class="string">"/"</span>.equals(val)</span><br><span class="line">                || <span class="string">"("</span>.equals(val)|| <span class="string">")"</span>.equals(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级由程序员确定，使用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，则优先级越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="string">"×"</span>.equals(oper) || <span class="string">"/"</span>.equals(oper))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"+"</span>.equals(oper) || <span class="string">"-"</span>.equals(oper))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定目前的表达式只有+，-，*，/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1567049345720" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567049345720.png" class="lazyload"></p>
<h1 id="四、递归"><a href="#四、递归" class="headerlink" title="四、递归"></a>四、递归</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p><strong>递归就是方法自己调用自己,每次调用时传入不同的变量。</strong> 递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p>
<p><img alt="1568340240264" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1568340240264.png" class="lazyload"></p>
<h2 id="2、遵守规则"><a href="#2、遵守规则" class="headerlink" title="2、遵守规则"></a>2、遵守规则</h2><p>1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</p>
<p>2) 方法的局部变量是独立的，不会相互影响, 比如n变量</p>
<p>3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</p>
<p>4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)</p>
<p>5) 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</p>
<h3 id="递归用于解决什么样的问题"><a href="#递归用于解决什么样的问题" class="headerlink" title="递归用于解决什么样的问题"></a>递归用于解决什么样的问题</h3><p>1)各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)</p>
<p>2)各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</p>
<p>3)将用栈解决的问题–&gt;第归代码比较简洁</p>
<h2 id="3、案例：迷宫回溯"><a href="#3、案例：迷宫回溯" class="headerlink" title="3、案例：迷宫回溯"></a>3、案例：迷宫回溯</h2><h3 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>寻找小球能走的路径</p>
<p><img alt="1569117111168" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569117111168.png" class="lazyload"></p>
<h3 id="2、制定规则"><a href="#2、制定规则" class="headerlink" title="2、制定规则"></a>2、制定规则</h3><ol>
<li>map 表示地图</li>
<li>i,j 表示地图的哪个位置开始出发</li>
<li>如果小球能到map [6] [5] ,这说明通路找到</li>
<li>约定：<br>当 map[i] [j]  为0表示没有走过;当为1表示墙;为2表示通路可以走;3表示该点已经走过，但是走不通</li>
<li>在走迷宫时，需要确定一个策略（方法）:下 -&gt; 右 -&gt; 上 -&gt; 左，如果该点走不通，再回溯</li>
</ol>
<p>大致行走路径如下：</p>
<p><img alt="1569117347949" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569117347949.png" class="lazyload"></p>
<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MiGong</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/22</span></span><br><span class="line"><span class="comment"> * Time      9:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//1表示墙</span></span><br><span class="line">        <span class="comment">//上下全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            map[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[j][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//地图情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : ints) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归回溯，给小球找路</span></span><br><span class="line">        setWay(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出新地图，小球走过，并标识过的递归</span></span><br><span class="line">        <span class="comment">//地图情况</span></span><br><span class="line">        System.out.println(<span class="string">"小球走过，并标识过的递归....."</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : ints) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//如果找到，返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// 1. map 表示地图</span></span><br><span class="line">    <span class="comment">// 2. i,j 表示地图的哪个位置开始出发</span></span><br><span class="line">    <span class="comment">// 3. 如果小球能到map[6][5],这说明通路找到</span></span><br><span class="line">    <span class="comment">// 4.约定：</span></span><br><span class="line">    <span class="comment">// 当map[i][j] 为0表示没有走过，当为1表示墙，为2表示通路可以走</span></span><br><span class="line">    <span class="comment">// 3表示该点已经走过，但是走不通</span></span><br><span class="line">    <span class="comment">// 5. 在走迷宫时，需要确定一个策略（方法）</span></span><br><span class="line">    <span class="comment">// 下 -&gt; 右 -&gt; 上 -&gt; 左，如果该点走不通，再回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;<span class="comment">//通路找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>)&#123;<span class="comment">//如果该点没有走过</span></span><br><span class="line">                <span class="comment">//下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map,i+<span class="number">1</span>,j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点走不通</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//map[i][j] != 0  可能1,2,3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1569117441529" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569117441529.png" class="lazyload"></p>
<h2 id="4、八皇后"><a href="#4、八皇后" class="headerlink" title="4、八皇后"></a>4、八皇后</h2><h3 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<p><img alt="1569120210811" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569120210811.png" class="lazyload"></p>
<p><img alt="1569120218024" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569120218024.png" class="lazyload"></p>
<h3 id="2、思路分析"><a href="#2、思路分析" class="headerlink" title="2、思路分析"></a>2、思路分析</h3><p><strong>八皇后问题算法思路分析</strong></p>
<p>1) 第一个皇后先放第一行第一列</p>
<p>2) 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p>
<p>3) 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p>
<p>4) 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p>
<p>5) 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 【示意图】</p>
<p><strong>说明</strong>：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列</p>
<h3 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Queen8</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/22</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Queen8 queen8 = <span class="keyword">new</span> Queen8();</span><br><span class="line">        queen8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放置第n个皇后</span></span><br><span class="line">    <span class="comment">//注意：check是每一次递归时，都会有8个for循环，因此会有回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == max)&#123; <span class="comment">// n = 8，其实8个皇后就已经放好了</span></span><br><span class="line">            print();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前的皇后n 放到该行的第一列</span></span><br><span class="line">            arr[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n))&#123;<span class="comment">//不冲突</span></span><br><span class="line">                <span class="comment">//接着放n+1个</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，继续执行arr[n] = i;即将第n个皇后，放置在本行的后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们防止第n个皇后，就去检测该皇后是否和前面已经摆放的皇后是否冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == arr[n] <span class="comment">//同一列</span></span><br><span class="line">                    || Math.abs(n - i) == Math.abs(arr[n] - arr[i])<span class="comment">//行差距和列差距相同，则在对角线</span></span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，将皇后摆放的位置打印出来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、排序算法"><a href="#五、排序算法" class="headerlink" title="五、排序算法"></a>五、排序算法</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。<br>排序的分类：</p>
<p>1) 内部排序:<br>指将需要处理的所有数据都加载到内部存储器中进行排序。<br>2) 外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储进行<br>排序。<br>3) 常见的排序算法分类(见下图):</p>
<p><img alt="1569221146552" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569221146552.png" class="lazyload"></p>
<h2 id="2、算法——时间复杂度"><a href="#2、算法——时间复杂度" class="headerlink" title="2、算法——时间复杂度"></a>2、算法——时间复杂度</h2><h3 id="1、介绍-6"><a href="#1、介绍-6" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>度量一个程序(算法)执行时间的两种方法</p>
<p>【1】事后统计的方法：</p>
<p>这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, <strong>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</strong></p>
<p>【2】事前估算的方法：</p>
<p>通过分析某个算法的时间复杂度来判断哪个算法更优.</p>
<h3 id="2、时间频度"><a href="#2、时间频度" class="headerlink" title="2、时间频度"></a>2、时间频度</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p><img alt="1569288482554" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288482554.png" class="lazyload"></p>
<h4 id="忽略常数项"><a href="#忽略常数项" class="headerlink" title="忽略常数项"></a>忽略常数项</h4><p><img alt="1569288739590" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288739590.png" class="lazyload"></p>
<h4 id="忽略低次项"><a href="#忽略低次项" class="headerlink" title="忽略低次项"></a>忽略低次项</h4><p><img alt="1569288758914" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288758914.png" class="lazyload"></p>
<h4 id="忽略系数"><a href="#忽略系数" class="headerlink" title="忽略系数"></a>忽略系数</h4><p><img alt="1569288776795" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288776795.png" class="lazyload"></p>
<h3 id="3、时间复杂度"><a href="#3、时间复杂度" class="headerlink" title="3、时间复杂度"></a>3、时间复杂度</h3><p>【1】一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>【2】T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</p>
<p>【3】计算时间复杂度的方法：</p>
<ul>
<li>用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  =&gt; T(n)=n²+7n+1</li>
<li>修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 =&gt; T(n) = n²</li>
<li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ul>
<h3 id="4、常见"><a href="#4、常见" class="headerlink" title="4、常见"></a>4、常见</h3><p><img alt="1569289528825" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289528825.png" class="lazyload"></p>
<h4 id="1、常数阶"><a href="#1、常数阶" class="headerlink" title="1、常数阶"></a>1、常数阶</h4><p><img alt="1569289932011" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289932011.png" class="lazyload"></p>
<h4 id="2、对数阶"><a href="#2、对数阶" class="headerlink" title="2、对数阶"></a>2、对数阶</h4><p><img alt="1569289945001" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289945001.png" class="lazyload"></p>
<h4 id="3、线性阶"><a href="#3、线性阶" class="headerlink" title="3、线性阶"></a>3、线性阶</h4><p><img alt="1569289962738" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289962738.png" class="lazyload"></p>
<h4 id="4、线性对数阶"><a href="#4、线性对数阶" class="headerlink" title="4、线性对数阶"></a>4、线性对数阶</h4><p><img alt="1569290040306" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290040306.png" class="lazyload"></p>
<h4 id="5、平方阶"><a href="#5、平方阶" class="headerlink" title="5、平方阶"></a>5、平方阶</h4><p><img alt="1569290207259" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290207259.png" class="lazyload"></p>
<h3 id="5、平均和最坏"><a href="#5、平均和最坏" class="headerlink" title="5、平均和最坏"></a>5、平均和最坏</h3><p><img alt="1569290303436" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290303436.png" class="lazyload"></p>
<h2 id="3、空间复杂度"><a href="#3、空间复杂度" class="headerlink" title="3、空间复杂度"></a>3、空间复杂度</h2><p><img alt="1569290526666" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290526666.png" class="lazyload"></p>
<h2 id="4、冒泡排序"><a href="#4、冒泡排序" class="headerlink" title="4、冒泡排序"></a>4、冒泡排序</h2><h3 id="1、介绍-7"><a href="#1、介绍-7" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><img alt="1569293021430" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569293021430.png" class="lazyload"></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img alt="1569293098871" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569293098871.png" class="lazyload"></p>
<p>代码如下：优化了规则(3)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BubbleSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/24</span></span><br><span class="line"><span class="comment"> * Time      10:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retSort</span><span class="params">(<span class="keyword">int</span>[] vals)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标识变量，表示是否变换</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.length - <span class="number">1</span>; i++) &#123; <span class="comment">//趟数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vals.length - i -<span class="number">1</span>; j++) &#123; <span class="comment">//需要比较的次数</span></span><br><span class="line">                <span class="keyword">if</span> (vals[j] &gt; vals[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = vals[j];</span><br><span class="line">                    vals[j] = vals[j+<span class="number">1</span>];</span><br><span class="line">                    vals[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟的数据为："</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : vals) &#123;</span><br><span class="line">                System.out.print(val + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!flag)&#123; <span class="comment">//在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">                System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟没有交换，结束"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;<span class="comment">//每趟重置flag，进行下次判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] vals = &#123;<span class="number">35</span>,<span class="number">88</span>,<span class="number">16</span>,<span class="number">27</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">79</span>&#125;;</span><br><span class="line">        retSort(vals);</span><br><span class="line">        System.out.println(Arrays.toString(vals));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1569309952415" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569309952415.png" class="lazyload"></p>
<h2 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1569310313714" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569310313714.png" class="lazyload"></p>
<h4 id="选择排序思路图"><a href="#选择排序思路图" class="headerlink" title="选择排序思路图"></a>选择排序思路图</h4><p><img alt="1569311330048" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569311330048.png" class="lazyload"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName SelectSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/24</span></span><br><span class="line"><span class="comment"> * Time      15:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] vals)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//存储临时值</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;<span class="comment">//存储最小索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.length -<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= vals.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(vals[min] &gt; vals[j]) &#123;</span><br><span class="line">                   min = j;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min != i)&#123; <span class="comment">//有变化</span></span><br><span class="line">                temp = vals[i];</span><br><span class="line">                vals[i] = vals[min];</span><br><span class="line">                vals[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟的数据为："</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : vals) &#123;</span><br><span class="line">                System.out.print(val + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] vals = &#123;<span class="number">35</span>,<span class="number">88</span>,<span class="number">16</span>,<span class="number">27</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">79</span>&#125;;</span><br><span class="line">        selectSort(vals);</span><br><span class="line">        System.out.println(Arrays.toString(vals));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果如下：</p>
<p><img alt="1569313443501" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569313443501.png" class="lazyload"></p>
<h2 id="6、插入排序"><a href="#6、插入排序" class="headerlink" title="6、插入排序"></a>6、插入排序</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1569375679910" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569375679910.png" class="lazyload"></p>
<h4 id="插入排序思路图"><a href="#插入排序思路图" class="headerlink" title="插入排序思路图"></a>插入排序思路图</h4><p><img alt="1569375691590" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569375691590.png" class="lazyload"></p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName InsertSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/24</span></span><br><span class="line"><span class="comment"> * Time      16:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//待插入的数</span></span><br><span class="line">            <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line">            <span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">            <span class="comment">// 说明</span></span><br><span class="line">            <span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">            <span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">            <span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">            <span class="comment">//原理：从待插入数的前一个开始依次向前找，找到insertVal &gt; arr[insertIndex] 就结束</span></span><br><span class="line">            <span class="keyword">while</span>(insertIndex &gt;=<span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex])&#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当退出while循环时，说明插入位置找到，insertIndex+1</span></span><br><span class="line">            arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            <span class="comment">//这里我们判断是否需要赋值</span></span><br><span class="line">            <span class="keyword">if</span>(insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟的数据为："</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">17</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">20</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="1569377419326" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569377419326.png" class="lazyload"></p>
<blockquote>
<p>结论：当需要插入的数是较小的时候，后移的次数明显增多，对效率有影响。</p>
</blockquote>
<h2 id="7、希尔排序"><a href="#7、希尔排序" class="headerlink" title="7、希尔排序"></a>7、希尔排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>简单插入排序存在的问题</p>
<p>我们看简单的插入排序可能存在的问题.<br>数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：<br>{2,3,4,5,6,6}<br>{2,3,4,5,5,6}<br>{2,3,4,4,5,6}<br>{2,3,3,4,5,6}<br>{2,2,3,4,5,6}<br>{1,2,3,4,5,6}</p>
<blockquote>
<p>*<em>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</em>。</p>
</blockquote>
<h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1569458492283" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569458492283.png" class="lazyload"></p>
<p><img alt="1569459476636" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569459476636.png" class="lazyload"></p>
<h3 id="交换法"><a href="#交换法" class="headerlink" title="交换法"></a>交换法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ShellSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/26</span></span><br><span class="line"><span class="comment"> * Time      8:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> gap = arr.length /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//以下就是个内排序（插入是开头连续排序的，二希尔是步长跳跃排序的）</span></span><br><span class="line">            <span class="comment">//有点类似冒泡</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(gap + "::" + j);</span></span><br><span class="line">                    <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                        temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j + gap];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            gap = gap/<span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">"本趟的数据为："</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移动法"><a href="#移动法" class="headerlink" title="移动法"></a>移动法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ShellSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/26</span></span><br><span class="line"><span class="comment"> * Time      8:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">                        <span class="comment">//移动</span></span><br><span class="line">                        arr[j] = arr[j-gap];</span><br><span class="line">                        <span class="comment">// 只不过不是连续的，需要gap步长 和插入稍有区别</span></span><br><span class="line">                        j -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        shellSort2(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1570776568054" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1570776568054.png" class="lazyload"></p>
<h2 id="8、快速排序"><a href="#8、快速排序" class="headerlink" title="8、快速排序"></a>8、快速排序</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>​        快速排序（Quicksort）是对<span style="color:red"><strong>冒泡排序的一种改进</strong></span>。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>快速排序法示意图:</p>
<p>以11为基准，随机选取</p>
<p><img alt="1571446578900" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571446578900.png" class="lazyload"></p>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>对 [-9,78,0,23,-567,70] 进行从小到大的排序，要求使用快速排序法</p>
<p><img alt="1571446659266" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571446659266.png" class="lazyload"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName QuickSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/14</span></span><br><span class="line"><span class="comment"> * Time      9:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left; <span class="comment">//左下标</span></span><br><span class="line">        <span class="keyword">int</span> r = right; <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line">        <span class="comment">//比pivot 值大放到右边</span></span><br><span class="line">        <span class="keyword">while</span>( l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span>( arr[l] &lt; pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line">            <span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line">            <span class="keyword">if</span>( l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"本趟的数据为："</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">70</span>&#125;;</span><br><span class="line">        QuickSort.quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9、归并排序"><a href="#9、归并排序" class="headerlink" title="9、归并排序"></a>9、归并排序</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>​            归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><img alt="1571449056725" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449056725.png" class="lazyload"></p>
<h4 id="合并思想"><a href="#合并思想" class="headerlink" title="合并思想"></a>合并思想</h4><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p>
<p>arr[i] &lt; arr[j]的情况</p>
<p><img alt="1571449128168" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449128168.png" class="lazyload"></p>
<p>arr[i] &gt; arr[j]的情况</p>
<p><img alt="1571449134754" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449134754.png" class="lazyload"></p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MergeSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/19</span></span><br><span class="line"><span class="comment"> * Time      9:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分+合方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   中建索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  中转数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">//初始化j, 右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]</span></span><br><span class="line">        <span class="comment">//先把左右两边有序的数据按照规则填充到temp数组中</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">            <span class="comment">//然后 t++, i++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j])&#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]</span></span><br><span class="line">        <span class="comment">//有一边有剩余，将剩余的依次全部填充到temp数组中去</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid) &#123; <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( j &lt;= right) &#123; <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr中</span></span><br><span class="line">        <span class="comment">//注意，并不是每次都拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLeft = left; <span class="comment">//</span></span><br><span class="line">        <span class="comment">//第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span></span><br><span class="line">        <span class="comment">//最后一次 tempLeft = 0  right = 7</span></span><br><span class="line">        System.out.println(<span class="string">"tempLeft::"</span> + tempLeft + <span class="string">" right::"</span> +right);</span><br><span class="line">        <span class="keyword">while</span>(tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            tempLeft += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">//归并排序需要一个额外空间</span></span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1571449674523" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449674523.png" class="lazyload"></p>
<h2 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</p>
</li>
<li><p>基数排序(Radix Sort)是桶排序的扩展</p>
</li>
<li><p>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
</li>
</ol>
<h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>​        将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p>{53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序</p>
<p>轮数与最高位数有关，最高三位则需要三轮，以此类推</p>
<p><strong>第一轮</strong></p>
<p><img alt="1571453587415" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571453587415.png" class="lazyload"></p>
<p><strong>第二轮</strong></p>
<p><img alt="1571453635718" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571453635718.png" class="lazyload"></p>
<p><strong>第三轮</strong></p>
<p><img alt="1571453647260" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571453647260.png" class="lazyload"></p>
<h3 id="代码实现（自己实现）"><a href="#代码实现（自己实现）" class="headerlink" title="代码实现（自己实现）"></a>代码实现（自己实现）</h3><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName RadixSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/19</span></span><br><span class="line"><span class="comment"> * Time      10:06</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int wanWei=num/10000;</span></span><br><span class="line"><span class="comment"> *     int qianWei=num%10000/1000;</span></span><br><span class="line"><span class="comment"> *     int baiWei=num%1000/100;</span></span><br><span class="line"><span class="comment"> *     int shiWei=num%100/10;</span></span><br><span class="line"><span class="comment"> *     int geWei=num%10;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> arr[][])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  递归方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> num,<span class="keyword">int</span> sum,<span class="keyword">int</span>[][] bucket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">3</span>) <span class="comment">//[0]达到最高位时结束递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]清空bucket</span></span><br><span class="line">        clear(bucket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要维护每个桶中有多少元素，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]按照位数放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = arr[i] % num / (num / <span class="number">10</span>);  <span class="comment">//确定位数</span></span><br><span class="line">            bucket[v][bucketElementCounts[v]] = arr[i]; <span class="comment">//根据位数放入值，</span></span><br><span class="line">            bucketElementCounts[v] += <span class="number">1</span>;<span class="comment">//桶里放值 +1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int[] b : bucket)</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(b));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(bucketElementCounts));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]将桶中数据依次copy会arr中</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123; <span class="comment">//桶个数循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketElementCounts[i]; j++) &#123; <span class="comment">//每桶的总个数循环</span></span><br><span class="line">                arr[index] = bucket[i][j];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"每次位数排序后arr结果："</span>+Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        sum++;</span><br><span class="line">        <span class="comment">//[4]递归</span></span><br><span class="line">        radix(arr,num * <span class="number">10</span> ,sum,bucket);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//最高位数index 即需要几轮排序</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        radix(arr,<span class="number">10</span>,sum,bucket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName RadixSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/19</span></span><br><span class="line"><span class="comment"> * Time      10:06</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int wanWei=num/10000;</span></span><br><span class="line"><span class="comment"> *     int qianWei=num%10000/1000;</span></span><br><span class="line"><span class="comment"> *     int baiWei=num%1000/100;</span></span><br><span class="line"><span class="comment"> *     int shiWei=num%100/10;</span></span><br><span class="line"><span class="comment"> *     int geWei=num%10;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> arr[][])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  非递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   原数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num   除余的基数10</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum   循环的最高位数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> num,<span class="keyword">int</span> sum,<span class="keyword">int</span>[][] bucket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> max = <span class="number">0</span>; max &lt; sum; max++) &#123;</span><br><span class="line">            num = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,(max+<span class="number">1</span>));<span class="comment">// 10 100 1000</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">            <span class="comment">//[1]清空bucket</span></span><br><span class="line">            clear(bucket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要维护每个桶中有多少元素，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">            <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//[2]按照位数放入桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = arr[i] % num / (num / <span class="number">10</span>);  <span class="comment">//确定位数</span></span><br><span class="line">                bucket[v][bucketElementCounts[v]] = arr[i]; <span class="comment">//根据位数放入值，</span></span><br><span class="line">                bucketElementCounts[v] += <span class="number">1</span>;<span class="comment">//桶里放值 +1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//[3]将桶中数据依次copy会arr中</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123; <span class="comment">//桶个数循环</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketElementCounts[i]; j++) &#123; <span class="comment">//每桶的总个数循环</span></span><br><span class="line">                    arr[index] = bucket[i][j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"每次位数排序后arr结果："</span>+Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        radix2(arr,<span class="number">10</span>,<span class="number">3</span>,bucket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>基数排序是对传统桶排序的扩展，<strong>速度很快.</strong></li>
<li><strong>基数排序是经典的空间换时间的方式</strong>，<strong>占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError</strong> 。例如：int[] arr = new int[8000000]， 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </li>
<li>基数排序时稳定的。[ 注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的 ]</li>
<li>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a> </li>
</ol>
<h2 id="排序算法对比"><a href="#排序算法对比" class="headerlink" title="排序算法对比"></a>排序算法对比</h2><p><img alt="1571552208801" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571552208801.png" class="lazyload"></p>
<p><strong>相关术语解释：</strong></p>
<p>[1] 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br>[2] 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；<br>[3] 内排序：所有排序操作都在内存中完成；<br>[4] 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p>[5] 时间复杂度： 一个算法执行所耗费的时间。<br>[6] 空间复杂度：运行完一个程序所需内存的大小。<br>[7] n: 数据规模<br>[8] k: “桶”的个数<br>[9] In-place:    不占用额外内存<br>[10] Out-place: 占用额外内存</p>
<h1 id="六、查找算法"><a href="#六、查找算法" class="headerlink" title="六、查找算法"></a>六、查找算法</h1><h2 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h2><p>在java中，我们常用的查找有四种:<br>    1) 顺序(线性)查找<br>    2) 二分查找/折半查找<br>   3) 插值查找<br>   4) 斐波那契查找</p>
<h2 id="1、线性查找"><a href="#1、线性查找" class="headerlink" title="1、线性查找"></a>1、线性查找</h2><p>逐一比对，发现相同值就返回下标</p>
<p><img alt="1571552672463" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571552672463.png" class="lazyload"></p>
<h2 id="2、折半查找"><a href="#2、折半查找" class="headerlink" title="2、折半查找"></a>2、折半查找</h2><p>请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。</p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            System.out.println(<span class="string">"not find..."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; arr[mid])&#123; <span class="comment">//左递归</span></span><br><span class="line"><span class="comment">//            right = mid - 1 ;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, left, mid, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; arr[mid])&#123; <span class="comment">//右递归</span></span><br><span class="line"><span class="comment">//            left = mid + 1;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, mid, right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"find index::"</span>+mid);</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        binary(arr,<span class="number">0</span>,arr.length,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.</p>
<p>思路：</p>
<p>已知找到1000的索引位置，数组也是有序的，那么分别向左和向右遍历，相同就记录下来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            System.out.println(<span class="string">"not find..."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; arr[mid])&#123; <span class="comment">//左递归</span></span><br><span class="line"><span class="comment">//            right = mid - 1 ;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, left, mid, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; arr[mid])&#123; <span class="comment">//右递归</span></span><br><span class="line"><span class="comment">//            left = mid + 1;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, mid, right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"find index::"</span>+mid);</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成一个课后思考题:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment">     * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">search</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; idx = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       idx.add(index);<span class="comment">//本身找到的index位置也要放入</span></span><br><span class="line">       <span class="keyword">int</span> left_temp = index - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//向左遍历</span></span><br><span class="line">       <span class="keyword">while</span> (left_temp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val == arr[left_temp])&#123;</span><br><span class="line">               idx.add(left_temp);</span><br><span class="line">               left_temp--;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> right_temp = index + <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//向右遍历</span></span><br><span class="line">       <span class="keyword">while</span> (right_temp&lt;=arr.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val == arr[right_temp])&#123;</span><br><span class="line">               idx.add(right_temp);</span><br><span class="line">               right_temp++;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> idx;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = binary(arr,<span class="number">0</span>,arr.length,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        search(arr,index,<span class="number">1000</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="1571554732074" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571554732074.png" class="lazyload"></p>
<h2 id="3、插值查找"><a href="#3、插值查找" class="headerlink" title="3、插值查找"></a>3、插值查找</h2><h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1571555508408" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571555508408.png" class="lazyload"></p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName InsertSearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编写插值查找算法</span></span><br><span class="line">    <span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插值查找次数~~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line">        <span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出mid, 自适应</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>,<span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">1234</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、斐波那契查找"><a href="#4、斐波那契查找" class="headerlink" title="4、斐波那契查找"></a>4、斐波那契查找</h2><h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1571556883869" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571556883869.png" class="lazyload"></p>
<h3 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h3><p>先将数组扩展成符合斐波那契形式，然后按照斐波那契的分割方式来确定mid</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName FibonacciSearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line">    <span class="comment">//非递归方法得到一个斐波那契数列   1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ........</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写斐波那契查找算法</span></span><br><span class="line">    <span class="comment">//使用非递归的方式编写算法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a  数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//存放mid值</span></span><br><span class="line">        <span class="keyword">int</span> f[] = fib(); <span class="comment">//获取到斐波那契数列</span></span><br><span class="line">        <span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">        <span class="comment">//不足的部分会使用0填充</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">        <span class="comment">//实际上需求使用a数组最后的数填充 temp</span></span><br><span class="line">        <span class="comment">//举例:</span></span><br><span class="line">        <span class="comment">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = a[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为甚是 k--</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line">                <span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line">                <span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line">                <span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k -=2</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line">                <span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span></span><br><span class="line">                <span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line">                <span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line">                <span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"index="</span> + fibSearch(arr, <span class="number">89</span>));<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七、哈希表"><a href="#七、哈希表" class="headerlink" title="七、哈希表"></a>七、哈希表</h1><h2 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p><strong>哈希表存放在内存中，速度快</strong></p>
<p><img alt="1571559206279" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571559206279.png" class="lazyload"></p>
<p>缓存层的意义<br><img alt="1571559452930" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571559452930.png" class="lazyload"></p>
<h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p><img alt="1571622722516" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571622722516.png" class="lazyload"></p>
<h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.</p>
<p>要求: 不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)</p>
<h2 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1、Emp对象"><a href="#1、Emp对象" class="headerlink" title="1、Emp对象"></a>1、Emp对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Emp</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Emp&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、EmpLinkedList"><a href="#2、EmpLinkedList" class="headerlink" title="2、EmpLinkedList"></a>2、EmpLinkedList</h3><p>每条索引的链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName EmpLinkedList</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp</span></span><br><span class="line">    <span class="comment">//private Emp head; //默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用java的LinkedList</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Emp&gt; empLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员到链表</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line">    <span class="comment">//   因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        empLinkedList.add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">find</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : empLinkedList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (findId == emp.getId())&#123;</span><br><span class="line">                <span class="keyword">return</span> emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : empLinkedList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (findId == emp.getId())&#123;</span><br><span class="line">                empLinkedList.remove(emp);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : empLinkedList)&#123;</span><br><span class="line">            System.out.print(emp.toString() + <span class="string">'\t'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、HashTab"><a href="#3、HashTab" class="headerlink" title="3、HashTab"></a>3、HashTab</h3><p>创建HashTab，包含所有的EmpLinkedList的头信息组成的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HashTab</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:15</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建HashTab 管理多条链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化empLinkedListArray</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写散列函数, 使用一个简单取模法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据员工的id ,得到该员工应当添加到哪条链表</span></span><br><span class="line">        <span class="keyword">int</span> id = emp.getId();</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(id);</span><br><span class="line">        empLinkedListArray[index].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">find</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(findId);</span><br><span class="line">        Emp emp = empLinkedListArray[index].find(findId);</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(findId);</span><br><span class="line">        <span class="keyword">return</span> empLinkedListArray[index].del(findId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; size;i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">"第"</span>+i+<span class="string">"条::"</span>);</span><br><span class="line">            empLinkedListArray[i].list();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//=======================================</span></span><br><span class="line">        HashTab empHashTab = <span class="keyword">new</span> HashTab(<span class="number">4</span>);</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">1</span>,<span class="string">"张三"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">2</span>,<span class="string">"李四"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">3</span>,<span class="string">"王五"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">4</span>,<span class="string">"jack"</span>));</span><br><span class="line"></span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">5</span>,<span class="string">"张三2"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">6</span>,<span class="string">"李四2"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">8</span>,<span class="string">"王五2"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">9</span>,<span class="string">"jack2"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        empHashTab.list();</span><br><span class="line">        empHashTab.del(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        empHashTab.list();</span><br><span class="line">        Emp emp = empHashTab.find(<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        System.out.println(emp.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1571622893210" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571622893210.png" class="lazyload"></p>
<h1 id="八、树结构"><a href="#八、树结构" class="headerlink" title="八、树结构"></a>八、树结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="使用数结构的原因"><a href="#使用数结构的原因" class="headerlink" title="使用数结构的原因"></a>使用数结构的原因</h3><p><img alt="1571642772893" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571642772893.png" class="lazyload"></p>
<p><img alt="1571642788098" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571642788098.png" class="lazyload"></p>
<p><img alt="1571642804730" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571642804730.png" class="lazyload"></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img alt="1571643339729" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571643339729.png" class="lazyload"></p>
<h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><p>1、树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。<br>2、二叉树的子节点分为左节点和右节点。</p>
<p><img alt="image-20191024153847814" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024153847814.png" class="lazyload"></p>
<p>3、如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为<strong>满二叉树</strong>。</p>
<p>4、如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为<strong>完全二叉树（叶子结点连续）</strong>。</p>
<p><img alt="1571643531652" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571643531652.png" class="lazyload"></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>先序遍历：先输出父节点，在遍历左子树和右子树</p>
<p>中序遍历：先遍历左子树，再输出父节点，在遍历右子树</p>
<p>后序遍历：先遍历左子树，再遍历右子树，最后输出父节点</p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>使用前序，中序和后序对下面的二叉树进行遍历.</p>
<p><img alt="1571649194257" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571649194257.png" class="lazyload"></p>
<p><img alt="image-20191024161333744" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024161333744.png" class="lazyload"></p>
<h3 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1、HeroNode对象节点"><a href="#1、HeroNode对象节点" class="headerlink" title="1、HeroNode对象节点"></a>1、HeroNode对象节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HeroNode</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归右字数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="comment">//递归右字数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、BinaryTree类"><a href="#2、BinaryTree类" class="headerlink" title="2、BinaryTree类"></a>2、BinaryTree类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      10:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的结点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="1571813629696" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571813629696.png" class="lazyload"></p>
<h2 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p><img alt="image-20191024154217973" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024154217973.png" class="lazyload"></p>
<h3 id="查找思想"><a href="#查找思想" class="headerlink" title="查找思想"></a>查找思想</h3><p><strong>和遍历类似，只不过将输出段变成查找判断</strong></p>
<p><img alt="image-20191024155817317" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024155817317.png" class="lazyload"></p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preSearch</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line">    <span class="keyword">if</span>(findId == <span class="keyword">this</span>.id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">    <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//[1]递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.left.preSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="keyword">null</span>)&#123;<span class="comment">//左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]递归右子树</span></span><br><span class="line">    <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">    <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.right.preSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixSearch</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">    <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//[1]递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.left.infixSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="keyword">null</span>)&#123;<span class="comment">//左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"进入中序查找"</span>);</span><br><span class="line">    <span class="keyword">if</span>(findId == <span class="keyword">this</span>.id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]递归右子树</span></span><br><span class="line">    <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">    <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.right.infixSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postSearch</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">    <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//[1]递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.left.postSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="keyword">null</span>)&#123;<span class="comment">//左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]递归右子树</span></span><br><span class="line">    <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">    <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.right.postSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line">    <span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">    <span class="keyword">if</span>(findId == <span class="keyword">this</span>.id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="image-20191024160045619" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024160045619.png" class="lazyload"></p>
<h2 id="二叉树删除"><a href="#二叉树删除" class="headerlink" title="二叉树删除"></a>二叉树删除</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>此处的删除要求如下：</p>
<p><img alt="image-20191024162424289" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024162424289.png" class="lazyload"></p>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p><img alt="image-20191024164107290" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024164107290.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">[1] 判断是否为空树 只有一个root节点，置空</span><br><span class="line"></span><br><span class="line">[2] 二叉树是单向，只能借助父节点去删除子节点</span><br><span class="line"></span><br><span class="line">[3] 判断this.left!=null &amp;&amp; this.left.val == id</span><br><span class="line">		this.left = null;</span><br><span class="line">	else 返回</span><br><span class="line"></span><br><span class="line">[4] 判断this.right!=null &amp;&amp; this.right.val == id</span><br><span class="line">		this.right = null;</span><br><span class="line">	else 返回</span><br><span class="line">	</span><br><span class="line">[5] 没删除节点 继续递归[3] 和 [4]</span><br></pre></td></tr></table></figure>



<h3 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="HeroNode类"><a href="#HeroNode类" class="headerlink" title="HeroNode类"></a>HeroNode类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -------------------------删除--------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//递归删除结点</span></span><br><span class="line"><span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">			5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.id == findId)&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.id == findId)&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.delNode(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.delNode(findId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BinaryTree"><a href="#BinaryTree" class="headerlink" title="BinaryTree"></a>BinaryTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(root.getId() == findId)&#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.delNode(findId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"空树，不能删除"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Test类"><a href="#Test类" class="headerlink" title="Test类"></a>Test类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------删除节点-----------------------------</span></span><br><span class="line">System.out.println(<span class="string">"删除前..................."</span>);</span><br><span class="line">binaryTree.preOrder();<span class="comment">//1,2,3,5,4</span></span><br><span class="line"><span class="comment">//        binaryTree.delNode(5);</span></span><br><span class="line">binaryTree.delNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除后..................."</span>);</span><br><span class="line">binaryTree.preOrder();<span class="comment">//1,2,3,4</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191024171717983" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024171717983.png" class="lazyload"></p>
<h2 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h2><h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><p>数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看示意图。</p>
<p><strong>顺序存储二叉树的特点:</strong></p>
<p>[1] 顺序二叉树通常只考虑完全二叉树<br>[2] 第n个元素的左子节点为  2 * n + 1<br>[3] 第n个元素的右子节点为  2 * n + 2<br>[4] 第n个元素的父节点为  (n-1) / 2</p>
<p>[5] n : 表示二叉树中的第几个元素(按0开始编号如图所示)</p>
<p><img alt="image-20191104082544384" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104082544384.png" class="lazyload"></p>
<p>要求:<br>[1] 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]<br>[2] 要求在遍历数组 arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</p>
<h3 id="案例：顺序存储二叉树遍历"><a href="#案例：顺序存储二叉树遍历" class="headerlink" title="案例：顺序存储二叉树遍历"></a>案例：顺序存储二叉树遍历</h3><h4 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h4><p>​     给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为 1,2,4,5,3,6,7</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ArrBinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/4</span></span><br><span class="line"><span class="comment"> * Time      8:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载preOrder方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成顺序存储的前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"数组为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(arr[index]+ <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span>*index + <span class="number">1</span>) &lt; arr.length)&#123;<span class="comment">//防止越界</span></span><br><span class="line">            preOrder(<span class="number">2</span>*index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span>*index + <span class="number">2</span>) &lt; arr.length) &#123;<span class="comment">//防止越界</span></span><br><span class="line">            preOrder(<span class="number">2</span>*index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr  = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line"></span><br><span class="line">        arrBinaryTree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191104084009952" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104084009952.png" class="lazyload"></p>
<h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7</p>
<p><img alt="image-20191104085623151" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104085623151.png" class="lazyload"></p>
<p>问题分析:<br>【1】当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }<br>【2】但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.<br>【3】如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?<br>【4】解决方案-线索二叉树</p>
<h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><p>【1】<strong>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。</strong>利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</p>
<p>【2】这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</p>
<p>【3】一个结点的前一个结点，称为前驱结点<br>【4】一个结点的后一个结点，称为后继结点</p>
<h3 id="案例：中序线索二叉树"><a href="#案例：中序线索二叉树" class="headerlink" title="案例：中序线索二叉树"></a>案例：中序线索二叉树</h3><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p><img alt="image-20191104090138746" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104090138746.png" class="lazyload"></p>
<p><img alt="image-20191104090221207" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104090221207.png" class="lazyload"></p>
<p><strong>说明: 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况:</strong><br>【1】 left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.<br>【3】right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="HeroNode"><a href="#HeroNode" class="headerlink" title="HeroNode"></a>HeroNode</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HeroNode</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">// leftType == 0 表示指向左子树    1 表示前驱节点</span></span><br><span class="line">    <span class="comment">// rightType == 0 表示指向右子树    1 表示后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="ThreadedBinaryTree"><a href="#ThreadedBinaryTree" class="headerlink" title="ThreadedBinaryTree"></a>ThreadedBinaryTree</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建给当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNode</span><span class="params">(HeroNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果node==null 不能线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一、先线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//二、线索化当前节点</span></span><br><span class="line">        <span class="comment">//先处理当前节点的前驱节点</span></span><br><span class="line">        <span class="comment">//以8节点来理解</span></span><br><span class="line">        <span class="comment">//8节点的left指向空</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前节点的做指针类型</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在处理当前节点的后继节点  利用下次的节点来指向</span></span><br><span class="line">        <span class="comment">//以3节点来理解	pre为8节点，将8节点的右边指向当前3节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//让前驱节点的有指针指向当前节点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱节点的有指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//三、线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ThreadedBinaryTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/4</span></span><br><span class="line"><span class="comment"> * Time      9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试中序线索二叉树</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"jack"</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"smith"</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"marry"</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"king"</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"dim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中序线索化</span></span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试: 以10号节点测试</span></span><br><span class="line">        HeroNode leftNode = node5.getLeft();</span><br><span class="line">        HeroNode rightNode = node5.getRight();</span><br><span class="line">        System.out.println(<span class="string">"10号结点的前驱结点是 ="</span>  + leftNode); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">"10号结点的后继结点是="</span>  + rightNode); <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191104145623072" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104145623072.png" class="lazyload"></p>
<h3 id="遍历线索化二叉树（中序）"><a href="#遍历线索化二叉树（中序）" class="headerlink" title="遍历线索化二叉树（中序）"></a>遍历线索化二叉树（中序）</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>[1]从根开始遍历左节点，当leftType == 1时，结束遍历</p>
<p>[2] 打印当前节点</p>
<p>[3]查看当前节点是否有后继节点 rightType == 1，若有，node = node.getRight();进入下一个循环[2]</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p><span style="color:red">在上述案例的基础进行的改进</span></p>
<h5 id="ThreadedBinaryTree类"><a href="#ThreadedBinaryTree类" class="headerlink" title="ThreadedBinaryTree类"></a>ThreadedBinaryTree类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建给当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化是，pre总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//*****遍历线索化二叉树的方法***************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line"></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span>( node!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType == 1 的结点，第一个找到就是8节点</span></span><br><span class="line">            <span class="comment">//后面随着遍历二变化，因为当leftType == 1时，说明该节点是按照线索化</span></span><br><span class="line">            <span class="comment">// 处理后的有效节点</span></span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印当前这个节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前节点的有指针指向的是后继节点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//获取当前节点的后继节点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//替换这个遍历的节点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line">	..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ThreadedBinaryTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/4</span></span><br><span class="line"><span class="comment"> * Time      9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">        ...............</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线索化二叉树后，能在使用原来的遍历方法</span></span><br><span class="line">        <span class="comment">//threadedBinaryTree.infixOrder();</span></span><br><span class="line">        System.out.println(<span class="string">"使用线索化的方式遍历 线索化二叉树"</span>);</span><br><span class="line">        threadedBinaryTree.threadedList(); <span class="comment">// 8, 3, 10, 1, 14, 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="九、树结构实际应用"><a href="#九、树结构实际应用" class="headerlink" title="九、树结构实际应用"></a>九、树结构实际应用</h1><h2 id="1、堆排序"><a href="#1、堆排序" class="headerlink" title="1、堆排序"></a>1、堆排序</h2><h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h3><p>【1】堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
<p>【2】堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
<p>【3】每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
<p>【4】大顶堆举例说明</p>
<p><img alt="image-20191104154231817" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104154231817.png" class="lazyload"></p>
<p>【5】小顶堆：<code>arr[i] &lt;= arr[2*i+1] &amp;&amp; arr[i] &lt;= arr[2*i+2] // i对应第几个节点</code>，i从0开始编号</p>
<p>大顶堆：<code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code></p>
<p>【6】<strong>一般升序采用大顶堆，降序采用小顶堆</strong> </p>
<p><img alt="image-20191104162430134" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104162430134.png" class="lazyload"></p>
<h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>堆排序的基本思想是：<br>【1】将待排序序列构造成一个大顶堆<br>【2】此时，整个序列的最大值就是堆顶的根节点。<br>【3】将其与末尾元素进行交换，此时末尾就为最大值。<br>【4】然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p> <img alt="img" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20180908013007479.gif" class="lazyload"> </p>
<h3 id="堆排序步骤"><a href="#堆排序步骤" class="headerlink" title="堆排序步骤"></a>堆排序步骤</h3><h4 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h4><p>构造初始堆，将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆）</p>
<p>原始数组 [ 4 , 6 , 8 , 5 , 9 ]</p>
<p>【1】假设给定无序序列如下</p>
<img alt="image-20191105093113140" style="zoom:80%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093113140.png" class="lazyload">

<p>【2】此时我们从最后一个非叶子节点开始（叶子结点不用调整，第一个非叶子节点公式：arr.length / 2 - 1 = 5 / 2 - 1 = 1,6节点）。从左至右，从下至上进行调整</p>
<p><img alt="image-20191105093257906" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093257906.png" class="lazyload"></p>
<p>【3】找到第二个非叶子节点4，由于[ 4 , 8 , 9 ] 中9最大，4和9交换</p>
<p><img alt="image-20191105093434647" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093434647.png" class="lazyload"></p>
<p>【4】交换导致子根[ 4 , 5 , 6 ]结构混乱，继续调整，[ 4 , 5 , 6 ] 中 6 最大，交换 4 和 6</p>
<p><img alt="image-20191105093538603" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093538603.png" class="lazyload"></p>
<p>此时，无序序列改造成了一个大顶堆</p>
<h4 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h4><p>将堆顶元素与莫为元素进行交换，是末尾元素最大，然后继续调整堆，再将堆顶元素与莫为元素交换，得到第二大元素，反复进行交换、重建、交换</p>
<p>【1】将堆顶元素9和末尾元素4进行交换</p>
<p><img alt="image-20191105093758144" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093758144.png" class="lazyload"></p>
<p>【2】重建</p>
<p><img alt="image-20191105093825948" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093825948.png" class="lazyload"></p>
<p>【3】8和5交换</p>
<p><img alt="image-20191105093845108" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093845108.png" class="lazyload"></p>
<p>【4】反复继续</p>
<img alt="image-20191105093911918" style="zoom:80%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093911918.png" class="lazyload">







<h3 id="代码——大顶堆升序"><a href="#代码——大顶堆升序" class="headerlink" title="代码——大顶堆升序"></a>代码——大顶堆升序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HeapSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/5</span></span><br><span class="line"><span class="comment"> * Time      8:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"堆排序!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        //分步完成</span></span><br><span class="line"><span class="comment">        adjustHeap(arr,1,arr.length);</span></span><br><span class="line"><span class="comment">        System.out.println("第一次" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //分步完成</span></span><br><span class="line"><span class="comment">        adjustHeap(arr,0,arr.length);</span></span><br><span class="line"><span class="comment">        System.out.println("第二次" + Arrays.toString(arr));*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成我们最终代码</span></span><br><span class="line">        <span class="comment">//[1] 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组:"</span> + Arrays.toString(arr)); <span class="comment">//大顶堆</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*[2]</span></span><br><span class="line"><span class="comment">		 * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment">　　	 * 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length-<span class="number">1</span>;j &gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"数组="</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个数组，调整成一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：完成 将以i 指向的对应的非叶子节点的树，调整成大顶堆</span></span><br><span class="line"><span class="comment">     * 举例  int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125;</span></span><br><span class="line"><span class="comment">     * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   待调整数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i     表示非叶子节点索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   表示对多少个元素进行调整，逐渐减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">// 先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="comment">//开始调整</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>;k &lt; len;k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( k+<span class="number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>])&#123;<span class="comment">////说明左子结点的值小于右子结点的值</span></span><br><span class="line">                k++; <span class="comment">//k 指向右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; temp)&#123; <span class="comment">//如果子结点大于父结点</span></span><br><span class="line">                arr[i] = arr[k]; <span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">                i = k; <span class="comment">//!!! i 指向 k,继续循环比较</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">        System.out.println(<span class="string">"adjustHeap::数组="</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//要求将数组进行升序排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、赫夫曼树"><a href="#2、赫夫曼树" class="headerlink" title="2、赫夫曼树"></a>2、赫夫曼树</h2><h3 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h3><p>[1] 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的<strong>带权路径长度(wpl)</strong>达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</p>
<p>[2] 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>1、路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</p>
<p>2、结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</p>
<p>3、树的带权路径长度：<strong>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length)</strong> ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
<p>4、<strong>WPL最小的就是赫夫曼树</strong></p>
<p><img alt="image-20191105100317226" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105100317226.png" class="lazyload"></p>
<h3 id="创建赫夫曼树"><a href="#创建赫夫曼树" class="headerlink" title="创建赫夫曼树"></a>创建赫夫曼树</h3><p>构成赫夫曼树的步骤：</p>
<p>1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树<br>2) 取出根节点权值最小的两颗二叉树<br>3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </p>
<p>4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
<p>案例：</p>
<p>如何构建一颗 赫夫曼树的步骤</p>
<p>13, 7, 8, 3, 29, 6, 1</p>
<p>排序<br>1, 3, 6, 7, 8, 13, 29 </p>
<p><img alt="image-20191105101207134" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105101207134.png" class="lazyload"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.huffmantree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HuffmanTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/5</span></span><br><span class="line"><span class="comment"> * Time      10:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        Node root = createHuffmanTree(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        preOrder(root); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个前序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"是空树，不能遍历~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为了操作方便</span></span><br><span class="line">        <span class="comment">//1、遍历arr数组</span></span><br><span class="line">        <span class="comment">//2、将arr每个元素构成一个Node</span></span><br><span class="line">        <span class="comment">//3、将Node放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : arr)&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排序从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"nodes::"</span> + nodes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//去除根节点全值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">//[1] 取出全值最小的节点</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//[2] 取出全值次小的节点</span></span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//[3]构造一颗新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line"></span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//[4]从arraylist删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//[5]将parent加入arraylist</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"第一次处理后::nodes::"</span> + nodes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回哈夫曼树的root节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结点类</span></span><br><span class="line"><span class="comment">// 为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">// 让Node 实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123; <span class="comment">//理论上不打印和的节点</span></span><br><span class="line">            System.out.print(<span class="keyword">this</span> + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"value="</span> + value +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191105103436932" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105103436932.png" class="lazyload"></p>
<h2 id="3、赫夫曼编码"><a href="#3、赫夫曼编码" class="headerlink" title="3、赫夫曼编码"></a>3、赫夫曼编码</h2><h3 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h3><p>[1] 赫夫曼编码也翻译为    哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法<br>[2] 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</p>
<p>[3] 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间<br>[4] 赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img alt="image-20191106090353546" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090353546.png" class="lazyload"></p>
<p><img alt="image-20191106090500829" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090500829.png" class="lazyload"></p>
<p><img alt="image-20191106090538052" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090538052.png" class="lazyload"></p>
<h3 id="赫夫曼编码步骤"><a href="#赫夫曼编码步骤" class="headerlink" title="赫夫曼编码步骤"></a>赫夫曼编码步骤</h3><h4 id="1、构成赫夫曼树"><a href="#1、构成赫夫曼树" class="headerlink" title="1、构成赫夫曼树"></a>1、构成赫夫曼树</h4><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>1) i like like like java do you like a java    </p>
<p>2)  d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数</p>
<p>3)  按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 </p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>构成赫夫曼树的步骤：</p>
<p>1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p>
<p>2) 取出根节点权值最小的两颗二叉树 </p>
<p>3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </p>
<p>4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
<p><img alt="image-20191106090804047" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090804047.png" class="lazyload"></p>
<h4 id="2、规定编码"><a href="#2、规定编码" class="headerlink" title="2、规定编码"></a>2、规定编码</h4><p>【1】根据赫夫曼树，给各个字符,规定编码 (前缀编码)， <strong>向左的路径为0 向右的路径为1</strong> ， 编码如下:<br>o: 1000   u: 10010  d: 100110  y: 100111  i: 101<br>a : 110     k: 1110    e: 1111       j: 0000       v: 0001<br>l: 001          : 01</p>
<p>【2】 按照上面的赫夫曼编码，我们的”i like like like java do you like a java”   字符串对应的编码为 (注意这里我们使用的无损压缩)<br>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110  通过赫夫曼编码处理  长度为  133</p>
<p>【3】 长度为 ： 133<br>说明:<br>原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%<br>此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性<br>赫夫曼编码是无损处理方案</p>
<h3 id="赫夫曼编码与解码"><a href="#赫夫曼编码与解码" class="headerlink" title="赫夫曼编码与解码"></a>赫夫曼编码与解码</h3><h4 id="1、编码"><a href="#1、编码" class="headerlink" title="1、编码"></a>1、编码</h4><p>【1】字符串转成字节数组</p>
<p>【2】将字节数组构建成nodes节点的集合</p>
<p>【3】根据nodes集合创建赫夫曼树</p>
<p>【4】生成赫夫曼编码</p>
<p>【5】压缩赫夫曼编码，形成赫夫曼编码字节数组</p>
<h4 id="2、解码"><a href="#2、解码" class="headerlink" title="2、解码"></a>2、解码</h4><p>【1】赫夫曼编码字节数组转成二进制字符串（赫夫曼编码）</p>
<p>【2】赫夫曼编码key与value对换，反向解码</p>
<p>【3】裁减二进制字符串与赫夫曼编码进行匹配，并将其存入集合中</p>
<p>【4】将集合转成字节数组，最终转成字符数组，解码完成</p>
<h4 id="3、完整代码"><a href="#3、完整代码" class="headerlink" title="3、完整代码"></a>3、完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.huffmancode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HuffmanCode</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/6</span></span><br><span class="line"><span class="comment"> * Time      8:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,Integer&gt; <span class="title">countMap</span><span class="params">(<span class="keyword">byte</span>[] str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Byte,Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;Byte,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!counts.containsKey(str[i]))&#123;</span><br><span class="line">                counts.put(str[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> count = counts.get(str[i]) + <span class="number">1</span>;</span><br><span class="line">                counts.put(str[i],count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计字符出现的次数</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = countMap(bytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每个键值对转成Node对象，并加入到nodes集合</span></span><br><span class="line">        counts.forEach((k,v)-&gt;&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(k,v));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println("nodes::"+nodes);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            Collections.sort(nodes); <span class="comment">//根据node对象的compareTo方法进行排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">            Node left = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第二颗最小的二叉树</span></span><br><span class="line">            Node right = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，根节点没有data，只有权值</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>,left.getWeight() + right.getWeight()  );</span><br><span class="line">            parent.setLeft(left);</span><br><span class="line">            parent.setRight(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将新的二叉树，加入到nodes</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nodes 最后的结点，就是赫夫曼树的根结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路:</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式</span></span><br><span class="line">    <span class="comment">//   生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte, String&gt;  <span class="title">getCode</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.getLeft(),<span class="string">"0"</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.getRight(),<span class="string">"1"</span>, stringBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*huffmanCodes.forEach((k,v)-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(k + "::" + v);</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取编码  拼接编码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node,String code,StringBuilder stringBuilder)</span></span>&#123;</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        <span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//如果node == null不处理</span></span><br><span class="line">            <span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(node.getData() == <span class="keyword">null</span>)&#123; <span class="comment">//非叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    getCodes(node.getLeft(),<span class="string">"0"</span>,stringBuilder2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    getCodes(node.getRight(),<span class="string">"1"</span>,stringBuilder2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">                <span class="comment">//就表示找到某个叶子结点的最后 存字符和编码</span></span><br><span class="line">                huffmanCodes.put(node.getData(),stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCode 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[]</span></span><br><span class="line"><span class="comment">     * 举例： String content = "i like like like java do you like a java"; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100"</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes,Map&lt;Byte, String&gt; huffmanCode)&#123;</span><br><span class="line">        StringBuffer codes = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> v : bytes)&#123;</span><br><span class="line">            codes.append(huffmanCode.get(v));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(codes.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计返回  byte[] huffmanCodeBytes 长度</span></span><br><span class="line">        <span class="comment">//一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(codes.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = codes.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = codes.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; codes.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span>( i+<span class="number">8</span> &gt; codes.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = codes.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = codes.substring(i, i + <span class="number">8</span>); <span class="comment">//每8位取一块放入strByte中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="comment">//[0] 构建node节点的集合</span></span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//[1] 根据 nodes 创建的赫夫曼树</span></span><br><span class="line">        Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//[2] 对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCode(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//[3] 根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把字符串安装指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;String, Byte&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//============================不断增大key 去和 编码key进行匹配==========================================</span></span><br><span class="line">        <span class="comment">//创建要给集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//i 可以理解成就是索引,扫描 stringBuilder</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            Byte b = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">                <span class="comment">//1010100010111...</span></span><br><span class="line">                <span class="comment">//递增的取出 key 1</span></span><br><span class="line">                String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span>(b == <span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配到</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;<span class="comment">//i 直接移动到 count</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"</span></span><br><span class="line">        <span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 传入的 byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用变量保存 b</span></span><br><span class="line">        <span class="keyword">int</span> temp = b; <span class="comment">//将 b 转成 int</span></span><br><span class="line">        <span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>; <span class="comment">//按位与 256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line">        String str = Integer.toBinaryString(temp); <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">"i like like like java do you like a java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes(); <span class="comment">//转成字节数组，字符变成了ASCII码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanZip = huffmanZip(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//40  -&gt;  17    测试</span></span><br><span class="line">        System.out.println(Arrays.toString(huffmanZip) + <span class="string">"长度::"</span> + huffmanZip.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据解压</span></span><br><span class="line">        <span class="keyword">byte</span>[] decode = decode(huffmanCodes, huffmanZip);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> v : decode) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191107091628722" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191107091628722.png" class="lazyload"></p>
<h3 id="压缩-解压文件"><a href="#压缩-解压文件" class="headerlink" title="压缩/解压文件"></a>压缩/解压文件</h3><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建输出流</span></span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//创建文件的输入流</span></span><br><span class="line">    FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        is.read(b);</span><br><span class="line">        <span class="comment">//直接对源文件压缩</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">        <span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">        os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">        <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        <span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">        oos.writeObject(huffmanBytes); <span class="comment">//我们是把</span></span><br><span class="line">        <span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">        <span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">        oos.writeObject(huffmanCodes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            oos.close();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，完成对压缩文件的解压</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义文件输入流</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义一个对象输入流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义文件的输出流</span></span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">            <span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line">            <span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(huffmanCodes.size());</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">            <span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zipFile(<span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\src.txt"</span>,</span><br><span class="line">                <span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\dst.txt"</span>);</span><br><span class="line"></span><br><span class="line">        unZipFile(<span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\dst.txt"</span>,</span><br><span class="line">                <span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\src1.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191107095601709" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191107095601709.png" class="lazyload"></p>
<p><strong>赫夫曼编码压缩文件注意事项</strong></p>
<p>1)如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 [举例压一个 .ppt]</p>
<p>2)赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml文件]</p>
<p>3)如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. </p>
<h2 id="4、二叉排序树-BST"><a href="#4、二叉排序树-BST" class="headerlink" title="4、二叉排序树(BST)"></a>4、二叉排序树(BST)</h2><h3 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h3><p>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><img alt="image-20191107104248819" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191107104248819.png" class="lazyload"></p>
<h3 id="创建-amp-添加"><a href="#创建-amp-添加" class="headerlink" title="创建&amp;添加"></a>创建&amp;添加</h3><h4 id="二叉排序树添加步骤"><a href="#二叉排序树添加步骤" class="headerlink" title="二叉排序树添加步骤"></a>二叉排序树添加步骤</h4><p>1、若该树为空，将其赋给root</p>
<p>2、若该树不为空，判断其值与当前结点值的大小</p>
<p>[2.1] 若 node.val &lt; this.val  ，且node的左节点为空，则接到node.left上</p>
<p>​                若node的左节点不为空，递归左节点</p>
<p>[2.2] 若 node.val &gt; this.val  ，且node的右节点为空，则接到node.right上</p>
<p>​                若node的右节点不为空，递归右节点</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><h5 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Node</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值 和当前子树根节点的值比大小</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt; <span class="keyword">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//node.val &gt; this.val</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BinarySortTree类"><a href="#BinarySortTree类" class="headerlink" title="BinarySortTree类"></a>BinarySortTree类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySortTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOreder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Test-2"><a href="#Test-2" class="headerlink" title="Test"></a>Test</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BinarySortTree root = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : arr) &#123;</span><br><span class="line">            root.add(<span class="keyword">new</span> Node(v));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.infixOreder();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>需要考虑三种情况</p>
<p>1、 删除叶子节点 (比如：2, 5, 9, 12)<br>2、删除只有一颗子树的节点 (比如：1)<br>3、删除有两颗子树的节点. (比如：7, 3，10 )</p>
<p><img alt="image-20191108100157835" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191108100157835.png" class="lazyload"></p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><strong>情况一：删除叶子结点</strong></p>
<p>1、需要先去找到要删除的结点  targetNode</p>
<p>2、找到targetNode 的 父结点 parent </p>
<p>3、确定 targetNode 是 parent的左子结点 还是右子结点</p>
<p>如果targetNode 是 parent的左子结点，parent.left = null</p>
<p>如果targetNode 是 parent的右子结点，parent.right= null</p>
<p><strong>情况二：删除只有一颗子树的结点</strong></p>
<p>1、先去找到要删除的结点  targetNode<br>2、找到targetNode 的 父结点 parent<br>3、确定targetNode 的子结点是左子结点还是右子结点<br>4、targetNode 是 parent 的左子结点还是右子结点<br>5、如果targetNode 有左子结点</p>
<p>[5.1] parent 不为空</p>
<p>如果 targetNode 是 parent 的左子结点，parent.left = targetNode.left;<br>如果 targetNode 是 parent 的右子结点，parent.right = targetNode.left;</p>
<p>[5.2]parent为空</p>
<p>说明当前点是根结点，将左子结点给根结点，root = targetNode.left;</p>
<p>6、如果targetNode 有右子结点</p>
<p>[5.1] parent 不为空</p>
<p>如果 targetNode 是 parent 的左子结点，parent.left = targetNode.right;<br>如果 targetNode 是 parent 的右子结点，parent.right = targetNode.right;</p>
<p>[5.2]parent为空</p>
<p>说明当前点是根结点，将左子结点给根结点，root = targetNode.right;</p>
<p><strong>情况三：删除有两颗子树的结点</strong></p>
<p>1、先去找到要删除的结点  targetNode</p>
<p>2、找到targetNode 的 父结点 parent </p>
<p>3、从targetNode 的右子树找到最小的结点（都比左子树的值大）</p>
<p>4、 用一个临时变量，将 最小结点的值保存 temp = 11</p>
<p>5、删除该最小结点，将当前结点的值换掉，引用不变，targetNode.value = temp</p>
<p>代码见下面</p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>功能：添加 + 删除</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Node</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  查找要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   希望删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="keyword">this</span>.val)&#123; <span class="comment">//找到该节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val)&#123; <span class="comment">//查找的值小于当前的节点，想左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除结点的父结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.val == val) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.val == val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(val); <span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(val); <span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值 和当前子树根节点的值比大小</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt; <span class="keyword">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//node.val &gt; this.val</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BinarySortTree"><a href="#BinarySortTree" class="headerlink" title="BinarySortTree"></a>BinarySortTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySortTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法:</span></span><br><span class="line">    <span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line">    <span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时 target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.val);</span><br><span class="line">        <span class="keyword">return</span> target.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.val == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">                <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.val = minVal;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——左</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点  右——左</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——右</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点 右——右</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOreder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySortTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BinarySortTree root = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : arr) &#123;</span><br><span class="line">            root.add(<span class="keyword">new</span> Node(v));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.infixOreder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        root.delNode(<span class="number">2</span>);</span><br><span class="line">        root.delNode(<span class="number">7</span>);</span><br><span class="line">        root.infixOreder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>中序遍历结果如下：</p>
<p><img alt="image-20191108104604363" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191108104604363.png" class="lazyload"></p>
<h2 id="5、平衡二叉树（AVL）"><a href="#5、平衡二叉树（AVL）" class="headerlink" title="5、平衡二叉树（AVL）"></a>5、平衡二叉树（AVL）</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p><img alt="image-20191109085633702" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109085633702.png" class="lazyload"></p>
<h3 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h3><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</p>
<p>具有以下<strong>特点</strong>：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><h4 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h4><img alt="左旋转" style="zoom:200%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/左旋转.png" class="lazyload">

<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋转的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建新的节点，以当前根节点的值</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">    <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">    newNode.left = left;</span><br><span class="line">    <span class="comment">//把新的结点的右子树设置成带你过去结点的右子树的左子树</span></span><br><span class="line">    newNode.right = right.left;</span><br><span class="line">    <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">    val = right.val;</span><br><span class="line">    <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">    right = right.right;</span><br><span class="line">    <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">    left = newNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h4><p><img alt="image-20191109094557964" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109094557964.png" class="lazyload"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">    newNode.right = right;</span><br><span class="line">    newNode.left = left.right;</span><br><span class="line">    val = left.val;</span><br><span class="line">    left = left.left;</span><br><span class="line">    right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h4><p>问题分析<br>当符号右旋转的条件时</p>
<ol>
<li>如果它的左子树的右子树高度大于它的左子树的高度</li>
<li>先对当前这个结点的左节点进行左旋转</li>
<li>在对当前结点进行右旋转的操作即可</li>
</ol>
<p><img alt="image-20191109100332183" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109100332183.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******当添加完节点后，(右子树的高度 - 左子树的高度) &gt; 1***********</span></span><br><span class="line">       <span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line">       <span class="keyword">if</span>(rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">           <span class="keyword">if</span>(right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">               <span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line">               right.rightRotate();</span><br><span class="line">               <span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line">               leftRotate(); <span class="comment">//左旋转..</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//直接进行左旋转即可</span></span><br><span class="line">               leftRotate();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ; <span class="comment">//必须要!!!</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line">       <span class="keyword">if</span>(leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">           <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">               <span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line">               left.leftRotate();</span><br><span class="line">               <span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">               rightRotate();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//直接进行右旋转即可</span></span><br><span class="line">               rightRotate();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="Node类-1"><a href="#Node类-1" class="headerlink" title="Node类"></a>Node类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Node</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前节点的高度，以该节点为根节点的树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height() ,</span><br><span class="line">                right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋转的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的节点，以当前根节点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">        newNode.left = left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成带你过去结点的右子树的左子树</span></span><br><span class="line">        newNode.right = right.left;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">        val = right.val;</span><br><span class="line">        <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">        right = right.right;</span><br><span class="line">        <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">        left = newNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        val = left.val;</span><br><span class="line">        left = left.left;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------二叉排序树的基本方法------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  查找要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   希望删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="keyword">this</span>.val)&#123; <span class="comment">//找到该节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val)&#123; <span class="comment">//查找的值小于当前的节点，想左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除结点的父结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.val == val) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.val == val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(val); <span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(val); <span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值 和当前子树根节点的值比大小</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt; <span class="keyword">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//node.val &gt; this.val</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//*******当添加完节点后，(右子树的高度 - 左子树的高度) &gt; 1***********</span></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line">        <span class="keyword">if</span>(rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">            <span class="keyword">if</span>(right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                <span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line">                right.rightRotate();</span><br><span class="line">                <span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line">                leftRotate(); <span class="comment">//左旋转..</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接进行左旋转即可</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">//必须要!!!</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line">        <span class="keyword">if</span>(leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                <span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接进行右旋转即可</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AVLTree类"><a href="#AVLTree类" class="headerlink" title="AVLTree类"></a>AVLTree类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName AVLTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/9</span></span><br><span class="line"><span class="comment"> * Time      9:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法:</span></span><br><span class="line">    <span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line">    <span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时 target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.val);</span><br><span class="line">        <span class="keyword">return</span> target.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.val == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">                <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.val = minVal;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——左</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点  右——左</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——右</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点 右——右</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOreder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Test-3"><a href="#Test-3" class="headerlink" title="Test"></a>Test</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName AVLTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/9</span></span><br><span class="line"><span class="comment"> * Time      9:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        avlTree.infixOreder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"平衡后........"</span>);</span><br><span class="line">        System.out.println(<span class="string">"树的高度::"</span> + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(<span class="string">"树的左子树高度::"</span> + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(<span class="string">"树的右子树高度::"</span> + avlTree.getRoot().rightHeight());</span><br><span class="line">        System.out.println(avlTree.getRoot().val);</span><br><span class="line">        System.out.println(avlTree.getRoot().left.val);</span><br><span class="line">        System.out.println(avlTree.getRoot().right.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="image-20191109110458028" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109110458028.png" class="lazyload"></p>
<h2 id="6、2-3树"><a href="#6、2-3树" class="headerlink" title="6、2-3树"></a>6、2-3树</h2><h3 id="介绍-23"><a href="#介绍-23" class="headerlink" title="介绍"></a>介绍</h3><img alt="image-20191109165319592" style="zoom:65%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109165319592.png" class="lazyload">

<img alt="image-20191109165452654" style="zoom:67%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109165452654.png" class="lazyload">

<p><strong>2-3树是一颗绝对平衡的树（左右子树的高度相等）</strong></p>
<h3 id="插入步骤"><a href="#插入步骤" class="headerlink" title="插入步骤"></a>插入步骤</h3><p><img alt="2-3树添加" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2-3%E6%A0%91%E6%B7%BB%E5%8A%A0.png" class="lazyload"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>2-3树是最简单的B树结构, 具有如下特点:</p>
<p>1、<span style="color:red"><strong>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</strong></span><br>2、有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
<p>3、有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</p>
<p>4、2-3树是由二节点和三节点构成的树。</p>
<h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><p><img alt="image-20191109155814269" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109155814269.png" class="lazyload"></p>
<h2 id="7、红黑树"><a href="#7、红黑树" class="headerlink" title="7、红黑树"></a>7、红黑树</h2><h3 id="介绍-24"><a href="#介绍-24" class="headerlink" title="介绍"></a>介绍</h3><p>2-3树中如下：b-c在同一个节点上，b比c小，将b挂到c的左子树上去，原本b-c节点的内部关联转成了b节点和c节点，标示成红色，并将此信息放入b节点中，而普通的节点则为黑色</p>
<img alt="image-20191110152750142" style="zoom:50%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191110152750142.png" class="lazyload">

<p>下图红黑树所示：</p>
<p><img alt="红黑树" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91.png" class="lazyload"></p>
<h4 id="4个性质"><a href="#4个性质" class="headerlink" title="4个性质"></a>4个性质</h4><p>性质1. 节点是红色或黑色。<br>性质2. 根节点是黑色。<br>性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br>性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h1 id="十、多路查找树"><a href="#十、多路查找树" class="headerlink" title="十、多路查找树"></a>十、多路查找树</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>二叉树的问题分析</p>
<p><img alt="image-20191109111021630" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109111021630.png" class="lazyload"></p>
<h2 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h2><p>1、在二叉树中，每个节点有数据项，最多有两个子节点。<strong>如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</strong></p>
<p>2、后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</p>
<p>举例说明(下面2-3树就是一颗多叉树)</p>
<p><img alt="image-20191109111057267" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109111057267.png" class="lazyload"></p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>[2-3树跳转](# 6、2-3树)</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</p>
<p><img alt="image-20191109161220051" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109161220051.png" class="lazyload"></p>
<p><img alt="image-20191109111310760" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109111310760.png" class="lazyload"></p>
<p>1、如图B树通过重新组织节点， 降低了树的高度.</p>
<p>2、文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</p>
<p>3、将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h2><p><img alt="image-20191109162216279" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109162216279.png" class="lazyload"></p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B* 树"></a>B* 树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针</p>
<p><img alt="image-20191109162435580" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109162435580.png" class="lazyload"></p>
<h1 id="十一、图"><a href="#十一、图" class="headerlink" title="十一、图"></a>十一、图</h1><h2 id="介绍-25"><a href="#介绍-25" class="headerlink" title="介绍"></a>介绍</h2><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。</p>
<p><img alt="image-20191110162430691" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191110162430691.png" class="lazyload"></p>
<p><img alt="image-20191110162447261" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191110162447261.png" class="lazyload"></p>
<h2 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h2><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。（1：可到达  0：不可到达）</p>
<p><img alt="image-20191110163316730" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191110163316730.png" class="lazyload"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>1、邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.<br>2、邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</p>
<p><img alt="image-20191111090959899" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191111090959899.png" class="lazyload"></p>
<h2 id="邻接矩阵——代码"><a href="#邻接矩阵——代码" class="headerlink" title="邻接矩阵——代码"></a>邻接矩阵——代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Graph</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/11</span></span><br><span class="line"><span class="comment"> * Time      9:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          无向图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回结点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示权值  边对应的值  1 / 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String v : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把邻结矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img alt="image-20191111101402439" style="zoom:90%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191111101402439.png" class="lazyload">







<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><blockquote>
<p> 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历</p>
</blockquote>
<h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><h4 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h4><p>图的深度优先搜索(Depth First Search) 。<br>1、深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：<strong>每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</strong><br>2、我们可以看到，这样的访问策略是<strong>优先往纵向挖掘深入</strong>，而不是对一个结点的所有邻接结点进行横向访问。<br>3、显然，深度优先搜索是一个递归的过程</p>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><p>1、访问初始结点v，并标记结点v为已访问。</p>
<p>2、查找结点v的第一个邻接结点w。</p>
<p>3、若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</p>
<p>4、若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</p>
<p>5、查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</p>
<p><img alt="深度优先遍历" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" class="lazyload"></p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到第一个邻接结点的下标 w</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//i 起始为0</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       例如：从第一个开始找，首先输出A，标记访问，然后找第一行第一个为1的路径B，</span></span><br><span class="line"><span class="comment">       开始遍历B行中第一个为1的路径A，发现访问过了，开始找下一个为1的路径C，标记访问，</span></span><br><span class="line"><span class="comment">       再开始遍历C行.............以此类推</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    A  B  C  D  E</span></span><br><span class="line"><span class="comment">           A       [0, 1, 1, 0, 0]</span></span><br><span class="line"><span class="comment">           B       [1, 0, 1, 1, 1]</span></span><br><span class="line"><span class="comment">           C       [1, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">           D       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">           E       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">       <span class="comment">//[1] 首先我们访问该结点,输出</span></span><br><span class="line">       System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">       <span class="comment">//[1] 将结点设置为已经访问</span></span><br><span class="line">       isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//[2] 查找结点i的第一个邻接结点w</span></span><br><span class="line">       <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">       <span class="comment">//[3]</span></span><br><span class="line">       <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//说明有</span></span><br><span class="line">           <span class="comment">//[4]</span></span><br><span class="line">           <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">               dfs(isVisited, w);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//[5] 如果w结点已经被访问过</span></span><br><span class="line">           w = getNextNeighbor(i, w);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">       <span class="comment">//遍历所有的结点，进行dfs[回溯]</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">               dfs(isVisited, i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>













<h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>图的广度优先搜索(Broad First Search) 。<br>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><p>1、访问初始结点v并标记结点v为已访问。<br>2、结点v入队列<br>3、当队列非空时，继续执行，否则算法结束。<br>4、出队列，取得队头结点u。<br>5、查找结点u的第一个邻接结点w。<br>6、若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<br>6.1 若结点w尚未被访问，则访问结点w并标记为已访问。<br>6.2 结点w入队列<br>6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p>
<p><img alt="广度优先遍历" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-1573521467725.png" class="lazyload"></p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u ; <span class="comment">// 表示队列的头结点对应下标</span></span><br><span class="line">    <span class="keyword">int</span> w ; <span class="comment">// 邻接结点w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">//[1]访问结点，输出结点信息</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">"=&gt;"</span>);</span><br><span class="line">    <span class="comment">//[1]标记为已访问</span></span><br><span class="line">    isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    queue.addLast(i);</span><br><span class="line">    <span class="comment">//[3]</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//[4]</span></span><br><span class="line">        u = (Integer) queue.removeFirst();</span><br><span class="line">        <span class="comment">//[5]得到第一个邻接结点的下标 w</span></span><br><span class="line">        w = getFirstNeighbor(u);</span><br><span class="line">        <span class="comment">//[6]</span></span><br><span class="line">        <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">            <span class="comment">//[6.1]是否访问过</span></span><br><span class="line">            <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">"=&gt;"</span>);</span><br><span class="line">                <span class="comment">//标记已经访问</span></span><br><span class="line">                isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//[6.2]入队</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//[6.2]以u为前驱点，找w后面的下一个邻结点</span></span><br><span class="line">            w = getNextNeighbor(u, w); <span class="comment">//体现出我们的广度优先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的结点，都进行广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">            bfs(isVisited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Graph</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/11</span></span><br><span class="line"><span class="comment"> * Time      9:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          无向图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回结点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *			无向图的添加方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示权值  边对应的值  1 / 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个邻接结点的下标 w</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 起始为0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        例如：从第一个开始找，首先输出A，标记访问，然后找第一行第一个为1的路径B，</span></span><br><span class="line"><span class="comment">        开始遍历B行中第一个为1的路径A，发现访问过了，开始找下一个为1的路径C，标记访问，</span></span><br><span class="line"><span class="comment">        再开始遍历C行.............以此类推</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     A  B  C  D  E</span></span><br><span class="line"><span class="comment">            A       [0, 1, 1, 0, 0]</span></span><br><span class="line"><span class="comment">            B       [1, 0, 1, 1, 1]</span></span><br><span class="line"><span class="comment">            C       [1, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">            D       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">            E       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先我们访问该结点,输出</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">        <span class="comment">//将结点设置为已经访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//查找结点i的第一个邻接结点w</span></span><br><span class="line">        <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//说明有</span></span><br><span class="line">            <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果w结点已经被访问过***************************</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//遍历所有的结点，进行dfs[回溯]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u ; <span class="comment">// 表示队列的头结点对应下标</span></span><br><span class="line">        <span class="keyword">int</span> w ; <span class="comment">// 邻接结点w</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//[1]访问结点，输出结点信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">"=&gt;"</span>);</span><br><span class="line">        <span class="comment">//[1]标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//[2]</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="comment">//[3]</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//[4]</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//[5]得到第一个邻接结点的下标 w</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="comment">//[6]</span></span><br><span class="line">            <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//[6.1]是否访问过</span></span><br><span class="line">                <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(w) + <span class="string">"=&gt;"</span>);</span><br><span class="line">                    <span class="comment">//标记已经访问</span></span><br><span class="line">                    isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//[6.2]入队</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//[6.2]以u为前驱点，找w后面的下一个邻结点*****************</span></span><br><span class="line">                w = getNextNeighbor(u, w); <span class="comment">//体现出我们的广度优先</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的结点，都进行广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String v : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把邻结矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"深度遍历"</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">        System.out.println(<span class="string">"\n广度优先!"</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>getNextNeighbor就是最大的区别，dfs跳转到另一行w找下一个邻接点，bfs是在当前行u找下一个邻节点</p>
</blockquote>
<h2 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h2><p><img alt="image-20191112095246913" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191112095246913.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String v : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新边的关系</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把邻结矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"深度遍历"</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">        System.out.println(<span class="string">"\n广度优先!"</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="十二、常用10种算法"><a href="#十二、常用10种算法" class="headerlink" title="十二、常用10种算法"></a>十二、常用10种算法</h1><h2 id="1、二分查找（非递归）"><a href="#1、二分查找（非递归）" class="headerlink" title="1、二分查找（非递归）"></a>1、二分查找（非递归）</h2><h3 id="介绍-26"><a href="#介绍-26" class="headerlink" title="介绍"></a>介绍</h3><p>​        前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式<br>​        二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找<br>​        二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysearch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySearchNoRecursion</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/12</span></span><br><span class="line"><span class="comment"> * Time      10:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNoRecursion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   默认升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(arr, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"index::"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、分治算法-Divide-and-Conquer"><a href="#2、分治算法-Divide-and-Conquer" class="headerlink" title="2、分治算法(Divide-and-Conquer)"></a>2、分治算法(Divide-and-Conquer)</h2><h3 id="介绍-27"><a href="#介绍-27" class="headerlink" title="介绍"></a>介绍</h3><p>1、分治法是一种很重要的算法。字面上的解释是“<strong>分而治之</strong>”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<p>2、分治算法可以求解的一些经典问题<br>二分搜索、大整数乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、汉诺塔</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><p>分治法在每一层递归上都有三个步骤：<br>[1] 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题<br>[2] 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br>[3] 合并：将各个子问题的解合并为原问题的解。</p>
<h3 id="案例——汉诺塔"><a href="#案例——汉诺塔" class="headerlink" title="案例——汉诺塔"></a>案例——汉诺塔</h3><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>1、如果是有一个盘， A-&gt;C</p>
<p>2、如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘</p>
<p>​    [1] 先把 最上面的盘 A-&gt;B<br>​    [2] 把最下边的盘 A-&gt;C<br>​    [3] 把B塔的所有盘 从 B-&gt;C   </p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.DivideAndConquer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName DivideAndConquer</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/12</span></span><br><span class="line"><span class="comment"> * Time      10:23</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 汉诺塔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoitower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"第1个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘</span></span><br><span class="line">            <span class="comment">//1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//2. 把最下边的盘 A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span> + num + <span class="string">"个盘从 "</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">            <span class="comment">//3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、动态规划"><a href="#3、动态规划" class="headerlink" title="3、动态规划"></a>3、动态规划</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题：有一个背包，容量为4磅 ， 现有如下物品</p>
<table>
<thead>
<tr>
<th align="center"><strong>物品</strong></th>
<th align="center"><strong>重量</strong></th>
<th align="center"><strong>价格</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">吉他(G)</td>
<td align="center">1</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">音响(S)</td>
<td align="center">4</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center">电脑(L)</td>
<td align="center">3</td>
<td align="center">2000</td>
</tr>
</tbody></table>
<p>1、要求达到的目标为装入的背包的总价值最大，并且重量不超出<br>2、要求装入的物品不能重复</p>
<h3 id="介绍-28"><a href="#介绍-28" class="headerlink" title="介绍"></a>介绍</h3><p>1、动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p>
<p>2、动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>3、与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p>
<p>4、动态规划可以通过填表的方式来逐步推进，得到最优解.</p>
<p> <a href="https://blog.csdn.net/qq_38410730/article/details/81667885" target="_blank" rel="noopener">https://blog.csdn.net/qq_38410730/article/details/81667885</a> </p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</p>
<p>1、  <code>v[i][0]=v[0][j]=0;</code> //表示 填入表 第一行和第一列是0</p>
<p>2、当<code>w[i]&gt; j</code> 时：<code>v[i][j]=v[i-1][j]</code>  // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略</p>
<p>3、当<code>j&gt;=w[i]</code>时：<code>v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}</code><br> 当 准备加入的新增的商品的容量小于等于当前背包的容量,<br> 装入的方式:<br><code>v[i-1][j]</code>： 就是上一个单元格的装入的最大值<br><code>v[i]</code> : 表示当前商品的价值<br><code>v[i-1][j-w[i]]</code> ： 装入i-1商品，到剩余空间j-w[i]的最大值<br>当<code>j&gt;=w[i]</code>时：<code>v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}</code> </p>
<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><p><img alt="image-20191114144929888" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114144929888.png" class="lazyload"></p>
<p><img alt="image-20191114145024253" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114145024253.png" class="lazyload"></p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName KnapsackProblem</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/12</span></span><br><span class="line"><span class="comment"> * Time      15:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;; <span class="comment">//物品的价值 这里val[i] 就是前面讲的v[i]</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length; <span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组，</span></span><br><span class="line">        <span class="comment">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//将第一列设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//将第一行设置0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面得到公式来动态规划处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123; <span class="comment">//不处理第一行 i是从1开始的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;<span class="comment">//不处理第一列, j是从1开始的</span></span><br><span class="line">                <span class="comment">//公式</span></span><br><span class="line">                <span class="keyword">if</span>(w[i-<span class="number">1</span>]&gt; j) &#123; <span class="comment">// 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]</span></span><br><span class="line">                    v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明:</span></span><br><span class="line">                    <span class="comment">//因为我们的i 从1开始的， 因此公式需要调整成</span></span><br><span class="line">                    <span class="comment">//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                    <span class="comment">//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span></span><br><span class="line">                    <span class="comment">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式</span></span><br><span class="line">                    <span class="keyword">if</span>(v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//把当前的情况记录到path</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出一下v 看看目前的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; v.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length;j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============================"</span>);</span><br><span class="line">        <span class="comment">//输出最后我们是放入的哪些商品</span></span><br><span class="line">        <span class="comment">//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入</span></span><br><span class="line"><span class="comment">//		for(int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//			for(int j=0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">//				if(path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">//					System.out.printf("第%d个商品放入到背包\n", i);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动脑筋</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>; <span class="comment">//行的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;  <span class="comment">//列的最大下标</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> ) &#123; <span class="comment">//从path的最后开始找</span></span><br><span class="line">            <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"第%d个商品放入到背包\n"</span>, i);</span><br><span class="line">                j -= w[i-<span class="number">1</span>]; <span class="comment">//w[i-1]</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4、KMP算法"><a href="#4、KMP算法" class="headerlink" title="4、KMP算法"></a>4、KMP算法</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>不多说，一一匹配，上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.kmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ViolenceMatch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/14</span></span><br><span class="line"><span class="comment"> * Time      15:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolenceMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力匹配算法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s1Len = s1.length;</span><br><span class="line">        <span class="keyword">int</span> s2Len = s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i索引指向s1</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// j索引指向s2</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;<span class="comment">// 保证匹配时，不越界</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j]) &#123;<span class="comment">//匹配ok</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//没有匹配成功</span></span><br><span class="line">                <span class="comment">//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。</span></span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j == s2Len) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试暴力匹配算法</span></span><br><span class="line">        String str1 = <span class="string">"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好"</span>;</span><br><span class="line">        String str2 = <span class="string">"尚硅谷你尚硅你"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">        System.out.println(<span class="string">"index="</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="kmp介绍"><a href="#kmp介绍" class="headerlink" title="kmp介绍"></a>kmp介绍</h3><p>1、KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法.</p>
<p>2、Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.</p>
<p>3、KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</p>
<p>4、参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a> </p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h4 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h4><p><img alt="image-20191114153325121" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153325121.png" class="lazyload"></p>
<p><img alt="image-20191114153348288" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153348288.png" class="lazyload"></p>
<p><img alt="image-20191114153423389" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153423389.png" class="lazyload"></p>
<p><img alt="image-20191114153456573" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153456573.png" class="lazyload"></p>
<p><img alt="image-20191114153513844" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153513844.png" class="lazyload"></p>
<p><img alt="image-20191114153535725" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153535725.png" class="lazyload"></p>
<h4 id="部分匹配表的产生"><a href="#部分匹配表的产生" class="headerlink" title="部分匹配表的产生"></a>部分匹配表的产生</h4><p><img alt="image-20191114153809183" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153809183.png" class="lazyload"></p>
<p><img alt="image-20191114153831281" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153831281.png" class="lazyload"></p>
<h3 id="求next值的两种方式"><a href="#求next值的两种方式" class="headerlink" title="求next值的两种方式"></a>求next值的两种方式</h3><p>原理请看上面网址</p>
<p><img alt="kmp求解方式" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/kmp%E6%B1%82%E8%A7%A3%E6%96%B9%E5%BC%8F.png" class="lazyload"></p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName KMPAlgorithm</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/14</span></span><br><span class="line"><span class="comment"> * Time      15:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1] 获取一个字符串（子串）的部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(str2);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(<span class="string">"index="</span> + index); <span class="comment">// 15了</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写出我们的kmp搜索算法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表, 是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小</span></span><br><span class="line">            <span class="comment">//KMP算法核心点, 可以验证...</span></span><br><span class="line">            <span class="keyword">while</span>( j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == str2.length()) &#123;<span class="comment">//找到了 // j = 3 i</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//如果子串长度为1，没有公共的，部分匹配之为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line">            <span class="comment">//这时kmp算法的核心点</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j))&#123; <span class="comment">// 部分匹配值 + 1</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、贪心算法"><a href="#5、贪心算法" class="headerlink" title="5、贪心算法"></a>5、贪心算法</h2><h3 id="介绍-29"><a href="#介绍-29" class="headerlink" title="介绍"></a>介绍</h3><p>​        贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</p>
<p>​        贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p>
<h3 id="集合覆盖"><a href="#集合覆盖" class="headerlink" title="集合覆盖"></a>集合覆盖</h3><h4 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h4><p><img alt="image-20191116081400909" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116081400909.png" class="lazyload"></p>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><h5 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h5><p><img alt="image-20191116092649061" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116092649061.png" class="lazyload"></p>
<h5 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h5><p>使用贪婪算法，效率高:<br>        目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:<br>1、遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）<br>2、将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。<br>3、重复第1步直到覆盖了全部的地区</p>
<h4 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h4><p><img alt="贪婪算法步骤" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4.png" class="lazyload"></p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建广播电台,放入到Map</span></span><br><span class="line">		HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">		<span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">		HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet1.add(<span class="string">"北京"</span>);</span><br><span class="line">		hashSet1.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet1.add(<span class="string">"天津"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet2.add(<span class="string">"广州"</span>);</span><br><span class="line">		hashSet2.add(<span class="string">"北京"</span>);</span><br><span class="line">		hashSet2.add(<span class="string">"深圳"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet3.add(<span class="string">"成都"</span>);</span><br><span class="line">		hashSet3.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet3.add(<span class="string">"杭州"</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet4.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet4.add(<span class="string">"天津"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet5.add(<span class="string">"杭州"</span>);</span><br><span class="line">		hashSet5.add(<span class="string">"大连"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//加入到map</span></span><br><span class="line">		broadcasts.put(<span class="string">"K1"</span>, hashSet1);</span><br><span class="line">		broadcasts.put(<span class="string">"K2"</span>, hashSet2);</span><br><span class="line">		broadcasts.put(<span class="string">"K3"</span>, hashSet3);</span><br><span class="line">		broadcasts.put(<span class="string">"K4"</span>, hashSet4);</span><br><span class="line">		broadcasts.put(<span class="string">"K5"</span>, hashSet5);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//allAreas 存放所有的地区</span></span><br><span class="line">		HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		allAreas.add(<span class="string">"北京"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"上海"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"天津"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"广州"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"深圳"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"成都"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"杭州"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"大连"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建ArrayList, 存放选择的电台集合</span></span><br><span class="line">		ArrayList&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">		HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span></span><br><span class="line">		<span class="comment">//如果maxKey 不为null , 则会加入到 selects</span></span><br><span class="line">		String maxKey = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>(allAreas.size() != <span class="number">0</span>) &#123; <span class="comment">// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区</span></span><br><span class="line">			<span class="comment">//每进行一次while,需要</span></span><br><span class="line">			maxKey = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//遍历 broadcasts, 取出对应key</span></span><br><span class="line">			<span class="keyword">for</span>(String key : broadcasts.keySet()) &#123;</span><br><span class="line">				<span class="comment">//每进行一次for</span></span><br><span class="line">				tempSet.clear();</span><br><span class="line">				<span class="comment">//当前这个key能够覆盖的地区</span></span><br><span class="line">				HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">				tempSet.addAll(areas);</span><br><span class="line">				<span class="comment">//求出tempSet 和   allAreas 集合的交集, 交集会赋给 tempSet</span></span><br><span class="line">				tempSet.retainAll(allAreas);</span><br><span class="line">				<span class="comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span></span><br><span class="line">				<span class="comment">//就需要重置maxKey</span></span><br><span class="line">				<span class="comment">// tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的</span></span><br><span class="line">				<span class="keyword">if</span>(tempSet.size() &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">						(maxKey == <span class="keyword">null</span> || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">					maxKey = key;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//maxKey != null, 就应该将maxKey 加入selects</span></span><br><span class="line">			<span class="keyword">if</span>(maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">				selects.add(maxKey);</span><br><span class="line">				<span class="comment">//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉</span></span><br><span class="line">				allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"得到的选择结果是"</span> + selects);<span class="comment">//[K1,K2,K3,K5]</span></span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果<br>2、比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区<br>3、但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的.</p>
<h2 id="6、普里姆（Prim）算法"><a href="#6、普里姆（Prim）算法" class="headerlink" title="6、普里姆（Prim）算法"></a>6、普里姆（Prim）算法</h2><h3 id="介绍-30"><a href="#介绍-30" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="image-20191116093521622" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116093521622.png" class="lazyload"></p>
<h3 id="修路问题"><a href="#修路问题" class="headerlink" title="修路问题"></a>修路问题</h3><h4 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h4><p><img alt="image-20191116093542948" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116093542948.png" class="lazyload"></p>
<p><img alt="image-20191116093614097" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116093614097.png" class="lazyload"></p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><img alt="image-20191116094718450" style="zoom:150%;" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116094718450.png" class="lazyload">



<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><h4 id="Graph类"><a href="#Graph类" class="headerlink" title="Graph类"></a>Graph类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.prim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MGraph</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/16</span></span><br><span class="line"><span class="comment"> * Time      9:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> verx;<span class="comment">//表示图的节点个数</span></span><br><span class="line">    <span class="keyword">char</span>[] data;<span class="comment">//保存节点数据</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;<span class="comment">//存放边，邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(<span class="keyword">int</span> verx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verx = verx;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">char</span>[verx];</span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">int</span>[verx][verx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVerx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> verx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVerx</span><span class="params">(<span class="keyword">int</span> verx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verx = verx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">char</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] getWeight() &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="MinTree类"><a href="#MinTree类" class="headerlink" title="MinTree类"></a>MinTree类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.prim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MinTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/16</span></span><br><span class="line"><span class="comment"> * Time      9:53</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建最小生成树 -&gt; 村庄图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图的邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verxs 图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(MGraph graph,<span class="keyword">int</span> verxs,<span class="keyword">char</span> data[],<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; verxs; i++) &#123;<span class="comment">//顶点</span></span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>;  j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(MGraph graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] weight = graph.getWeight();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] vs : weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(vs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写prim算法，生成最小生成树</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(MGraph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> verx = graph.getVerx();</span><br><span class="line">        <span class="keyword">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[verx];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] weight = graph.getWeight();</span><br><span class="line"></span><br><span class="line">        isVisited[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v_1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v_2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min_weight = <span class="number">100000</span>; <span class="comment">//初始大值，遍历到小的就替换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; verx; k++) &#123; <span class="comment">//因为有verx个顶点，prim结束后，有verx - 1条边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//每一次会有多个点，而每个点需要遍历，所以需要双循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;verx;i++)&#123;<span class="comment">// i结点表示被访问过的结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; verx; j++) &#123;<span class="comment">//j结点表示还没有访问过的结点</span></span><br><span class="line">                    <span class="keyword">if</span> (isVisited[i] &amp;&amp; !isVisited[j])&#123; <span class="comment">//头点已访问，尾点未访问的边</span></span><br><span class="line">                        <span class="keyword">if</span> (min_weight &gt; weight[i][j])&#123;</span><br><span class="line">                            min_weight = weight[i][j];</span><br><span class="line">                            v_1 = i;</span><br><span class="line">                            v_2 = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一条边是最小</span></span><br><span class="line">            System.out.println(<span class="string">"边&lt;"</span> + graph.data[v_1] + <span class="string">","</span> + graph.data[v_2]</span><br><span class="line">                    + <span class="string">"&gt; 权值:"</span> + min_weight);</span><br><span class="line"></span><br><span class="line">            isVisited[v_2] = <span class="keyword">true</span>;</span><br><span class="line">            min_weight = <span class="number">10000</span>; <span class="comment">//初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Test-4"><a href="#Test-4" class="headerlink" title="Test"></a>Test</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.prim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName PrimAlgorithm</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/16</span></span><br><span class="line"><span class="comment"> * Time      9:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试看看图是否创建ok</span></span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span></span><br><span class="line">        <span class="keyword">int</span> [][]weight=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MGraph对象</span></span><br><span class="line">        MGraph graph = <span class="keyword">new</span> MGraph(verxs);</span><br><span class="line">        <span class="comment">//创建一个MinTree对象</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试普利姆算法</span></span><br><span class="line">        minTree.prim(graph, <span class="number">0</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191116110948344" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116110948344.png" class="lazyload"></p>
<h2 id="7、克鲁斯卡尔（Kruskal）算法"><a href="#7、克鲁斯卡尔（Kruskal）算法" class="headerlink" title="7、克鲁斯卡尔（Kruskal）算法"></a>7、克鲁斯卡尔（Kruskal）算法</h2><h3 id="介绍-31"><a href="#介绍-31" class="headerlink" title="介绍"></a>介绍</h3><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p>
<p><strong>基本思想</strong>：<strong>按照权值从小到大的顺序</strong>选择n-1条边，并保证这n-1条边不构成回路</p>
<p>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p>
<h3 id="公交站问题"><a href="#公交站问题" class="headerlink" title="公交站问题"></a>公交站问题</h3><p><img alt="image-20191116140518598" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116140518598.png" class="lazyload"></p>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p><img alt="克鲁斯卡尔" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94.png" class="lazyload"></p>
<p><img alt="image-20191116143005177" data-src="http://img.mxranger.cn/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116143005177.png" class="lazyload"></p>
<h2 id="8、-迪杰斯特拉-（Dijkstra）算法"><a href="#8、-迪杰斯特拉-（Dijkstra）算法" class="headerlink" title="8、 迪杰斯特拉 （Dijkstra）算法"></a>8、 迪杰斯特拉 （Dijkstra）算法</h2><h2 id="9、-弗洛伊德（Floyd）算法"><a href="#9、-弗洛伊德（Floyd）算法" class="headerlink" title="9、 弗洛伊德（Floyd）算法"></a>9、 弗洛伊德（Floyd）算法</h2>]]></content>
      <categories>
        <category>java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>医学图像评价指标</title>
    <url>/2019/11/25/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近写论文需要一些评价指标数据，做个总结，实现python代码</p>
<h1 id="基本评价指标"><a href="#基本评价指标" class="headerlink" title="基本评价指标"></a>基本评价指标</h1><h2 id="FP、FN、TP、TN"><a href="#FP、FN、TP、TN" class="headerlink" title="FP、FN、TP、TN"></a>FP、FN、TP、TN</h2><p><img alt="640?wx_fmt=png" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/p.png" class="lazyload"></p>
<ul>
<li><p>TP：T（预测对了true） P(预测为正样本positive)；真的正值，说明被预测为正样本，预测是真的，即真实值为正样本</p>
</li>
<li><p>TN：T（预测对了true） P(预测为负样本negative)；真的负值，说明被预测为负样本，预测是真的，即真实值为负样本</p>
</li>
<li><p>FP：T（预测错了false）P(预测为正样本positive)；假的正直：说明被预测为正样本，但预测是假的，即真实值为负样本</p>
</li>
<li><p>FN：T（预测错了false）P(预测为负样本negative)；假的负值，说明被预测为负样本，但预测是假的，即真实值为正样</p>
</li>
</ul>
<h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.seterr(divide=<span class="string">'ignore'</span>,invalid=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line">labels=[<span class="string">"dog"</span>, <span class="string">"cat"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_base</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    C2 = confusion_matrix(y_true, y_pred, labels=labels)</span><br><span class="line">    TN, FP, FN, TP = C2.ravel()</span><br><span class="line">    <span class="keyword">return</span> TN, FP, FN, TP</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    y_true = [<span class="string">"dog"</span>, <span class="string">"dog"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>]</span><br><span class="line">    y_pred = [<span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>]</span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br></pre></td></tr></table></figure>





<h2 id="精确率-Precision-、召回率-Recall-、准确率-Accuracy"><a href="#精确率-Precision-、召回率-Recall-、准确率-Accuracy" class="headerlink" title="精确率(Precision)、召回率(Recall)、准确率(Accuracy)"></a>精确率(Precision)、召回率(Recall)、准确率(Accuracy)</h2><p><strong>准确率(Accuracy)</strong>：这三个指标里最直观的就是准确率: 模型判断正确的数据(TP+TN)占总数据的比例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Accuracy: "</span>+str(round((tp+tn)/(tp+fp+fn+tn), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>召回率(Recall)：</strong>针对数据集中的所有正例(TP+FN)而言,模型正确判断出的正例(TP)占数据集中所有正例的比例.FN表示被模型误认为是负例但实际是正例的数据.召回率也叫查全率,以物体检测为例,我们往往把图片中的物体作为正例,此时召回率高代表着模型可以找出图片中更多的物体!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Recall: "</span>+str(round((tp)/(tp+fn), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>精确率(Precision)：</strong>针对模型判断出的所有正例(TP+FP)而言,其中真正例(TP)占的比例.精确率也叫查准率,还是以物体检测为例,精确率高表示模型检测出的物体中大部分确实是物体,只有少量不是物体的对象被当成物体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Precision: "</span>+str(round((tp)/(tp+fp), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<h3 id="python代码-1"><a href="#python代码-1" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    classification accuracy，描述分类器的分类准确率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    ACC = str(round((TP + TN)/(TP + FP + FN + TN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Accuracy: "+ ACC)</span></span><br><span class="line">    <span class="keyword">return</span> ACC</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    敏感度（sensitivity）、查全率（Recall）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Recall = str(round((TP)/(TP+FN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Recall: "+ Recall)</span></span><br><span class="line">    <span class="keyword">return</span> Recall</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    查准率（Precision）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Precision</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Precision = str(round(TP/(TP + FP), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("Precision: "+ Precision)</span></span><br><span class="line">    <span class="keyword">return</span> Precision</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    描述识别出的负例占所有负例的比例，特异度（specificity）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specificity</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    <span class="comment">#Positive predictive value</span></span><br><span class="line">    NPV = str(round(TN/(TN + FP + <span class="number">0.01</span>), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("PPV:" + NPV)</span></span><br><span class="line">    <span class="keyword">return</span> NPV</span><br></pre></td></tr></table></figure>









<h1 id="医学图像分割"><a href="#医学图像分割" class="headerlink" title="医学图像分割"></a>医学图像分割</h1><h2 id="DICE"><a href="#DICE" class="headerlink" title="DICE"></a>DICE</h2><p>DICE（值域为[0,1]）: 使用频率最高。数学定义如下，具体表示两个物体相交的面积占总面积的比值，完美分割该值为1</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612115855632.png" class="lazyload"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    python numpy版 dice损失函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">smooth = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DICE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = np.sum(y_true_f * y_pred_f)</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br></pre></td></tr></table></figure>



<h2 id="VOE"><a href="#VOE" class="headerlink" title="VOE"></a>VOE</h2><p>与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612155245106.png" class="lazyload"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    VOE（volumetric overlap error）</span></span><br><span class="line"><span class="string">    与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VOE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = abs(np.sum(y_true_f) - np.sum(y_pred_f))</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br></pre></td></tr></table></figure>



<h2 id="RVD"><a href="#RVD" class="headerlink" title="RVD"></a>RVD</h2><p>表示两者体积之间的差异</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612160043818.png" class="lazyload"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    RVD（relative volume difference）：表示两者体积之间的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RVD</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    numerator = abs(np.sum(y_pred_f) - np.sum(y_true_f))</span><br><span class="line">    denominator = np.sum(y_true_f)</span><br><span class="line">    <span class="keyword">return</span> numerator / (denominator + smooth)</span><br></pre></td></tr></table></figure>



<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/11/25 15:37</span></span><br><span class="line"><span class="comment"># @Author  : MxRanger</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : eval.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.seterr(divide=<span class="string">'ignore'</span>,invalid=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># labels=["dog", "cat"]</span></span><br><span class="line">labels = [<span class="number">1</span> , <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_base</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    C2 = confusion_matrix(y_true, y_pred, labels=labels)</span><br><span class="line">    <span class="comment">#print(C2)</span></span><br><span class="line">    <span class="comment">#print("-------------")</span></span><br><span class="line">    TN, FP, FN, TP = C2.ravel()</span><br><span class="line">    <span class="keyword">return</span> TN, FP, FN, TP</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    classification accuracy，描述分类器的分类准确率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    ACC = str(round((TP + TN)/(TP + FP + FN + TN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Accuracy: "+ ACC)</span></span><br><span class="line">    <span class="keyword">return</span> ACC</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    敏感度（sensitivity）、查全率（Recall）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Recall = str(round((TP)/(TP+FN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Recall: "+ Recall)</span></span><br><span class="line">    <span class="keyword">return</span> Recall</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    查准率（Precision）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Precision</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Precision = str(round(TP/(TP + FP), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("Precision: "+ Precision)</span></span><br><span class="line">    <span class="keyword">return</span> Precision</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    描述识别出的负例占所有负例的比例，特异度（specificity）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specificity</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    <span class="comment">#Positive predictive value</span></span><br><span class="line">    NPV = str(round(TN/(TN + FP + <span class="number">0.01</span>), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("PPV:" + NPV)</span></span><br><span class="line">    <span class="keyword">return</span> NPV</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    python numpy版 dice损失函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">smooth = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DICE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = np.sum(y_true_f * y_pred_f)</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    VOE（volumetric overlap error）</span></span><br><span class="line"><span class="string">    与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VOE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = abs(np.sum(y_true_f) - np.sum(y_pred_f))</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    RVD（relative volume difference）：表示两者体积之间的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RVD</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    numerator = abs(np.sum(y_pred_f) - np.sum(y_true_f))</span><br><span class="line">    denominator = np.sum(y_true_f)</span><br><span class="line">    <span class="keyword">return</span> numerator / (denominator + smooth)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(mha_path)</span>:</span></span><br><span class="line">    img = sitk.ReadImage(mha_path)</span><br><span class="line">    image = sitk.GetArrayFromImage(img)  <span class="comment"># indexes are z,y,x (notice the ordering)</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># y_true = ["dog", "dog", "dog", "cat", "cat", "cat", "cat"]</span></span><br><span class="line">    <span class="comment"># y_pred = ["cat", "cat", "dog", "cat", "cat", "cat", "cat"]</span></span><br><span class="line">    <span class="comment"># arr = [1,2,0,3,4,5,6]</span></span><br><span class="line">    <span class="comment"># arr[arr == 2] = 7</span></span><br><span class="line">    <span class="comment"># print(arr)</span></span><br><span class="line"></span><br><span class="line">    gt = read(<span class="string">'xxx#gt.mha'</span>)</span><br><span class="line">    pre = read(<span class="string">'xxx.mha'</span>)</span><br><span class="line"></span><br><span class="line">    print(acc(gt.flatten(),pre.flatten()))</span><br><span class="line">    print(DICE(gt,pre))</span><br><span class="line">    print(VOE(gt,pre))</span><br><span class="line">    print(RVD(gt,pre))</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191125174329852" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/image-20191125174329852.png" class="lazyload"></p>
]]></content>
  </entry>
  <entry>
    <title>JAVA多线程、高并发编程</title>
    <url>/2019/11/17/JAVA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="高并发编程一"><a href="#高并发编程一" class="headerlink" title="高并发编程一"></a>高并发编程一</h1><h2 id="1、synchronized关键字"><a href="#1、synchronized关键字" class="headerlink" title="1、synchronized关键字"></a>1、synchronized关键字</h2><h3 id="1-1、对象锁"><a href="#1-1、对象锁" class="headerlink" title="1.1、对象锁"></a>1.1、对象锁</h3><blockquote>
<p>同步代码块，将需要线性安全的某个操作放入到改代码块中，可以避免超卖，破坏对象的原子性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T1</span></span><br><span class="line"><span class="comment">* synchronized关键字</span></span><br><span class="line"><span class="comment">* 对某个对象加锁</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:47</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object(); <span class="comment">// o 是引用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    栈          __________________</span></span><br><span class="line"><span class="comment">     * |        |    |   new Object()   |</span></span><br><span class="line"><span class="comment">     * |        |   /|------------------|</span></span><br><span class="line"><span class="comment">     * |        |  / |                  |</span></span><br><span class="line"><span class="comment">     * |--------| /  |                  |</span></span><br><span class="line"><span class="comment">     * |___o____|/   |__________________|</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123; <span class="comment">//任何线程要执行下面的代码，必须先拿到o的锁</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t1 = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、this对象"><a href="#1-2、this对象" class="headerlink" title="1.2、this对象"></a>1.2、this对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized关键字</span></span><br><span class="line"><span class="comment">     * 对某个对象加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">//任何线程要执行下面的代码，必须先拿到this的锁</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、synchronized修饰函数"><a href="#1-3、synchronized修饰函数" class="headerlink" title="1.3、synchronized修饰函数"></a>1.3、synchronized修饰函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//等同于在方法的代码执行时要synchronized(this)</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、静态方法"><a href="#1-4、静态方法" class="headerlink" title="1.4、静态方法"></a>1.4、静态方法</h3><blockquote>
<p>synchronized 修饰static方法的时候，等同于synchronized(T.class)，</p>
<p>但是不能写synchronized(this)，静态的属性和方法不能new出当前对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//这里等同于synchronized(yxxy.c_004.T.class)</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(T<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">//考虑一下这里写synchronized(this)是否可以？不可以，静态的属性和方法不能new出当前对象</span></span><br><span class="line">            count --;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【5】有无synchronized修饰的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T5;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T5</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分析一下这个程序的输出</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T5</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T5 t = <span class="keyword">new</span> T5();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不加结果如下：</p>
<p><img alt="1552033919404" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552033919404.png" class="lazyload"></p>
<p>加了结果如下：</p>
<p><img alt="1552033984991" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552033984991.png" class="lazyload"></p>
<p><strong>得出结论，有synchronized修饰可以保证count在修改操作的时候保证只有一个线程可以操作，而其他线程必须等待，知道拿到锁才可以进行修改</strong></p>
<h3 id="1-5、synchronized优化"><a href="#1-5、synchronized优化" class="headerlink" title="1.5、synchronized优化"></a>1.5、synchronized优化</h3><blockquote>
<p>同步代码块中的语句越少越好,细粒度锁，提高效率</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">        count ++;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">        <span class="comment">//采用细粒度的锁，可以使线程争用时间变短，从而提高效率</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、面试1"><a href="#2、面试1" class="headerlink" title="2、面试1"></a>2、面试1</h2><blockquote>
<p>同步方法和非同步方法是否可以同时调用？</p>
<p>可以调用，两者没有冲突</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T7;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T7</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:57</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同步和非同步方法是否可以同时调用？</span></span><br><span class="line"><span class="comment">* 可以，两者没有冲突</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T7 t = <span class="keyword">new</span> T7();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*new Thread(()-&gt;t.m1(), "t1").start();</span></span><br><span class="line"><span class="comment">        new Thread(()-&gt;t.m2(), "t2").start();*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、面试2"><a href="#3、面试2" class="headerlink" title="3、面试2"></a>3、面试2</h2><blockquote>
<p>一个Account类的set、get方法是否会产生脏读?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对业务写方法加锁</span></span><br><span class="line"><span class="comment">* 对业务读方法不加锁</span></span><br><span class="line"><span class="comment">* 容易产生脏读问题（dirtyRead）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 在set的时候可能会出现balance未赋值时刚好另一个在取值，若不加锁，则会以默认值输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T8Account</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">double</span> <span class="title">getBalance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T8Account a = <span class="keyword">new</span> T8Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;a.set(<span class="string">"zhangsan"</span>, <span class="number">100.0</span>)).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552035524226" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035524226.png" class="lazyload"></p>
<p>给set和get加上synchronized后结果如下：</p>
<p><img alt="1552035597466" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035597466.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：在使用set方法存储信息的时候，假设利用sleep来模拟这期间的其他进程get的时候，可能会读出默认值的情况，所以需要给set和get方法加上synchronized关键字</strong></span></p>
</blockquote>
<h2 id="4、面试3"><a href="#4、面试3" class="headerlink" title="4、面试3"></a>4、面试3</h2><blockquote>
<p>synchronized是否可以重获锁？</p>
</blockquote>
<h3 id="【1】同类中的两个方法"><a href="#【1】同类中的两个方法" class="headerlink" title="【1】同类中的两个方法"></a>【1】同类中的两个方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T9;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T9</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      11:02</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment">* 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current::this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">"m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m2 start"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current::this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m2 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T9 t = <span class="keyword">new</span> T9();</span><br><span class="line">        t.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552035830633" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035830633.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：    一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。也就是说synchronized获得的锁是可重入的。</strong></span></p>
</blockquote>
<h3 id="【2】父子类的情形"><a href="#【2】父子类的情形" class="headerlink" title="【2】父子类的情形"></a>【2】父子类的情形</h3><h4 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T10;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment">* 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment">* 这里是继承中有可能发生的情形，子类调用父类的同步方法</span></span><br><span class="line"><span class="comment">* 子类的同步方法可以调用父类的同步方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this::"</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">        System.out.println(<span class="string">"child m start"</span>);</span><br><span class="line">        <span class="keyword">super</span>.m();</span><br><span class="line">        System.out.println(<span class="string">"child m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TT().m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552036140086" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552036140086.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：在对子类进行创建对象，调用子类函数同时调用父类函数，两边的synchronized对象都是子类对象</strong></span></p>
</blockquote>
<h2 id="5、程序在执行过程中，如果出现异常，锁会被释放"><a href="#5、程序在执行过程中，如果出现异常，锁会被释放" class="headerlink" title="5、程序在执行过程中，如果出现异常，锁会被释放"></a>5、程序在执行过程中，如果出现异常，锁会被释放</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T11;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T11</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      11:06</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 程序在执行过程中，如果出现异常，默认情况锁会被释放</span></span><br><span class="line"><span class="comment">* 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。</span></span><br><span class="line"><span class="comment">* 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，</span></span><br><span class="line"><span class="comment">* 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。</span></span><br><span class="line"><span class="comment">* 因此要非常小心的处理同步业务逻辑中的异常</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">5</span>) &#123;</span><br><span class="line">               <span class="comment">/* try&#123;</span></span><br><span class="line"><span class="comment">                    int i = 1/0; //此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span></span><br><span class="line"><span class="comment">                    System.out.println(i);</span></span><br><span class="line"><span class="comment">                &#125;catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*        Runnable r1 = ()-&gt;&#123;</span></span><br><span class="line"><span class="comment">          t.m();</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="chair" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/chair.gif" class="lazyload"></p>
<p>若将异常放在try…catch中，则锁不会被释放</p>
<p><img alt="chair1" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/chair1.gif" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：线程中出现异常则会释放锁，为保证安全性，将出现异常的代码放在try…catch中，以保证线程的安全。</strong></span></p>
</blockquote>
<h2 id="6、volatile-关键字"><a href="#6、volatile-关键字" class="headerlink" title="6、volatile 关键字"></a>6、volatile 关键字</h2><h3 id="6-1、可见性"><a href="#6-1、可见性" class="headerlink" title="6.1、可见性"></a>6.1、可见性</h3><blockquote>
<pre><code>volatile 关键字，使一个变量在多个线程间可见
A、B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道
使用volatile关键字，会让所有线程都会读到变量的修改值</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>; <span class="comment">//对比一下有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;</span><br><span class="line">            <span class="comment">/* 睡眠了一段时间，cpu会去堆内存中重新获取running的值，就会结束掉。</span></span><br><span class="line"><span class="comment">                若不设置，cpu没空去获取修改后的值</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.MILLISECONDS.sleep(10);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>结论：若不加volatile，则代码会一直运行

在上面的代码中，running是存在于堆内存的t对象中当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行

使用volatile，将会强制所有线程都去堆内存中读取running的值

![1552048554763](http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552048554763.png)

可以阅读这篇文章进行更深入的理解
http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html

volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized

 保证线程之间的内存可见性 能用volatile的时候就不用加锁，无锁同步，synchronized做同步效率低</code></pre></blockquote>
<h3 id="6-2、原子性"><a href="#6-2、原子性" class="headerlink" title="6.2、原子性"></a>6.2、原子性</h3><blockquote>
<pre><code>volatile具备可见性，不具备原子性

synchronized保证可见性和原子性。效率低

volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) count++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o)-&gt;o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o)-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();    <span class="comment">//调用join方法，等待线程o执行完毕</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552048954983" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552048954983.png" class="lazyload"></p>
<blockquote>
<p>由此可见，volatile只保证了可见性，不保证原子性，效率高。</p>
<p>比如A、B线程，A获取到count是100，正准备+1，</p>
<p>B线程此时获取count的时候也是100，也在+1，那么最终的count不是102，应该是101。</p>
<p>volatile可以重复读取，没有保证数据的原子性。</p>
</blockquote>
<p>对以上代码做修改，将需要同步的代码用synchronized修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对比上一个程序，可以用synchronized解决，synchronized可以保证可见性和原子性，volatile只能保证可见性</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552049314896" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552049314896.png" class="lazyload"></p>
<h2 id="7、AtomicXXX类"><a href="#7、AtomicXXX类" class="headerlink" title="7、AtomicXXX类"></a>7、AtomicXXX类</h2><blockquote>
<p>AtomXXX类效率非常高<br>AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="comment">//int count = 0;</span></span><br><span class="line"> </span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            <span class="comment">//if count.get() &lt; 1000     若同时调用AtomXXX类的多个方法，而之间不加锁的话，还是会被打断</span></span><br><span class="line">            <span class="comment">// ++ 不具备原子性    incrementAndGet具备原子性</span></span><br><span class="line">            <span class="comment">//保证线程执行时不会被其他线程打断</span></span><br><span class="line">            count.incrementAndGet(); <span class="comment">//count++</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552049484456" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552049484456.png" class="lazyload"></p>
<blockquote>
<p>结论： ++不保证原子性，AtomXXX类保证原子性</p>
<p>AtomXXX类对象不可使用使用多个方法，方法彼此之间不保证具有原子性</p>
</blockquote>
<h2 id="8、对象锁改变"><a href="#8、对象锁改变" class="headerlink" title="8、对象锁改变"></a>8、对象锁改变</h2><blockquote>
<p>锁定某对象o，如果o的属性发生改变，不影响锁的使用。但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">//启动第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建第二个线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t::m, <span class="string">"t2"</span>);</span><br><span class="line"> </span><br><span class="line">        t.o = <span class="keyword">new</span> Object(); <span class="comment">//锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object.gif" class="lazyload"></p>
<h2 id="9、不要以字符串常量作为锁定对象"><a href="#9、不要以字符串常量作为锁定对象" class="headerlink" title="9、不要以字符串常量作为锁定对象"></a>9、不要以字符串常量作为锁定对象</h2><blockquote>
<p>不要以字符串常量作为锁定对象<br>在下面的例子中，m1和m2其实锁定的是同一个对象<br>这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，<br>但是你读不到源码，所以你在自己的代码中也锁定了”Hello”,这时候就有可能发生非常诡异的死锁阻塞，<br>因为你的程序和你用到的类库不经意间使用了同一把锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    String s2 = <span class="string">"Hello"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10、面试"><a href="#10、面试" class="headerlink" title="10、面试"></a>10、面试</h2><blockquote>
<p>题目：<br> 实现一个容器，提供两个方法，add，size<br> 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</p>
</blockquote>
<h3 id="解法一：使用volatile"><a href="#解法一：使用volatile" class="headerlink" title="解法一：使用volatile"></a>解法一：使用volatile</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer2 c = <span class="keyword">new</span> MyContainer2();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red"><strong>结论：给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu</strong></span></p>
</blockquote>
<h3 id="解法二：使用wait-、notify"><a href="#解法二：使用wait-、notify" class="headerlink" title="解法二：使用wait()、notify()"></a>解法二：使用wait()、notify()</h3><blockquote>
<p>需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以<br>这里使用wait和notify做到，wait会释放锁，而notify不会释放锁,所以若想t1执行，则必须再次wait()让t2释放锁才行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer4</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer4 c = <span class="keyword">new</span> MyContainer4();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">                <span class="keyword">if</span>(c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">                <span class="comment">//通知t1继续执行</span></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                    c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        <span class="comment">//释放锁，让t2得以执行</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object1" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object1.gif" class="lazyload"></p>
<h3 id="解法三：使用CountDownLatch"><a href="#解法三：使用CountDownLatch" class="headerlink" title="解法三：使用CountDownLatch"></a>解法三：使用CountDownLatch</h3><blockquote>
<p>使用Latch（门闩）替代wait notify来进行通知<br>好处是通信方式简单，同时也可以指定等待时间<br>使用await和countdown方法替代wait和notify<br>CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行<br>当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了<br>这时应该考虑countdownlatch/cyclicbarrier/semaphore</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer5</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer5 c = <span class="keyword">new</span> MyContainer5();</span><br><span class="line"> </span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">            <span class="keyword">if</span> (c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"size为5"</span>);</span><br><span class="line">                    <span class="comment">//也可以指定等待时间</span></span><br><span class="line">                    <span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打开门闩，让t2得以执行</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object12" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object12.gif" class="lazyload"></p>
<h1 id="java多线程、高并发编程二"><a href="#java多线程、高并发编程二" class="headerlink" title="java多线程、高并发编程二"></a>java多线程、高并发编程二</h1><blockquote>
<p> java多线程三个主要部分</p>
<ul>
<li>synchronizer</li>
<li>同步容器</li>
<li>ThreadPool、executor</li>
</ul>
</blockquote>
<h2 id="1、ReentrantLock关键字"><a href="#1、ReentrantLock关键字" class="headerlink" title="1、ReentrantLock关键字"></a>1、ReentrantLock关键字</h2><h3 id="1、手动锁"><a href="#1、手动锁" class="headerlink" title="1、手动锁"></a>1、手动锁</h3><blockquote>
<p>使用reentrantlock可以完成同样的功能</p>
<ul>
<li>需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</li>
<li>使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</li>
</ul>
<p><span style="color:red"><strong>ReentrantLock是手动锁，自己创建自己释放</strong></span></p>
<p><span style="color:red"><strong>synchronized是自动锁，{}范围就行</strong></span></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//synchronized(this)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"m2 ..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock2 rl = <span class="keyword">new</span> ReentrantLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552119906562" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552119906562.png" class="lazyload"></p>
<h3 id="2、尝试锁定"><a href="#2、尝试锁定" class="headerlink" title="2、尝试锁定"></a>2、尝试锁定</h3><blockquote>
<pre><code>使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待

根据tryLock的返回值来判定是否锁定  lock.lock()

可以指定tryLock的时间  lock.tryLock(5, TimeUnit.SECONDS)</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行</span></span><br><span class="line"><span class="comment">     * 可以根据tryLock的返回值来判定是否锁定</span></span><br><span class="line"><span class="comment">     * 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean locked = lock.tryLock();</span></span><br><span class="line"><span class="comment">        System.out.println("m2 ..." + locked);</span></span><br><span class="line"><span class="comment">        if(locked) lock.unlock();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">"m2 ..."</span> + locked);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked) lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock3 rl = <span class="keyword">new</span> ReentrantLock3();</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、打断线程"><a href="#3、打断线程" class="headerlink" title="3、打断线程"></a>3、打断线程</h3><blockquote>
<p>使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，在一个线程等待锁的过程中，可以被打断。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T20;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ReentrantLock1</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      22:49</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* reentrantlock用于替代synchronized</span></span><br><span class="line"><span class="comment">* 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span></span><br><span class="line"><span class="comment">* 这里是复习synchronized最原始的语义</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用reentrantlock可以完成同样的功能</span></span><br><span class="line"><span class="comment">* 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span></span><br><span class="line"><span class="comment">* 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，</span></span><br><span class="line"><span class="comment">* 在一个线程等待锁的过程中，可以被打断</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//lock.lock();</span></span><br><span class="line">                System.out.println(<span class="string">"----------3"</span>);</span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">//可以对interrupt()方法做出响应</span></span><br><span class="line">                System.out.println(<span class="string">"----------4"</span>);</span><br><span class="line">                System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="string">"t2 end"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> locked = ((ReentrantLock) lock).isLocked();<span class="comment">//查询此锁是否由任何线程持有</span></span><br><span class="line">                System.out.println(<span class="string">"locked::"</span>+locked);</span><br><span class="line">                <span class="keyword">if</span> (locked != <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//不能释放别人打开的锁，否则报错Exception in thread "Thread-1" java.lang.IllegalMonitorStateException</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------1"</span>);</span><br><span class="line">        t2.interrupt(); <span class="comment">//打断线程2的等待</span></span><br><span class="line">        System.out.println(<span class="string">"-----------2"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552120908663" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552120908663.png" class="lazyload"></p>
<p>程序执行流程如下：</p>
<p><img alt="1552121643790" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552121643790.png" class="lazyload"></p>
<h3 id="4、公平锁"><a href="#4、公平锁" class="headerlink" title="4、公平锁"></a>4、公平锁</h3><blockquote>
<p>每一个线程都能平等分配到lock，只需在创建对象带入参数true即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//参数为true表示为公平锁，请对比输出结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock5 rl=<span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        Thread th1=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th2=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th3=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th4=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">        th4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>每个线程都能平等有序的分配到锁</p>
<p><img alt="1552121776463" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552121776463.png" class="lazyload"></p>
<h2 id="2、面试题"><a href="#2、面试题" class="headerlink" title="2、面试题"></a>2、面试题</h2><blockquote>
<p>面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</p>
<p>假设：生产者2个，每个生产25件。消费者10个，每个消费5件</p>
</blockquote>
<h3 id="解法一：使用synchronized、wait、notify"><a href="#解法一：使用synchronized、wait、notify" class="headerlink" title="解法一：使用synchronized、wait、notify"></a>解法一：使用synchronized、wait、notify</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T21;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/9</span></span><br><span class="line"><span class="comment"> * Time      21:34</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">10</span>;    <span class="comment">//限制容器大小10</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(list.size() == NUM)&#123;</span><br><span class="line">            System.out.println(<span class="string">"容器已满..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"正在存 ..."</span>+obj);</span><br><span class="line">        list.add(obj);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();<span class="comment">//通知所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"容器空,等待中..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T first = list.removeFirst();</span><br><span class="line">        System.out.println(<span class="string">"正在取..."</span> + first);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();<span class="comment">//通知所有等待线程</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test&lt;String&gt; test = <span class="keyword">new</span> Test&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;<span class="comment">//消费者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+test.get());</span><br><span class="line">            &#125;,<span class="string">"consumer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;<span class="comment">//生产者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++)</span><br><span class="line">                    test.put(Thread.currentThread().getName()+<span class="string">" "</span>+j);</span><br><span class="line">            &#125;,<span class="string">"producer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object123" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object123-1552145403929.gif" class="lazyload"></p>
<p>程序原理图如下：</p>
<h3 id="解法二：使用Lock、Condition"><a href="#解法二：使用Lock、Condition" class="headerlink" title="解法二：使用Lock、Condition"></a>解法二：使用Lock、Condition</h3><blockquote>
<p>使用Lock和Condition来实现<br>对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size() == MAX) &#123; <span class="comment">//想想为什么用while而不是用if？</span></span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            lists.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll(); <span class="comment">//通知消费者线程进行消费</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = lists.removeFirst();</span><br><span class="line">            count --;</span><br><span class="line">            producer.signalAll(); <span class="comment">//通知生产者进行生产</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer2&lt;String&gt; c = <span class="keyword">new</span> MyContainer2&lt;&gt;();</span><br><span class="line">        <span class="comment">//启动消费者线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) System.out.println(c.get());</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//启动生产者线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">            &#125;, <span class="string">"p"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、ThreadLocal关键字"><a href="#3、ThreadLocal关键字" class="headerlink" title="3、ThreadLocal关键字"></a>3、ThreadLocal关键字</h2><blockquote>
<p>ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
</blockquote>
<p>抛砖引玉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T22;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ThreadLocal1</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocal线程局部变量</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 马士兵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(p.name);</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            p.name = <span class="string">"lisi"</span>;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552181901880" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552181901880.png" class="lazyload"></p>
<blockquote>
<p>程序执行过程：</p>
<p>两个线程同时启动，第一个线程先睡2秒，第二个线程睡1秒后将name改掉后第一个线程输出lisi</p>
</blockquote>
<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><blockquote>
<p>ThreadLocal 用来提供线程的局部变量</p>
<p><span style="color:red"><strong>当前线程存的变量只能在当前线程中使用，其他线程无法使用</strong></span></p>
<p><span style="color:red"><strong>使用ThreadLocal的数据不用上锁</strong></span></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T22;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ThreadLocal2</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocal线程局部变量</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ThreadLocal是使用空间换时间，synchronized是使用时间换空间</span></span><br><span class="line"><span class="comment">* 比如在hibernate中session就存在与ThreadLocal中，避免synchronized的使用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 运行下面的程序，理解ThreadLocal</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 马士兵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile static Person p = new Person();</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Person&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(tl.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            tl.set(<span class="keyword">new</span> Person());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="1552182492710" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552182492710.png" class="lazyload"></p>
<blockquote>
<p>闲谈：</p>
<p>数据库的高并发的处理：</p>
<p>加索引、分库、分表、读写分离、主从结构</p>
</blockquote>
<h2 id="4、Singleton-单例模式"><a href="#4、Singleton-单例模式" class="headerlink" title="4、Singleton 单例模式"></a>4、Singleton 单例模式</h2><blockquote>
<p><strong>单例模式就是说系统中对于某类的只能有一个对象，不可能出来第二个</strong></p>
</blockquote>
<h3 id="1、实例一（不使用同步锁）"><a href="#1、实例一（不使用同步锁）" class="headerlink" title="1、实例一（不使用同步锁）"></a>1、实例一（不使用同步锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sin=<span class="keyword">new</span> Singleton();    <span class="comment">///直接初始化一个实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;    <span class="comment">///private类型的构造函数，保证其他类对象不能直接new一个该对象的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSin</span><span class="params">()</span></span>&#123;    <span class="comment">///该类唯一的一个public方法  </span></span><br><span class="line">        <span class="keyword">return</span> sin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中的一个缺点是该类加载的时候就会直接new 一个静态对象出来，当系统中这样的类较多时，会使得启动速度变慢 。现在流行的设计都是讲<strong>“延迟加载”</strong>，我们可以在第一次使用的时候才初始化第一个该类对象。所以这种适合在小系统。</p>
</blockquote>
<h3 id="2、实例二（使用同步锁）"><a href="#2、实例二（使用同步锁）" class="headerlink" title="2、实例二（使用同步锁）"></a>2、实例二（使用同步锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>)   </span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、实例三（小粒度双重同步锁）"><a href="#3、实例三（小粒度双重同步锁）" class="headerlink" title="3、实例三（小粒度双重同步锁）"></a>3、实例三（小粒度双重同步锁）</h3><blockquote>
<p>上述代码中的一次锁住了一个方法， 这个粒度有点大 ，改进就是只锁住其中的new语句就OK。就是所谓的“双重锁”机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                   instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、内部类方式："><a href="#4、内部类方式：" class="headerlink" title="4、内部类方式："></a>4、内部类方式：</h3><blockquote>
<p> 既不用加锁，也能实现懒加载</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"single"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">200</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Singleton.getSingle());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Arrays.asList(ths).forEach(o-&gt;o.start());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、面试题-买票"><a href="#5、面试题-买票" class="headerlink" title="5、面试题 买票"></a>5、面试题 买票</h2><blockquote>
<p>有N张火车票，每张票都有一个编号<br>同时有10个窗口对外售票<br>请写一个模拟程序</p>
</blockquote>
<h3 id="程序一："><a href="#程序一：" class="headerlink" title="程序一："></a>程序一：</h3><blockquote>
<p>出现超卖的情况</p>
<p>list的方法不具备原子性操作，会出现只剩一个的时候多个线程同时remove导致下面的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) tickets.add(<span class="string">"票编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552194906999" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552194906999.png" class="lazyload"></p>
<h3 id="程序二：使用Vector"><a href="#程序二：使用Vector" class="headerlink" title="程序二：使用Vector"></a>程序二：使用Vector</h3><blockquote>
<p>以下代码在while中加入睡眠10秒后依然会出现上面的问题</p>
<p>原因：</p>
<p>Vector的方法虽然具备原子操作，但是同时使用两个方法不能保证原子操作，size()的原子操作范围只在判断处，remove()的原子操作在后面，判断操作和修改操作分离了，不在同一个原子操作中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Vector&lt;String&gt; tickets = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：<br>就算操作A和B都是同步的，但A和B组成的复合操作也未必是同步的，仍然需要自己进行同步<br>就像这个程序，判断size和进行remove必须是一整个的原子操作</strong></p>
</blockquote>
<h3 id="程序三：使用synchronized"><a href="#程序三：使用synchronized" class="headerlink" title="程序三：使用synchronized"></a>程序三：使用synchronized</h3><blockquote>
<p>下面程序不会出现问题，synchronized保证了tickets操作时的原子性，但是synchronized的效率很低。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(tickets) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(tickets.size() &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="程序四：使用ConcurrentLinkedQueue"><a href="#程序四：使用ConcurrentLinkedQueue" class="headerlink" title="程序四：使用ConcurrentLinkedQueue"></a>程序四：使用ConcurrentLinkedQueue</h3><blockquote>
<p>程序正常运行，不会出错。</p>
<p>ConcurrentLinkedQueue 的底层使用的是CAS算法，而非synchronized，效率高。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Queue&lt;String&gt; tickets = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    String s = tickets.poll();</span><br><span class="line">                    <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> System.out.println(<span class="string">"销售了--"</span> + s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、Map、Set"><a href="#6、Map、Set" class="headerlink" title="6、Map、Set"></a>6、Map、Set</h2><blockquote>
<p>对于map、set<br>不使用多线程（不加锁）：HashMap、TreeMap、LinkedHashMap</p>
<p>并发量小（加锁）：Hashtable、Collections.sychronizedXXX  （不怎么用，将不加锁的map转成上锁的map）</p>
<p>并发量大：ConcurrentHashMap  ConcurrentSkipListMap</p>
</blockquote>
<h3 id="1、ConcurrentMap关键字"><a href="#1、ConcurrentMap关键字" class="headerlink" title="1、ConcurrentMap关键字"></a>1、ConcurrentMap关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* http://blog.csdn.net/sunxianghuang/article/details/52221913</span></span><br><span class="line"><span class="comment">* http://www.educity.cn/java/498061.html</span></span><br><span class="line"><span class="comment">* 阅读concurrentskiplistmap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ConcurrentMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();    //262ms 大锁分成小锁</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(); <span class="comment">//高并发并且排序  340ms</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();    //370ms</span></span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //Collections.synchronizedXXX</span></span><br><span class="line">        <span class="comment">//TreeMap</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(ths.length);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) map.put(<span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>), <span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7、队列"><a href="#7、队列" class="headerlink" title="7、队列"></a>7、队列</h2><blockquote>
<p>不需要同步队列：ArrayList、LinkedList</p>
<p>并发量比较低：Collections.synchronizedXXX</p>
<p>写少读多（没有脏读，不需要锁）：CopyOnWriteList</p>
<p>并发量高：Queue<br> [1]高并发加锁队列<br> CocurrentLinkedQueue //concurrentArrayQueue<br> [2]阻塞式队列<br> BlockingQueue<br>     LinkedBQ<br>     ArrayBQ<br>     TransferQueue<br>     SynchronusQueue<br> DelayQueue——执行定时任务</p>
</blockquote>
<h3 id="1、CopyOnWriteArrayList关键字"><a href="#1、CopyOnWriteArrayList关键字" class="headerlink" title="1、CopyOnWriteArrayList关键字"></a>1、CopyOnWriteArrayList关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 写时复制容器 copy on write</span></span><br><span class="line"><span class="comment">* 多线程环境下，写时效率低，读时效率高</span></span><br><span class="line"><span class="comment">* 适合写少读多的环境</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; lists =</span><br><span class="line">                <span class="comment">//new ArrayList&lt;&gt;(); //这个会出并发问题！</span></span><br><span class="line">                <span class="comment">//new Vector();</span></span><br><span class="line">                <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) lists.add(<span class="string">"a"</span> + r.nextInt(<span class="number">10000</span>));</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        runAndComputeTime(ths);</span><br><span class="line"> </span><br><span class="line">        System.out.println(lists.size());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAndComputeTime</span><span class="params">(Thread[] ths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();<span class="comment">//Waits for this thread to die.</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(s2 - s1);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Collections-synchronizedListXXX"><a href="#2、Collections-synchronizedListXXX" class="headerlink" title="2、Collections.synchronizedListXXX"></a>2、Collections.synchronizedListXXX</h3><blockquote>
<p>给list加锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SynchronizedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//给strs加锁，所有方法都上了锁</span></span><br><span class="line">        List&lt;String&gt; strsSync = Collections.synchronizedList(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、ConcurrentLinkedQueue-关键字"><a href="#3、ConcurrentLinkedQueue-关键字" class="headerlink" title="3、ConcurrentLinkedQueue 关键字"></a>3、ConcurrentLinkedQueue 关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ConcurrentQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; strs = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            strs.offer(<span class="string">"a"</span> + i);  <span class="comment">//add 若满了，add会报异常，offer会返回false</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs);</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.poll());<span class="comment">//拿头出来并删除</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.peek());<span class="comment">//拿头出来不删除</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//双端队列Deque</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4、LinkedBlockingQueue关键字"><a href="#4、LinkedBlockingQueue关键字" class="headerlink" title="4、LinkedBlockingQueue关键字"></a>4、LinkedBlockingQueue关键字</h3><blockquote>
<p>生产一个，消费一个，不论空的还是满的都会在等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();<span class="comment">//如果不指定容量，默认为Integer.MAX_VALUE 无界队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个生产者，生产100个</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"生产 -"</span>+i);</span><br><span class="line">                    strs.put(<span class="string">"a"</span> + i); <span class="comment">//如果满了，就会等待</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"p1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//5个消费者进行消费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" take -"</span> + strs.take()); <span class="comment">//如果空了，就会等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552303987293" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552303987293.png" class="lazyload"></p>
<h3 id="5、ArrayBlockingQueue关键字"><a href="#5、ArrayBlockingQueue关键字" class="headerlink" title="5、ArrayBlockingQueue关键字"></a>5、ArrayBlockingQueue关键字</h3><blockquote>
<p>有序队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);<span class="comment">//有界队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            strs.put(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        strs.put(<span class="string">"aaa"</span>); <span class="comment">//满了就会等待，程序阻塞</span></span><br><span class="line">        <span class="comment">//strs.add("aaa");</span></span><br><span class="line">        <span class="comment">//strs.offer("aaa");//add 若满了，add会报异常，offer会返回false</span></span><br><span class="line">        <span class="comment">//strs.offer("aaa", 1, TimeUnit.SECONDS);//按时间段加值，若加不进去就不加</span></span><br><span class="line"> </span><br><span class="line">        System.out.println(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、DelayQueue-关键字"><a href="#6、DelayQueue-关键字" class="headerlink" title="6、DelayQueue 关键字"></a>6、DelayQueue 关键字</h3><blockquote>
<p>DelayQueue 常用于执行定时任务，且队列中的对象必须实现Delayed的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();<span class="comment">//无界队列，但是消费的时候需要在一定固定时间后才能拿出来</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> runningTime;</span><br><span class="line"> </span><br><span class="line">        MyTask(<span class="keyword">long</span> rt) &#123;</span><br><span class="line">            <span class="keyword">this</span>.runningTime = rt;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还剩多长时间才能拿出</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span> + runningTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        MyTask t1 = <span class="keyword">new</span> MyTask(now + <span class="number">1000</span>);</span><br><span class="line">        MyTask t2 = <span class="keyword">new</span> MyTask(now + <span class="number">2000</span>);</span><br><span class="line">        MyTask t3 = <span class="keyword">new</span> MyTask(now + <span class="number">1500</span>);</span><br><span class="line">        MyTask t4 = <span class="keyword">new</span> MyTask(now + <span class="number">2500</span>);</span><br><span class="line">        MyTask t5 = <span class="keyword">new</span> MyTask(now + <span class="number">500</span>);</span><br><span class="line"> </span><br><span class="line">        tasks.put(t1);</span><br><span class="line">        tasks.put(t2);</span><br><span class="line">        tasks.put(t3);</span><br><span class="line">        tasks.put(t4);</span><br><span class="line">        tasks.put(t5);</span><br><span class="line"> </span><br><span class="line">        System.out.println(tasks);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(tasks.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、SynchronousQueue-关键字"><a href="#7、SynchronousQueue-关键字" class="headerlink" title="7、SynchronousQueue 关键字"></a>7、SynchronousQueue 关键字</h3><blockquote>
<p>不进入队列，当生产者生产出来的时候，必须要有消费者进行消费</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SynchronusQueue</span> </span>&#123;<span class="comment">//容量为0，有东西来消费者必须要消费掉</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(strs.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        strs.put(<span class="string">"aaa"</span>); <span class="comment">//阻塞等待消费者消费</span></span><br><span class="line">        <span class="comment">//strs.add("aaa");</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="案例：依次打印ABABABAB…"><a href="#案例：依次打印ABABABAB…" class="headerlink" title="案例：依次打印ABABABAB…."></a>案例：依次打印ABABABAB….</h2><h3 id="解法一：使用wait-notify"><a href="#解法一：使用wait-notify" class="headerlink" title="解法一：使用wait()  notify()"></a>解法一：使用wait()  notify()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T25.printAB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/10</span></span><br><span class="line"><span class="comment"> * Time      22:21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.print(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.print(<span class="string">"B"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    object.notify();<span class="comment">//先通知</span></span><br><span class="line">                    object.wait();<span class="comment">//后释放</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.A();</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.B();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="AB" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AB.gif" class="lazyload"></p>
<h3 id="解法二：使用ReentrantLock"><a href="#解法二：使用ReentrantLock" class="headerlink" title="解法二：使用ReentrantLock"></a>解法二：使用ReentrantLock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T25.printAB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test2</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/10</span></span><br><span class="line"><span class="comment"> * Time      23:12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition ca = lock.newCondition();</span><br><span class="line">    Condition cb = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            System.out.print(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                ca.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cb.signalAll();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            System.out.print(<span class="string">"B"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                ca.signalAll();</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test2.A();</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test2.B();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="java多线程、高并发编程三"><a href="#java多线程、高并发编程三" class="headerlink" title="java多线程、高并发编程三"></a>java多线程、高并发编程三</h1><h2 id="1、线程池须知的一些接口和类"><a href="#1、线程池须知的一些接口和类" class="headerlink" title="1、线程池须知的一些接口和类"></a>1、线程池须知的一些接口和类</h2><h3 id="1、Executor-关键字"><a href="#1、Executor-关键字" class="headerlink" title="1、Executor 关键字"></a>1、Executor 关键字</h3><blockquote>
<p>调用executor的execute方法会执行Runnable的run方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 认识Executor   执行任务的接口，只有一个方法execute</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T01_MyExecutor().execute(()-&gt;System.out.println(<span class="string">"hello executor"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Thread(command).run();</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、ExecutorService-关键字"><a href="#2、ExecutorService-关键字" class="headerlink" title="2、ExecutorService 关键字"></a>2、ExecutorService 关键字</h3><blockquote>
<p>对Executor的拓展接口，其中的submit方法带有返回值</p>
</blockquote>
<p><img alt="1552379303479" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552379303479.png" class="lazyload"></p>
<h3 id="3、Callable-关键字"><a href="#3、Callable-关键字" class="headerlink" title="3、Callable 关键字"></a>3、Callable 关键字</h3><blockquote>
<p>Callable类似于Runnable</p>
<p>Runnable的run方法没有返回值，Callable的call方法有返回值</p>
</blockquote>
<p><img alt="1552379414728" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552379414728.png" class="lazyload"></p>
<h3 id="4、Executors-、Executor"><a href="#4、Executors-、Executor" class="headerlink" title="4、Executors 、Executor"></a>4、Executors 、Executor</h3><blockquote>
<p>Executor用来执行提交的对象Runnable任务</p>
<p>Executors用来调度何种线程池</p>
</blockquote>
<h2 id="2、Executors-线程池"><a href="#2、Executors-线程池" class="headerlink" title="2、Executors 线程池"></a>2、Executors 线程池</h2><h3 id="1、newFixedThreadPool"><a href="#1、newFixedThreadPool" class="headerlink" title="1、newFixedThreadPool"></a>1、newFixedThreadPool</h3><table>
<thead>
<tr>
<th>newFixedThreadPool(int nThreads)</th>
</tr>
</thead>
<tbody><tr>
<td>创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。</td>
</tr>
</tbody></table>
<p>static ExecutorService newFixedThreadPool(int nThreads)</p>
<blockquote>
<p><img alt="1552380480772" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552380480772.png" class="lazyload"></p>
<p>创建一个线程池，传入固定的线程数</p>
<p>将线程放入LinkedBlockingQueue队列中</p>
</blockquote>
<p><strong>下述代码中：</strong></p>
<pre><code>使用Executor的子接口ExecutorService来创建5个固定线程的线程池，调用execute方法便是执行了Runnable的run方法，执行了睡500毫秒打印当前线程名的任务</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//execute执行无返回值 submit执行有/无返回值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        service.shutdown();<span class="comment">//等所有任务执行完才能关闭</span></span><br><span class="line">        System.out.println(service.isTerminated());<span class="comment">//查看是否所有任务执行完</span></span><br><span class="line">        System.out.println(service.isShutdown());<span class="comment">//是不是关闭了</span></span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(service.isTerminated());</span><br><span class="line">        System.out.println(service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552380940265" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552380940265.png" class="lazyload"></p>
<h4 id="1、Future接口实现类——FutureTask"><a href="#1、Future接口实现类——FutureTask" class="headerlink" title="1、Future接口实现类——FutureTask"></a>1、Future接口实现类——FutureTask</h4><blockquote>
<p>线程可以输出返回值</p>
</blockquote>
<table>
<thead>
<tr>
<th>FutureTask(Callable<v> callable)</v></th>
</tr>
</thead>
<tbody><tr>
<td>创建一个 <code>FutureTask</code> ，它将在运行时执行给定的 <code>Callable</code>，并给出返回值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_Future</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;); <span class="comment">//new Callable () &#123; Integer call();&#125;</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(task.get()); <span class="comment">//阻塞，直到拿到Callable的call返回的值</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Future&lt;Integer&gt; f = service.submit(()-&gt;&#123;<span class="comment">//重写Callable的call方法</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">        System.out.println(f.isDone());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552398499806" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552398499806.png" class="lazyload"></p>
<h4 id="2、并行计算"><a href="#2、并行计算" class="headerlink" title="2、并行计算"></a>2、并行计算</h4><blockquote>
<p>5个线程并行计算1-200000以内的素数的时间</p>
</blockquote>
<p>在上述提到ExecutorService的submit方法的参数可以是Runnable，也可以是Callable，本次采用Callable可以收到返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池的概念</span></span><br><span class="line"><span class="comment">* nasa</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_ParallelComputing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//=====================不用线程，直接算1-200000之间的素数==============================</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        getPrime(<span class="number">1</span>, <span class="number">200000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> processors = Runtime.getRuntime().availableProcessors();<span class="comment">//返回当前电脑的cpu核数</span></span><br><span class="line">        System.out.println(<span class="string">"processorsNum::"</span>+processors);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//==========使用4个线程，将1-200000进行切片并行计算得到返回值============================</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpuCoreNum = <span class="number">4</span>;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class="line"> </span><br><span class="line">        MyTask t1 = <span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">80000</span>); <span class="comment">//1-5 5-10 10-15 15-20</span></span><br><span class="line">        MyTask t2 = <span class="keyword">new</span> MyTask(<span class="number">80001</span>, <span class="number">130000</span>);</span><br><span class="line">        MyTask t3 = <span class="keyword">new</span> MyTask(<span class="number">130001</span>, <span class="number">170000</span>);</span><br><span class="line">        MyTask t4 = <span class="keyword">new</span> MyTask(<span class="number">170001</span>, <span class="number">200000</span>);</span><br><span class="line"> </span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(t1);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(t2);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(t3);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(t4);</span><br><span class="line"> </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        f1.get();</span><br><span class="line">        f2.get();</span><br><span class="line">        f3.get();</span><br><span class="line">        f4.get();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startPos, endPos;</span><br><span class="line"> </span><br><span class="line">        MyTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = s;</span><br><span class="line">            <span class="keyword">this</span>.endPos = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; r = getPrime(startPos, endPos);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是素数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出start到end之间的素数，并放入list中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i)) results.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><strong>并行计算速度很快</strong></p>
<p><img alt="1552399229946" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552399229946.png" class="lazyload"></p>
<h3 id="2、CachedPool"><a href="#2、CachedPool" class="headerlink" title="2、CachedPool"></a>2、CachedPool</h3><blockquote>
<pre><code>弹性线程池，有一个任务，就开启一个线程，每个线程都activetime，超过这个时间未开启则销毁该线程

查看源码：存活时间为60s，无界队列，最大Integer.MAX_VALUE基本达不到
![1552399339664](http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552399339664.png)</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T08_CachedPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:51</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 弹性线程池，有一个任务，就开启一个线程，每个线程都activetime，超过这个时间未开启则销毁该线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_CachedPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">80</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552399699835" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552399699835.png" class="lazyload"></p>
<h3 id="3、newSingleThreadExecutor"><a href="#3、newSingleThreadExecutor" class="headerlink" title="3、newSingleThreadExecutor"></a>3、newSingleThreadExecutor</h3><blockquote>
<p>查看源码：线程数限制为1个</p>
<p><img alt="1552400118289" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400118289.png" class="lazyload"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line"> </span><br><span class="line">                System.out.println(j + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：只有一个线程在执行</strong></p>
<p><img alt="1552400068650" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400068650.png" class="lazyload"></p>
<h3 id="4、newScheduledThreadPool"><a href="#4、newScheduledThreadPool" class="headerlink" title="4、newScheduledThreadPool"></a>4、newScheduledThreadPool</h3><blockquote>
<p>源码查看：每隔一段时间执行一个线程</p>
<p><img alt="1552400446939" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400446939.png" class="lazyload"></p>
<p>service.scheduleAtFixedRate的相关参数</p>
<p><img alt="1552400730234" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400730234.png" class="lazyload"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_ScheduledPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="schedule" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/schedule.gif" class="lazyload"></p>
<h3 id="5、ForkJoinPool"><a href="#5、ForkJoinPool" class="headerlink" title="5、ForkJoinPool"></a>5、ForkJoinPool</h3><blockquote>
<p>原理和MapReduce类似</p>
</blockquote>
<p><img alt="1552401802490" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552401802490.png" class="lazyload"></p>
<blockquote>
<p>ForkJoinPool的execute方法的参数是ForkJoinTask类</p>
<p>ForkJoinTask类有两个直接子类分类为： RecursiveAction和RecursiveTask</p>
</blockquote>
<h4 id="案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算"><a href="#案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算" class="headerlink" title="案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算"></a><strong>案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算</strong></h4><p>下面代码的原理图如下：</p>
<p><img alt="1552465325571" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552465325571.png" class="lazyload"></p>
<h5 id="1、RecursiveAction子类实现"><a href="#1、RecursiveAction子类实现" class="headerlink" title="1、RecursiveAction子类实现"></a>1、RecursiveAction子类实现</h5><blockquote>
<p>无返回值，只能在compute方法中打印查看</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T12_ForkJoinPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.stream(nums).sum()); <span class="comment">//stream api</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"> </span><br><span class="line">        AddTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">                System.out.println(<span class="string">"from:"</span> + start + <span class="string">" to:"</span> + end + <span class="string">" = "</span> + sum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">                AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">                AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        <span class="comment">//long result = task.join();</span></span><br><span class="line">        <span class="comment">//System.out.println(result);</span></span><br><span class="line"> </span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552464765077" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552464765077.png" class="lazyload"></p>
<h5 id="2、RecursiveTask子类实现"><a href="#2、RecursiveTask子类实现" class="headerlink" title="2、RecursiveTask子类实现"></a>2、RecursiveTask子类实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T12_ForkJoinPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.stream(nums).sum()); <span class="comment">//stream api</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"> </span><br><span class="line">        AddTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">            AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">            subTask1.fork();</span><br><span class="line">            subTask2.fork();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        <span class="keyword">long</span> result = task.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//System.in.read();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、WorkStealingPool"><a href="#6、WorkStealingPool" class="headerlink" title="6、WorkStealingPool"></a>6、WorkStealingPool</h3><blockquote>
<p><strong>WorkStealingPool是在ForkJoinPool的基础上做了封装</strong></p>
<p>WorkStealingPool中的每个线程都有自己的任务队列，如果某一个线程完成后队列也没有任务，就会去其他的线程任务队列中拿任务做。主动找活干</p>
<p>由于我的电脑是12线程，所以我开了14个线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T11_WorkStealingPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:52</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 主动找活干</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_WorkStealingPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));<span class="comment">//daemon</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//由于产生的是精灵线程（守护线程、后台线程），主线程不阻塞的话，看不到输出</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line"> </span><br><span class="line">        R(<span class="keyword">int</span> t) &#123;</span><br><span class="line">            <span class="keyword">this</span>.time = t;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(time  + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552466044537" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552466044537.png" class="lazyload"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>如果想要自己打造一个线程池，可以继承ThreadPoolExecutor来创造自己的线程池</p>
<h2 id="parallelStream-API（多线程）"><a href="#parallelStream-API（多线程）" class="headerlink" title="parallelStream API（多线程）"></a>parallelStream API（多线程）</h2><blockquote>
<p><strong>jdk1.8新增的比较方便的接口，使用多线程来进行一起做事</strong></p>
<p>List中存着10000个数，并判断是否为素数，常规方法是遍历所有的数进行判断，速度慢。</p>
<p>Collection中提供了parallelStream的方式进行遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T14_ParallelStreamAPI</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:54</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T14_ParallelStreamAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) nums.add(<span class="number">1000000</span> + r.nextInt(<span class="number">1000000</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//System.out.println(nums);</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        nums.forEach(v-&gt;isPrime(v));</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用parallel stream api</span></span><br><span class="line"> </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        nums.parallelStream().forEach(T14_ParallelStreamAPI::isPrime);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>在判断10000个数是否为素数上速度差距很大</p>
<p><img alt="1552466241334" data-src="http://img.mxranger.cn/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552466241334.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现微信公众号信息推送</title>
    <url>/2019/11/17/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>本教程使用的是个人测试账号，企业微信公众号稍有出入<br>主要用来做服务异常报警处理，也可以使用推送邮件，但是显得过重，所以使用微信推送消息简洁</p>
</blockquote>
<h2 id="1、注册账号"><a href="#1、注册账号" class="headerlink" title="1、注册账号"></a>1、注册账号</h2><p>前往网站 <em><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></em> 注册账号</p>
<p>获取 appID 、 appsecret，后面有用</p>
<p><img alt="1557989221693" data-src="http://img.mxranger.cn/1557989221693.png" class="lazyload"></p>
<h2 id="2、获取ACCESS-TOKEN"><a href="#2、获取ACCESS-TOKEN" class="headerlink" title="2、获取ACCESS_TOKEN"></a>2、获取ACCESS_TOKEN</h2><blockquote>
<p> 官网教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183</a></p>
</blockquote>
<p><strong>注意：access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试账号id secret</span></span><br><span class="line">    appid = <span class="string">"xxxxxxxxxxxxxxxxxx"</span></span><br><span class="line">    secret = <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="</span>+appid+<span class="string">"&amp;secret="</span>+secret</span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    access_token = res.json()[<span class="string">"access_token"</span>]</span><br><span class="line">    print(access_token)</span><br></pre></td></tr></table></figure>

<h2 id="3、设置信息模板"><a href="#3、设置信息模板" class="headerlink" title="3、设置信息模板"></a>3、设置信息模板</h2><p>首先添加用户，用来收信息的微信号，扫二维码即可,微信号后面有用</p>
<p><img alt="1557989476566" data-src="http://img.mxranger.cn/1557989476566.png" class="lazyload"><br>添加模板，按照要求填写即可</p>
<p>注意：企业公众号有固定的信息模板，个人测试则自定义即可</p>
<p><img alt="1557989560258" data-src="http://img.mxranger.cn/1557989560258.png" class="lazyload"></p>
<p>添加完成</p>
<p><img alt="1557989621986" data-src="http://img.mxranger.cn/1557989621986.png" class="lazyload"></p>
<h2 id="4、发送模板信息"><a href="#4、发送模板信息" class="headerlink" title="4、发送模板信息"></a>4、发送模板信息</h2><blockquote>
<p>官网教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433751277" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433751277</a></p>
<p><img alt="1557989712618" data-src="http://img.mxranger.cn/1557989712618.png" class="lazyload"></p>
</blockquote>
<p>代码如下：</p>
<blockquote>
<p> 解释：</p>
<pre><code>touser : 是扫二维码后生成的微信号id

template_id ：创建模板后的模板id

data：模板内容一一对应的数据，value是值，color为颜色字体</code></pre></blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url1 = <span class="string">"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="</span> + access_token</span><br><span class="line"></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">"touser"</span>:<span class="string">"xxxxxxxxxxxxxxxxxxxx"</span>, <span class="comment"># 接收信息的用户id</span></span><br><span class="line">        <span class="string">"template_id"</span>:<span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>, <span class="comment">#模板id</span></span><br><span class="line">        <span class="string">"topcolor"</span>:<span class="string">"#FF0000"</span>,</span><br><span class="line">        <span class="string">"data"</span>:&#123;</span><br><span class="line">                <span class="string">"first"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:<span class="string">"服务器正常,爬虫数据已更新"</span>,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#ff0000"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"time"</span>: &#123; </span><br><span class="line">                    <span class="string">"value"</span>:time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time())),</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#173177"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"content"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:con,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#173177"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"remark"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:<span class="string">"稳定运行"</span>,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#ff0000"</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res1 = requests.post(url=url1,data=json.dumps(param))</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="微信图片编辑_20190516150303" data-src="http://img.mxranger.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20190516150303.jpg" class="lazyload"></p>
<p>推荐一家消息推送的网站，叫Server酱，使用简单方便</p>
<p><a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">http://sc.ftqq.com/3.version</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用教程</title>
    <url>/2019/11/17/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、docker"><a href="#一、docker" class="headerlink" title="一、docker"></a>一、docker</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><h3 id="1、什么是Dokcer"><a href="#1、什么是Dokcer" class="headerlink" title="1、什么是Dokcer"></a>1、什么是Dokcer</h3><pre><code>百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口；
使用go语言编写，在LCX（linux容器）基础上进行的封装
简单来说：
1）就是可以快速部署启动应用
2）实现虚拟化，完整资源隔离
3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用）</code></pre><h3 id="2、为什么要用"><a href="#2、为什么要用" class="headerlink" title="2、为什么要用"></a>2、为什么要用</h3><p>1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就可以直接启动运行   </p>
<p>2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动</p>
<p>3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用</p>
<p>4、更好的资源隔离和共享</p>
<p>一句话：开箱即用，快速部署，可移植性强，环境隔离</p>
<h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="1、linux安装"><a href="#1、linux安装" class="headerlink" title="1、linux安装"></a>1、linux安装</h3><p><strong>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</strong> </p>
<p>1、通过<strong>uname -r</strong>命令查看你当前的内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>2、使用 <code>root</code> 权限登录 Centos。确保 yum 包更新到最新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<p>3、卸载旧版本(如果安装过旧版本的话)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>

<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>5、设置yum源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>

<p>7、安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce #repo中默认只开启stable仓库</span><br></pre></td></tr></table></figure>

<p>8、启动并加入开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><img alt="1557193586913" data-src="http://img.mxranger.cn/docker/img/1557193586913.png" class="lazyload"></p>
<p><code>lsb_release -a</code>命令查看linux版本</p>
<p><img alt="1557133258261" data-src="http://img.mxranger.cn/docker/img/1557133258261.png" class="lazyload"></p>
<h3 id="2、win10安装"><a href="#2、win10安装" class="headerlink" title="2、win10安装"></a>2、win10安装</h3><h4 id="1、去官网注册账号，点击"><a href="#1、去官网注册账号，点击" class="headerlink" title="1、去官网注册账号，点击"></a>1、去官网注册账号，点击</h4><p><img alt="1557649468894" data-src="http://img.mxranger.cn/docker/img/1557649468894.png" class="lazyload"></p>
<p><img alt="1557649485009" data-src="http://img.mxranger.cn/docker/img/1557649485009.png" class="lazyload"></p>
<p>安装完成</p>
<p><img alt="QQ图片20180227225058.png" data-src="http://img.mxranger.cn/docker/img/201802284475_4291.png" class="lazyload"></p>
<p>单击Close and log out，会自动注销当前用户</p>
<h4 id="2、打开docker"><a href="#2、打开docker" class="headerlink" title="2、打开docker"></a>2、打开docker</h4><p>桌面打开docker，如果系统没有启动hyper-v的话，会提示你启动，点击ok启动。这个时候系统可能会重启安装hyper-v。等它重启完毕后，在桌面的右下角就能看到docker的图标，说明docker开始运行了。</p>
<p>[<img alt="windows10上安装docker" data-src="http://img.mxranger.cn/docker/img/6159252dd42a2834b433c56656b5c9ea14cebfc2.jpg" class="lazyload"></p>
<p><img alt="1557649614054" data-src="http://img.mxranger.cn/docker/img/1557649614054.png" class="lazyload"></p>
<h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p>cmd命令输入<code>docker version</code></p>
<p><img alt="1557649657623" data-src="http://img.mxranger.cn/docker/img/1557649657623.png" class="lazyload"></p>
<p>则安装完成</p>
<h3 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h3><p>由于Vmware和docker不能共用，当使用vmware时需要关闭Hyper-V，否则报错</p>
<p><img alt="vmware 报错" data-src="http://img.mxranger.cn/docker/img/Snipaste_2018-06-08_21-50-16.png" class="lazyload"></p>
<p>控制面板-&gt;程序-&gt;程序和功能-&gt;启用或关闭 Windows 功能</p>
<p><img alt="start Hyper-V" data-src="http://img.mxranger.cn/docker/img/markdown-img-paste-20180611095532509.png" class="lazyload"></p>
<p><strong>只能二选一</strong></p>
<h2 id="3、概念"><a href="#3、概念" class="headerlink" title="3、概念"></a>3、概念</h2><p>1、Docker 镜像 - Docker images：<br>容器运行时的只读模板，操作系统+软件运行环境+用户程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Docker 容器 - Docker containers：<br>容器包含了某个应用运行所需要的全部环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user = new User()</span><br></pre></td></tr></table></figure>
<p>3、Docker 仓库 - Docker registeries：<br>用来保存镜像，有公有和私有仓库，好比Maven的中央仓库和本地私服</p>
<p>镜像仓库：    </p>
<p>（参考）配置国内镜像仓库：<a href="https://blog.csdn.net/zzy1078689276/article/details/77371782" target="_blank" rel="noopener">https://blog.csdn.net/zzy1078689276/article/details/77371782</a></p>
<p>对比面向对象的方式<br>Dokcer 里面的镜像 : Java里面的类 Class<br>Docker 里面的容器 : Java里面的对象 Object<br>通过类创建对象，通过镜像创建容器</p>
<h2 id="4、docker常见命令"><a href="#4、docker常见命令" class="headerlink" title="4、docker常见命令"></a>4、docker常见命令</h2><p>常用命令（安装部署好Dokcer后，执行的命令是docker开头）,xxx是镜像名称</p>
<pre><code>搜索镜像：docker search xxx

列出当前系统存在的镜像：docker images

拉取镜像：docker pull xxx
xxx是具体某个镜像名称(格式 REPOSITORY:TAG)
REPOSITORY：表示镜像的仓库源,TAG：镜像的标签

运行一个容器：docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management
docker run - 运行一个容器
-d 后台运行
-p 端口映射
rabbitmq:management  (格式 REPOSITORY:TAG)，如果不指定tag，默认使用最新的
--name &quot;xxx&quot;

列举当前运行的容器：docker ps

检查容器内部信息：docker inspect 容器名称

删除镜像：docker rmi IMAGE_NAME
强制移除镜像不管是否有容器使用该镜像 增加 -f 参数，

停止某个容器：docker stop 容器名称/容器id

启动某个容器：docker start 容器名称/容器id

移除某个容器： docker rm 容器名称 （容器必须是停止状态）</code></pre><h3 id="安装rabbitmq镜像"><a href="#安装rabbitmq镜像" class="headerlink" title="安装rabbitmq镜像"></a>安装rabbitmq镜像</h3><p>查看镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>从仓库中拉取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>查看已安装的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img alt="1557193935767" data-src="http://img.mxranger.cn/docker/img/1557193935767.png" class="lazyload"></p>
<p>运行rabbitmq</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>查看运行的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img alt="1557193914859" data-src="http://img.mxranger.cn/docker/img/1557193914859.png" class="lazyload"></p>
<p>防火墙打开15672端口</p>
<p>RabbitMQ默认创建了一个 guest 用户，密码也是 guest, 如果访问不了记得查看防火墙，端口或者云服务器的安全组<br>          管理后台：<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></p>
<p><img alt="1557194025594" data-src="http://img.mxranger.cn/docker/img/1557194025594.png" class="lazyload"></p>
<p>停止工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称/容器id</span><br></pre></td></tr></table></figure>



<p>其他命令文档：<br>            <a href="https://blog.csdn.net/permike/article/details/51879578" target="_blank" rel="noopener">https://blog.csdn.net/permike/article/details/51879578</a></p>
<h3 id="安装nginx镜像"><a href="#安装nginx镜像" class="headerlink" title="安装nginx镜像"></a>安装nginx镜像</h3><p>1、获取镜像 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run (首先会从本地找镜像，如果有则直接启动，没有的话，从镜像仓库拉起，再启动)</span><br><span class="line"></span><br><span class="line">docker search nignx</span><br></pre></td></tr></table></figure>

<p>2、列举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>3、拉取</p>
<p>若不加-tag 则下载最新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nignx</span><br></pre></td></tr></table></figure>
<p>4、启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name &quot;xdclass_nginx&quot; -p 8088:80 nginx</span><br><span class="line">docker run -d --name &quot;xdclass_nginx2&quot; -p 8089:80 nginx</span><br><span class="line">docker run -d --name &quot;xdclass_nginx3&quot; -p 8090:80 nginx</span><br></pre></td></tr></table></figure>
<p>5、访问<br>如果是阿里云服务，记得配置安全组，腾讯云也需要配置，这个就是一个防火墙</p>
<p><img alt="1557306207106" data-src="http://img.mxranger.cn/docker/img/1557306207106.png" class="lazyload"></p>
<h3 id="安装redis镜像"><a href="#安装redis镜像" class="headerlink" title="安装redis镜像"></a>安装redis镜像</h3><p>1、搜索镜像<br><code>docker search redis</code></p>
<p>2、拉取<br><code>docker pull docker.io/redis</code></p>
<p>3、启动<br><code>docker run --name &quot;xd_redis&quot; -p 6379:6379 -d [IMAGE ID]</code><br>参考：<br><code>docker run --name &quot;xd_redis&quot; -p 6379:6379 -d [IMAGE ID] --requirepass &quot;123456&quot; -v $PWD/data:/data</code></p>
<p><code>--requirepass</code>设置密码        <code>-v</code> 本机路径:容器路径</p>
<p>4、访问redis容器里面，进行操作<br><code>docker exec -it bb5b092b5483 redis-cli</code></p>
<p><img alt="1557660802359" data-src="http://img.mxranger.cn/docker/img/1557660802359.png" class="lazyload"></p>
<p><img alt="1557660925504" data-src="http://img.mxranger.cn/docker/img/1557660925504.png" class="lazyload"></p>
<p>redis镜像配置成功</p>
<h2 id="5、镜像仓库"><a href="#5、镜像仓库" class="headerlink" title="5、镜像仓库"></a>5、镜像仓库</h2><h3 id="官方公共镜像仓库和私有镜像仓库"><a href="#官方公共镜像仓库和私有镜像仓库" class="headerlink" title="官方公共镜像仓库和私有镜像仓库"></a>官方公共镜像仓库和私有镜像仓库</h3><p>1、公共镜像仓库：<br>        官方：<a href="https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的" target="_blank" rel="noopener">https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的</a><br>        非官方：其他组织或者公司开发的镜像，供大家免费试用</p>
<p>2、私有镜像仓库：<br>        用于存放公司内部的镜像，不提供给外部试用； </p>
<pre><code>SpringCloud 开发了一个支付系统 -》做成一个镜像 （操作系统+软件运行环境+用户程序）</code></pre><p><img alt="WechatIMG1" data-src="http://img.mxranger.cn/docker/img/WechatIMG1.png" class="lazyload"></p>
<h2 id="6、镜像仓库配置"><a href="#6、镜像仓库配置" class="headerlink" title="6、镜像仓库配置"></a>6、镜像仓库配置</h2><p>使用自己的镜像仓库</p>
<p>1、点击容器镜像服务，需要设置密码</p>
<p><img alt="1557471756133" data-src="http://img.mxranger.cn/docker/img/1557471756133.png" class="lazyload"></p>
<p>2、创建镜像仓库</p>
<p><img alt="1557472324271" data-src="http://img.mxranger.cn/docker/img/1557472324271.png" class="lazyload"></p>
<p>代码源：选择本地仓库即可</p>
<p>3、管理</p>
<p><img alt="1557472406587" data-src="http://img.mxranger.cn/docker/img/1557472406587.png" class="lazyload"></p>
<p>4、根据所给命令进行pull和push</p>
<p><img alt="1557472829459" data-src="http://img.mxranger.cn/docker/img/1557472829459.png" class="lazyload"></p>
<h2 id="7、推送自己的镜像"><a href="#7、推送自己的镜像" class="headerlink" title="7、推送自己的镜像"></a>7、推送自己的镜像</h2><p>1、登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>2、推送本地镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:[镜像版本号]</span><br><span class="line"></span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:[镜像版本号]</span><br></pre></td></tr></table></figure>



<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>将之前下载的rabbitmq镜像推送到自己的镜像仓库</p>
<p><img alt="1557473073919" data-src="http://img.mxranger.cn/docker/img/1557473073919.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录	输入密码</span><br><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com  </span><br><span class="line"></span><br><span class="line">#推送</span><br><span class="line">docker tag ac759a4f2d38 registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br><span class="line"></span><br><span class="line">#push</span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br></pre></td></tr></table></figure>

<p>推送中：</p>
<p><img alt="1557473325362" data-src="http://img.mxranger.cn/docker/img/1557473325362.png" class="lazyload"></p>
<p>推送完，镜像推送成功</p>
<p><img alt="1557475433518" data-src="http://img.mxranger.cn/docker/img/1557475433518.png" class="lazyload"></p>
<h2 id="8、拉取自己仓库的镜像"><a href="#8、拉取自己仓库的镜像" class="headerlink" title="8、拉取自己仓库的镜像"></a>8、拉取自己仓库的镜像</h2><p>线上服务器拉取镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com </span><br><span class="line"></span><br><span class="line">docker pull registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br><span class="line"></span><br><span class="line">#启动容器</span><br><span class="line">docker run -d --name &quot;mxranger_rabbitmq&quot; -p 15672:15672 ac759a4f2d38</span><br></pre></td></tr></table></figure>

<p><img alt="1557536682388" data-src="http://img.mxranger.cn/docker/img/1557536682388.png" class="lazyload"></p>
<h2 id="9、springboot项目打包docker镜像"><a href="#9、springboot项目打包docker镜像" class="headerlink" title="9、springboot项目打包docker镜像"></a>9、springboot项目打包docker镜像</h2><blockquote>
<p>简介:使用Docker的maven插件，构建springboot应用<br>官方文档：<a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot-docker/</a></p>
</blockquote>
<h3 id="1、简单编写springboot程序"><a href="#1、简单编写springboot程序" class="headerlink" title="1、简单编写springboot程序"></a>1、简单编写springboot程序</h3><p>只添加了web依赖，建一个controller的方法做测试用</p>
<p><img alt="1557650702452" data-src="http://img.mxranger.cn/docker/img/1557650702452.png" class="lazyload"></p>
<h3 id="2、pom-xml添加配置"><a href="#2、pom-xml添加配置" class="headerlink" title="2、pom.xml添加配置"></a>2、pom.xml添加配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>mxranger<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>docker-demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置讲解:</strong><br>        Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。<br><code>${project.build.finalName}</code> 产出物名称，缺省为<code>${project.artifactId}-${project.version}</code></p>
<h3 id="3、创建Dockerfile"><a href="#3、创建Dockerfile" class="headerlink" title="3、创建Dockerfile"></a>3、创建Dockerfile</h3><pre><code>创建Dockerfile在项目根目录（也可以修改为src/main/docker/Dockerfile,如果修则需要制定路径）
Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ARG JAR_FILE</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">ENTRYPOINT ["java","-jar","/app.jar"]</span><br></pre></td></tr></table></figure>

<p><img alt="1557647182362" data-src="http://img.mxranger.cn/docker/img/1557647182362.png" class="lazyload"></p>
<p><strong>参数讲解：</strong><br>【1】<code>FROM &lt;image&gt;:&lt;tag&gt;</code>需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令<br>【2】<code>VOLUME</code>  配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录<br>【3】<code>ARG</code>  设置编译镜像时加入的参数， ENV 是设置容器的环境变量<br>【4】<code>COPY</code> : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点<br>【5】<code>ENTRYPOINT</code> 容器启动时执行的命令<br>【6】<code>EXPOSE 8080</code> 暴露镜像端口</p>
<h3 id="4、构建镜像"><a href="#4、构建镜像" class="headerlink" title="4、构建镜像"></a>4、构建镜像</h3><p>构建前windows10必须安装docker [安装教程](# 2、win10安装)</p>
<p>在idea <code>Terminal</code>的当前项目根目录下执行命令<code>mvn install dockerfile:build</code></p>
<p><img alt="1557649939527" data-src="http://img.mxranger.cn/docker/img/1557649939527.png" class="lazyload"></p>
<p>构建完成后</p>
<p><img alt="1557649981791" data-src="http://img.mxranger.cn/docker/img/1557649981791.png" class="lazyload"></p>
<p>当前电脑中docker镜像</p>
<p><img alt="1557649998263" data-src="http://img.mxranger.cn/docker/img/1557649998263.png" class="lazyload"></p>
<h3 id="5、本地测试"><a href="#5、本地测试" class="headerlink" title="5、本地测试"></a>5、本地测试</h3><p>cmd执行命令<code>docker run -d --name demo -p 8080:8080 [IMAGES ID]</code></p>
<p>测试成功</p>
<p><img alt="1557650596662" data-src="http://img.mxranger.cn/docker/img/1557650596662.png" class="lazyload"></p>
<h3 id="6、推送到阿里云镜像服务器"><a href="#6、推送到阿里云镜像服务器" class="headerlink" title="6、推送到阿里云镜像服务器"></a>6、推送到阿里云镜像服务器</h3><p>步骤同[推送自己的镜像](# 7、推送自己的镜像)一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">登录阿里云</span></span><br><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com</span><br><span class="line"><span class="meta">#</span><span class="bash">打标签</span></span><br><span class="line">docker tag d5267a28accd registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</span><br><span class="line"><span class="meta">#</span><span class="bash">push 推送</span></span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</span><br></pre></td></tr></table></figure>
<p>推送成功<br><img alt="1557652237001" data-src="http://img.mxranger.cn/docker/img/1557652237001.png" class="lazyload"></p>
<p>已经推送阿里云镜像服务器<br><img alt="1557652190008" data-src="http://img.mxranger.cn/docker/img/1557652190008.png" class="lazyload"></p>
<h3 id="7、拉取镜像"><a href="#7、拉取镜像" class="headerlink" title="7、拉取镜像"></a>7、拉取镜像</h3><p>拉取镜像到购买的服务器，同[拉取镜像](# 8、拉取自己仓库的镜像)一样</p>
<p><code>docker pull registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</code></p>
<p><img alt="1557652303752" data-src="http://img.mxranger.cn/docker/img/1557652303752.png" class="lazyload"></p>
<h3 id="8、启动"><a href="#8、启动" class="headerlink" title="8、启动"></a>8、启动</h3><p><img alt="1557652477807" data-src="http://img.mxranger.cn/docker/img/1557652477807.png" class="lazyload"></p>
<p>启动命令<code>docker run -d --name docker_demo -p 8080:8080  d5267a28accd</code></p>
<p>如图启动成功</p>
<p><img alt="1557652443639" data-src="http://img.mxranger.cn/docker/img/1557652443639.png" class="lazyload"></p>
<h3 id="9、查看项目启动日志"><a href="#9、查看项目启动日志" class="headerlink" title="9、查看项目启动日志"></a>9、查看项目启动日志</h3><p><code>docker logs -f  [containerid]</code></p>
<p><img alt="1557652592105" data-src="http://img.mxranger.cn/docker/img/1557652592105.png" class="lazyload"></p>
<h3 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h3><p>1、localhost:2375 connection refused:connect</p>
<p><img alt="1557649151795" data-src="http://img.mxranger.cn/docker/img/1557649151795.png" class="lazyload"></p>
<p>解决办法：右击任务栏Docker图标 点击Settings 勾选红线部分 完美解决<br><img alt="img" data-src="http://img.mxranger.cn/docker/img/20180929181816965.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用七牛云搭建图床</title>
    <url>/2019/11/17/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="七牛云做图床"><a href="#七牛云做图床" class="headerlink" title="七牛云做图床"></a>七牛云做图床</h1><blockquote>
<p>由于微博图床有些已经不能用了，所有利用七牛云进行搭建自己的图床</p>
<p>本教程是需要绑定域名，所以没有域名的请去购买域名，否则七牛云的网址会时效</p>
</blockquote>
<h2 id="1、注册七牛云"><a href="#1、注册七牛云" class="headerlink" title="1、注册七牛云"></a>1、注册七牛云</h2><p>具体不多说，见<a href="https://www.qiniu.com/" target="_blank" rel="noopener">网站</a></p>
<h2 id="2、创建七牛云存储空间"><a href="#2、创建七牛云存储空间" class="headerlink" title="2、创建七牛云存储空间"></a>2、创建七牛云存储空间</h2><p>选择对象存储</p>
<p><img alt="1559206358837" data-src="http://img.mxranger.cn/qiniu/img/1559206358837.png" class="lazyload"></p>
<p>点击新建<br><img alt="1559206384676" data-src="http://img.mxranger.cn/qiniu/img/1559206384676.png" class="lazyload"></p>
<p>内容自行填写</p>
<h2 id="3、注册二级域名"><a href="#3、注册二级域名" class="headerlink" title="3、注册二级域名"></a>3、注册二级域名</h2><p>为你自己的域名注册二级域名(以阿里云域名管理为例，进行说明)</p>
<h3 id="1、点击解析"><a href="#1、点击解析" class="headerlink" title="1、点击解析"></a>1、点击解析</h3><p><img alt="1559206549792" data-src="http://img.mxranger.cn/qiniu/img/1559206549792.png" class="lazyload"></p>
<p>​     </p>
<h3 id="2、添加记录"><a href="#2、添加记录" class="headerlink" title="2、添加记录"></a>2、添加记录</h3><p><img alt="1559206701135" data-src="http://img.mxranger.cn/qiniu/img/1559206701135.png" class="lazyload">     </p>
<p>​     </p>
<h3 id="3、添加解析页面如下所示，页面中的值如下填写即可"><a href="#3、添加解析页面如下所示，页面中的值如下填写即可" class="headerlink" title="3、添加解析页面如下所示，页面中的值如下填写即可"></a>3、添加解析页面如下所示，页面中的值如下填写即可</h3><p><img alt="1559207616427" data-src="http://img.mxranger.cn/qiniu/img/1559207616427.png" class="lazyload"></p>
<h3 id="4、七牛云存储空间绑定二级域名"><a href="#4、七牛云存储空间绑定二级域名" class="headerlink" title="4、七牛云存储空间绑定二级域名"></a>4、七牛云存储空间绑定二级域名</h3><p>1、进入到七牛云存储空间创建完成后跳转的页面，绑定域名</p>
<p><img alt="1559207640036" data-src="http://img.mxranger.cn/qiniu/img/1559207640036.png" class="lazyload"></p>
<p>2、进入到七牛云存储空间创建完成后跳转的页面，绑定域名</p>
<p><img alt="1559207655749" data-src="http://img.mxranger.cn/qiniu/img/1559207655749.png" class="lazyload"></p>
<p>3、绑定成功后，跳转的页面上有CNAME值</p>
<p><img alt="1559207680812" data-src="http://img.mxranger.cn/qiniu/img/1559207680812.png" class="lazyload"></p>
<h3 id="5、为CNAME绑定二级域名"><a href="#5、为CNAME绑定二级域名" class="headerlink" title="5、为CNAME绑定二级域名"></a>5、为CNAME绑定二级域名</h3><p>1、回到阿里云域名解析的页面，修改绑定的值</p>
<p><img alt="1559207711657" data-src="http://img.mxranger.cn/qiniu/img/1559207711657.png" class="lazyload"></p>
<p>2、修改绑定的值为CNAM，替换<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p><img alt="1559207736061" data-src="http://img.mxranger.cn/qiniu/img/1559207736061.png" class="lazyload"></p>
<h2 id="4、审核结果"><a href="#4、审核结果" class="headerlink" title="4、审核结果"></a>4、审核结果</h2><p>至此七牛云绑定域名就行完成了，等待审核结果</p>
<p>收到邮件</p>
<p><img alt="1559207797499" data-src="http://img.mxranger.cn/qiniu/img/1559207797499.png" class="lazyload"></p>
<p><img alt="1559207849766" data-src="http://img.mxranger.cn/qiniu/img/1559207849766.png" class="lazyload"></p>
<h2 id="5、上传图片"><a href="#5、上传图片" class="headerlink" title="5、上传图片"></a>5、上传图片</h2><p>可以在内容管理里面上传图片了</p>
<p><img alt="1559208005620" data-src="http://img.mxranger.cn/qiniu/img/1559208005620.png" class="lazyload"></p>
<p>获取链接</p>
<p><img alt="1559208036593" data-src="http://img.mxranger.cn/qiniu/img/1559208036593.png" class="lazyload"></p>
<p>至此，搭建图床已完成</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题</title>
    <url>/2019/11/17/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1、重建二叉树"><a href="#1、重建二叉树" class="headerlink" title="1、重建二叉树"></a>1、重建二叉树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>树的结构采用用递归来实现。</p>
<p>递归的思想其实就是解决当前节点所需要做的事，然后将下一个节点扔进去做同一件事，所以我们可以当做就解决root应该做的事，赋值 + 对接左右子树</p>
<p>根据前序遍历的特点，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。</p>
<p>根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。</p>
<p>只需要将确定的左右子树安到root上即可。如果最后只有一个元素了，那么就要返回。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rebuildTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rebuildTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//[0]前序数组为空，直接结束</span></span><br><span class="line">        <span class="comment">//可能出现在子树中没有左/右子树的情况</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]判断下以防万一</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]只需要对当前父节点进行赋值即可</span></span><br><span class="line">        <span class="keyword">int</span> root_val = pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]当中序数组中只剩下一个，直接返回，已经是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(in.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[4]记录父节点的索引位置，用来为下面划分左子树和右子树</span></span><br><span class="line">        <span class="keyword">int</span> root_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root_val == in[i])&#123;<span class="comment">//找到根节点的位置，为了一分为二</span></span><br><span class="line">                root_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[5]将前序和中序分别拆分左子树区域和右子树区域</span></span><br><span class="line">        <span class="keyword">int</span>[] pre_left = Arrays.copyOfRange(pre, <span class="number">1</span>, root_index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] pre_right = Arrays.copyOfRange(pre, root_index+<span class="number">1</span>, pre.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] in_left = Arrays.copyOfRange(in, <span class="number">0</span>, root_index);</span><br><span class="line">        <span class="keyword">int</span>[] in_right = Arrays.copyOfRange(in, root_index+<span class="number">1</span>, in.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[6]接上去即可，递归</span></span><br><span class="line">        node.left = reConstructBinaryTree(pre_left, in_left);</span><br><span class="line">        node.right= reConstructBinaryTree(pre_right,in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历打印测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">        print(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">        print(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        print(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="构建二叉树" data-src="http://img.mxranger.cn/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="lazyload"></p>
<h2 id="2、包含min函数的栈"><a href="#2、包含min函数的栈" class="headerlink" title="2、包含min函数的栈"></a>2、包含min函数的栈</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>定义一个主栈A，一个辅助栈B，用来存放最小值<br>既然是最小值，肯定只有一个</p>
<p>主栈A入栈<br>[1]如果B中无值，便入栈其值<br>[2]如果B中有值，判断B栈顶的值和入栈A的值比较<br>        B栈顶的值 &gt; 入栈A的值,将其入辅助栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|  3  |     |     |</span><br><span class="line">|  2  |     |     |</span><br><span class="line">|  4  |     |  2  |</span><br><span class="line">|_ 3__|     |_ 3__|</span><br><span class="line"></span><br><span class="line">   A           B</span><br></pre></td></tr></table></figure>


<p>主栈A出栈<br>[1]判断A出栈值和B的栈顶值<br>        A出栈值 &gt; B的栈顶值,说明A中仍存在B栈顶值，A出栈即可<br>        A出栈值 = B的栈顶值,说明A中除了该值没有再小的值了（最小值只有一个，栈的特性），A和B都出栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|     |     |     |</span><br><span class="line">|  2  |╲   |     |</span><br><span class="line">|  4  |  ╲ |  2  |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B   </span><br><span class="line"></span><br><span class="line">2号出栈</span><br><span class="line"></span><br><span class="line">|     |     |     |</span><br><span class="line">|     |     |     |</span><br><span class="line">|  4  |     |     |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B </span><br><span class="line"></span><br><span class="line">4号出栈</span><br><span class="line">|     |     |     |</span><br><span class="line">|     |╲   |     |</span><br><span class="line">|     |  ╲ |     |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B </span><br><span class="line"></span><br><span class="line">0号入栈</span><br><span class="line">|     |     |     |</span><br><span class="line">|     |╲   |     |</span><br><span class="line">|  0  |  ╲ |  0  |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B</span><br></pre></td></tr></table></figure>

<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MinStack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//辅助栈，用来存放最小值、次小值、.....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.add(node);</span><br><span class="line">        push2(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(stack2.peek() == val)&#123;<span class="comment">//若主栈出栈了最小值 和辅助栈的栈顶一致，便一起出栈，辅助栈留下来前一次的次小值</span></span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = stack2.peek();</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push2</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123; <span class="comment">//栈顶为空放值</span></span><br><span class="line">            stack2.add(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack2.peek()&gt; node)&#123; <span class="comment">//栈顶的最小值若比入栈的还要小，便将其压栈</span></span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinStack stack = <span class="keyword">new</span> MinStack();</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img alt="min函数栈" data-src="http://img.mxranger.cn/min%E5%87%BD%E6%95%B0%E6%A0%88.png" class="lazyload"></p>
<h2 id="3、数的子结构"><a href="#3、数的子结构" class="headerlink" title="3、数的子结构"></a>3、数的子结构</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用递归的方式遍历子树和主数<br>[1] 当主树和子树都为空  返回false</p>
<p>[2]当 当前主树根节点和子树根节点值相同，匹配开始</p>
<pre><code>[2.1] 如果子树遍历完了，说明匹配完成，返回true
[2.2] 如果主数遍历完，说明匹配不成功，返回false (你说你把主数都遍历完了，子树还没结束，还匹配啥)
[2.3] 如果匹配的过程中，有节点不一样，返回false
[2.4] 分别将主树的左子树 + 子树的左子树 进入[2]递归
[2.5] 分别将主树的右子树 + 子树的右子树 进入[2]递归</code></pre><p>[3] 若[2]中为匹配到，则需要将主树的根节点的左子树和右子树分别进入[1]中递归</p>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChildTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123; <span class="comment">//若两个数都为空，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123; </span><br><span class="line">            <span class="comment">//当 当前主树根节点和子树根节点值相同，</span></span><br><span class="line">            <span class="comment">//考虑为匹配开始，进入HasSubtree2函数</span></span><br><span class="line">            result =  HasSubtree2( root1, root2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="comment">//如果没匹配到，遍历主树的左子树去进行匹配</span></span><br><span class="line">            result = HasSubtree(root1.left,root2); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="comment">//如果没匹配到，遍历主树的右子树去进行匹配</span></span><br><span class="line">            result = HasSubtree(root1.right,root2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree2</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;<span class="comment">//遍历子树结束了，说明都匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;<span class="comment">//若主树遍历完，说明没匹配完整，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root1.val != root2.val) &#123;  <span class="comment">//在匹配的时候中途不一样，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]当前节点匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1.1]匹配左子树是否一致</span></span><br><span class="line">        <span class="keyword">boolean</span> result_left = HasSubtree2(root1.left, root2.left); </span><br><span class="line">        <span class="comment">//[1.2]匹配右子树是否一致</span></span><br><span class="line">        <span class="keyword">boolean</span> result_right = HasSubtree2(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result_left &amp;&amp; result_right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode t1 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t1.left = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t1.left.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        t1.left.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        t1.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode t2 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t2.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        t2.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = HasSubtree(t1, t2);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="主树找子树" data-src="http://img.mxranger.cn/%E4%B8%BB%E6%A0%91%E6%89%BE%E5%AD%90%E6%A0%91.png" class="lazyload"></p>
<h2 id="4、栈的压入、弹出序列"><a href="#4、栈的压入、弹出序列" class="headerlink" title="4、栈的压入、弹出序列"></a>4、栈的压入、弹出序列</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>链接：</p>
<p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>举例：</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JudgeStack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JudgeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//辅助栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            <span class="comment">//压栈</span></span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j&lt;popA.length &amp;&amp; stack.peek() == popA[j])&#123; <span class="comment">//判断popA的第一个值是不是栈顶的值，若是，则出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123; <span class="comment">//若辅助栈出栈完毕，说明包含popA的出栈顺序</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pushA = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] popA = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> result = IsPopOrder(pushA,popA);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、从上往下打印二叉树"><a href="#4、从上往下打印二叉树" class="headerlink" title="4、从上往下打印二叉树"></a>4、从上往下打印二叉树</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">二叉树如下：</span><br><span class="line">        1</span><br><span class="line">      /   \</span><br><span class="line">    2       3</span><br><span class="line">  /  \     /  \</span><br><span class="line"> 4    5   6    7</span><br></pre></td></tr></table></figure>

<p>创建一个ArrayList<br>想象成一个队列</p>
<p>[1] 输入1入队</p>
<pre><code>----------------------
                    1
----------------------</code></pre><p>[2]将1出队，并将他的左子树和右子树入队  </p>
<pre><code>将1的值添加到ArrayList中

            ----------------------
        1                  2    3 
            ----------------------</code></pre><p>[3]将2出队，并将他的左子树4和右子树5入队</p>
<pre><code>将2的值添加到ArrayList中
            ----------------------
1       2             3    4    5 
            ----------------------</code></pre><p>[4]将3出队，并将他的左子树4和右子树5入队</p>
<pre><code>将3的值添加到ArrayList中
            ----------------------
1   2   3         4    5   6    7
            ----------------------</code></pre><p>[5] 重复上述动作，4、5、6、7没有左子树和右子树，便以此出队</p>
<p>[6] 当队列为空时，结束</p>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PrintTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; trees = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">        trees.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(trees.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode temp = trees.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                trees.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                trees.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(temp.val+ <span class="string">" "</span>);</span><br><span class="line">            nums.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        PrintFromTopToBottom(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="5、顺序打印矩阵"><a href="#5、顺序打印矩阵" class="headerlink" title="5、顺序打印矩阵"></a>5、顺序打印矩阵</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>一圈一圈打印<br>确定好每圈的左上角位置，按照[0,0] [1,1] [2,2],取一个值即可</p>
<p>每走一圈，行和列都要缩小</p>
<p>打印顺序为：顶行 -&gt; 右列-&gt; 底行 -&gt; 左列</p>
<p>可以设置上下左右的变量锁定行列的打印范围，我没做</p>
<p>单数列、单数行需要进行判断是否需要打印底行 左列</p>
<h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * printMatrix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">printMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">//每圈开始</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一圈圈打印</span></span><br><span class="line">        <span class="keyword">while</span>(row &gt; start * <span class="number">2</span> &amp;&amp; column &gt; start * <span class="number">2</span>)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;column - start;i++)&#123;<span class="comment">//打印顶行</span></span><br><span class="line">                <span class="comment">//    System.out.print(matrix[start][i] + " ");</span></span><br><span class="line">                   nums.add(matrix[start][i]);</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>;i&lt;row - start;i++)&#123;<span class="comment">//打印右列</span></span><br><span class="line">                <span class="comment">// System.out.print(matrix[i][column - start - 1] + " ");</span></span><br><span class="line">                nums.add(matrix[i][column - start - <span class="number">1</span>]);</span><br><span class="line">               &#125;</span><br><span class="line">            </span><br><span class="line">               <span class="keyword">if</span>(start != (row-start-<span class="number">1</span>))&#123; <span class="comment">//若为单行，则无需打印</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> i = column - start - <span class="number">2</span>;i&gt;=start;i--)&#123;<span class="comment">//打印底行</span></span><br><span class="line">                       <span class="comment">// System.out.print(matrix[row-start-1][i] + " ");</span></span><br><span class="line">                       nums.add(matrix[row-start-<span class="number">1</span>][i]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">                </span><br><span class="line">               <span class="keyword">if</span>(start != (column-start-<span class="number">1</span>))&#123;<span class="comment">//若为单列，则无需打印</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> i= row - start - <span class="number">2</span>;i&gt;=start+<span class="number">1</span> ;i--)&#123;<span class="comment">//打印左列</span></span><br><span class="line">                       <span class="comment">// System.out.print(matrix[i][start] + " ");</span></span><br><span class="line">                       nums.add(matrix[i][start]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">               start++;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix2 = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix3 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix4 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>&#125;&#125;;</span><br><span class="line">                        </span><br><span class="line">        ArrayList&lt;Integer&gt; nums = printMatrix(matrix);</span><br><span class="line">        </span><br><span class="line">        nums.forEach((e)-&gt;&#123;</span><br><span class="line">          System.out.print(e + <span class="string">" "</span>);  </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6、平衡二叉树"><a href="#6、平衡二叉树" class="headerlink" title="6、平衡二叉树"></a>6、平衡二叉树</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<h3 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h3><p>[1]求左子树和右子树的深度</p>
<p>[2]平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</p>
<h3 id="完整代码1"><a href="#完整代码1" class="headerlink" title="完整代码1"></a>完整代码1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; <span class="comment">//当前节点为空，情况：没有子节点或者空树    返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_depth = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth = treeDepth(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：</span></span><br><span class="line">        <span class="comment">//它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left_depth - right_depth) &lt;=<span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; <span class="comment">//当前节点为空，情况：没有子节点或者空树    返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_depth = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth = treeDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树 / 右子树 的深度 + 当前节点的深度1</span></span><br><span class="line">        <span class="keyword">return</span> left_depth &gt; right_depth ? left_depth+<span class="number">1</span> : right_depth+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h3><p>[1] 直接在求左右子树的深度时，进行深度之差判断，不平衡直接返回，剪枝效果</p>
<h3 id="完整代码2"><a href="#完整代码2" class="headerlink" title="完整代码2"></a>完整代码2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;my-first-blog&#39;</title>
    <url>/2019/11/16/my-first-blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> # 前言 </p>
<p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快； </li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； </li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； </li>
</ol>
<a id="more"></a> 


<ol start="4">
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5. 博客内容可以轻松打包、转移、发布到其它平台； 6. 等等； </li>
</ol>
<p><img alt="123" data-src="/images/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94.png" class="lazyload"></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/16/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
