<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL基础高级教程</title>
    <url>/2019/12/12/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、mysql基础"><a href="#一、mysql基础" class="headerlink" title="一、mysql基础"></a>一、mysql基础</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h3 id="1、数据库的好处"><a href="#1、数据库的好处" class="headerlink" title="1、数据库的好处"></a>1、数据库的好处</h3><p>持久化数据到本地<br>可以实现结构化查询，方便管理</p>
<h3 id="2、数据库相关概念"><a href="#2、数据库相关概念" class="headerlink" title="2、数据库相关概念"></a>2、数据库相关概念</h3><p>DB:database：存储数据的“仓库”。它保存了一系列有组织的数据。</p>
<p>DBMS：数据库管理系统（Database Management System）。数据库是通过DBMS创建和操作的容器</p>
<ul>
<li>基于共享文件系统的DBMS（Access）</li>
<li>基于客户机-服务器（CS）的DBMS （MySQL、Oracle、SqlServer）</li>
</ul>
<p>SQL：结构化查询语言（Structure Query Language）：专门用来与数据库通信的语言。</p>
<p>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等</p>
<p><img alt="1560403616380" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560403616380.png" class="lazyload"></p>
<h3 id="3、数据库存储数据的特点"><a href="#3、数据库存储数据的特点" class="headerlink" title="3、数据库存储数据的特点"></a>3、数据库存储数据的特点</h3><p>​    1、将数据放到表中，表再放到库中<br>​    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>​    3、<strong>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</strong><br>​    4、<strong>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</strong><br>​    5、<strong>表中的数据是按行存储的，每一行类似于java中的“对象”。</strong></p>
<h2 id="2、mysql使用"><a href="#2、mysql使用" class="headerlink" title="2、mysql使用"></a>2、mysql使用</h2><h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a>1、登录</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>通过mysql自带的客户端，只限于root用户</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>将mysql文件夹下的bin目录添加到环境变量中，cmd中输入</p>
<p><code>-h:host  -P:port -u:user -p:password</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 3306 -u root -p</span><br></pre></td></tr></table></figure>

<p>输入密码</p>
<p><img alt="1560404879953" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560404879953.png" class="lazyload"></p>
<h3 id="2、SQL的常见命令"><a href="#2、SQL的常见命令" class="headerlink" title="2、SQL的常见命令"></a>2、SQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line"></span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line"></span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">	列名 列类型,</span><br><span class="line">	列名 列类型，</span><br><span class="line">	。。。</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br></pre></td></tr></table></figure>



<h3 id="3、mysql语法规范"><a href="#3、mysql语法规范" class="headerlink" title="3、mysql语法规范"></a>3、mysql语法规范</h3><p>1、不区分大小写,但建议关键字大写，表名、列名小写<br>2、每条命令最好用分号结尾<br>3、每条命令根据需要，可以进行缩进 或换行<br>4、注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字</span><br><span class="line">单行注释：-- 注释文字  必须加空格</span><br><span class="line">多行注释：/* 注释文字  */</span><br></pre></td></tr></table></figure>

<h3 id="4、SQL的语言分类"><a href="#4、SQL的语言分类" class="headerlink" title="4、SQL的语言分类"></a>4、SQL的语言分类</h3><p>DQL（Data Query Language）：数据查询语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select</span><br></pre></td></tr></table></figure>
<p>DML(Data Manipulate Language):数据操作语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 、update、delete</span><br></pre></td></tr></table></figure>
<p>DDL（Data Define Languge）：数据定义语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create、drop、alter</span><br></pre></td></tr></table></figure>
<p>TCL（Transaction Control Language）：事务控制语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit、rollback</span><br></pre></td></tr></table></figure>



<h2 id="3、DQL语言学习"><a href="#3、DQL语言学习" class="headerlink" title="3、DQL语言学习"></a>3、DQL语言学习</h2><blockquote>
<p>Data Query Language —— 数据查询语言</p>
</blockquote>
<p>准备数据，字段介绍</p>
<p><img alt="1560407441118" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560407441118.png" class="lazyload"></p>
<h3 id="1、基础查询"><a href="#1、基础查询" class="headerlink" title="1、基础查询"></a>1、基础查询</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>select 查询列表 from 表名;</p>
<p>类似java中的<code>System.out.println(...)</code>打印</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、查询列表可以是：表中的字段、常量值、表达式、函数<br>2、查询的结果是一个虚拟的表格</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#推荐指定某个数据库</span><br><span class="line">USE myemployees;</span><br></pre></td></tr></table></figure>
<p>1、查询表中的单个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name FROM employees;</span><br></pre></td></tr></table></figure>
<p>2、查询表中的多个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,salary,email FROM employees;</span><br></pre></td></tr></table></figure>
<p>3、查询表中的所有字段<br>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    `employee_id`,</span><br><span class="line">    `first_name`,</span><br><span class="line">    `last_name`,</span><br><span class="line">    `phone_number`,</span><br><span class="line">    `last_name`,</span><br><span class="line">    `job_id`,</span><br><span class="line">    `phone_number`,</span><br><span class="line">    `job_id`,</span><br><span class="line">    `salary`,</span><br><span class="line">    `commission_pct`,</span><br><span class="line">    `manager_id`,</span><br><span class="line">    `department_id`,</span><br><span class="line">    `hiredate` </span><br><span class="line">FROM</span><br><span class="line">    employees ;</span><br></pre></td></tr></table></figure>
<p>方式二： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure>


<p> 4、查询常量值</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100;</span><br><span class="line">SELECT &apos;john&apos;;</span><br></pre></td></tr></table></figure>


<p> 5、查询表达式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98;</span><br><span class="line">SELECT 100*98;</span><br></pre></td></tr></table></figure>



<p> 6、查询mysql版本函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>



<p> 7、起别名<br> ①便于理解<br> ②如果要查询的字段有重名的情况，使用别名可以区分开来</p>
<p>方式一：使用as</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line">SELECT last_name AS 姓,first_name AS 名 FROM employees;</span><br></pre></td></tr></table></figure>

<p>方式二：使用空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name 姓,first_name 名 FROM employees;</span><br></pre></td></tr></table></figure>

<p>案例：查询salary，显示结果为 out put</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary AS &quot;out put&quot; FROM employees;</span><br></pre></td></tr></table></figure>



<p>8、去重 使用DISTINCT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工表中涉及到的所有的部门编号</span><br><span class="line">SELECT DISTINCT department_id FROM employees;</span><br></pre></td></tr></table></figure>



<p>9、+号的作用</p>
<p>java中的+号：<br>①运算符，两个操作数都为数值型<br>②连接符，只要有一个操作数为字符串</p>
<p>mysql中的+号：<br>仅仅只有一个功能：运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 100+90; 两个操作数都为数值型，则做加法运算</span><br><span class="line">select &apos;123&apos;+90;只要其中一方为字符型，试图将字符型数值转换成数值型.如果转换成功，则继续做加法运算</span><br><span class="line">select &apos;john&apos;+90;	如果转换失败，则将字符型数值转换成0</span><br><span class="line">select null+10; 只要其中一方为null，则结果肯定为null</span><br></pre></td></tr></table></figure>



<p>10、concat作用<br>案例：查询员工名和姓连接成一个字段，并显示为 姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) AS 结果;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">	CONCAT(last_name,first_name) AS 姓名</span><br><span class="line">FROM</span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>显示表departments的结构，并查询其中的全部数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc departments;</span><br></pre></td></tr></table></figure>



<p>显示出表employees中的全部job_id（不能重复）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct job_id from employees;</span><br></pre></td></tr></table></figure>



<p>显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(`first_name`,&apos;,&apos;,`last_name`,&apos;,&apos;,`job_id`,&apos;,&apos;,IFNULL(commission_pct,0)) as out_put</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<p><img alt="1560409611290" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560409611290.png" class="lazyload"></p>
<h3 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	查询列表</span><br><span class="line">from</span><br><span class="line">	表名</span><br><span class="line">where</span><br><span class="line">	筛选条件;</span><br></pre></td></tr></table></figure>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1、按条件表达式筛选</p>
<p>简单条件运算符：<code>&gt;</code> <code>&lt;</code>  <code>=</code>  <code>!=</code>  <code>&lt;&gt; (等同于!=)</code>  <code>&gt;=</code>  <code>&lt;=</code></p>
<p>2、按逻辑表达式筛选<br>逻辑运算符：<br>作用：用于连接条件表达式<br><code>&amp;&amp;</code> <code>||</code> <code>!</code>    <code>and</code> <code>or</code> <code>not</code></p>
<p>3、模糊查询<br><code>like</code> <code>between and</code> <code>in</code> <code>is null</code></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>1、按条件表达式筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询工资&gt;12000的员工信息</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary&gt;12000;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#案例2：查询部门编号不等于90号的员工名和部门编号</span><br><span class="line">SELECT </span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	department_id&lt;&gt;90;</span><br></pre></td></tr></table></figure>

<p>2、按逻辑表达式筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary&gt;=10000 AND salary&lt;=20000;</span><br><span class="line">#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	#department_id&gt;90 or department_id&lt;110 OR salary&gt;15000;</span><br><span class="line">	NOT(department_id&gt;=90 AND  department_id&lt;=110) OR salary&gt;15000;</span><br></pre></td></tr></table></figure>



<p>3、模糊查询<br><code>like</code> <code>between and</code> <code>in</code> <code>is null</code> <code>is not null</code></p>
<p>【1】like</p>
<blockquote>
<p>一般和通配符搭配使用，%表示任意个数的任意字符(但是不包含null)<br>    通配符：<br>    % 任意多个字符,包含0个字符<br>    _ 任意单个字符</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询员工名中包含字符a的员工信息</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	last_name like &apos;%a%&apos;;#abc</span><br><span class="line">	</span><br><span class="line">#案例2：查询员工名中第三个字符为e，第五个字符为n的员工名和工资</span><br><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &apos;__e_n%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：查询员工名中第二个字符为_的员工名</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	last_name</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &apos;_$_%&apos; ESCAPE &apos;$&apos;;</span><br></pre></td></tr></table></figure>



<p>【2】between and</p>
<blockquote>
<p>①使用between and 可以提高语句的简洁度<br>②包含临界值<br>③两个临界值不要调换顺序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询员工编号在100到120之间的员工信息</span><br><span class="line"># --------------------方式一 -------------</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	employee_id &gt;= 100 AND employee_id&lt;=120;</span><br><span class="line">#----------------------方式二 -----------</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	employee_id BETWEEN 100 AND 120;</span><br></pre></td></tr></table></figure>



<p>【3】in</p>
<blockquote>
<p>含义：判断某字段的值是否属于in列表中的某一项<br>特点：<br>    ①使用in提高语句简洁度<br>    ②in列表的值类型必须一致或兼容（类似隐式转换）<br>    ③in列表中不支持通配符，必须强制指定某个值，原因在于in就是等号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</span><br><span class="line"># -----------方式一（繁琐）--------------</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	job_id = &apos;IT_PROT&apos; OR job_id = &apos;AD_VP&apos; OR JOB_ID =&apos;AD_PRES&apos;;</span><br><span class="line"></span><br><span class="line">#-----------方式二（简洁）-------</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	job_id IN( &apos;IT_PROT&apos; ,&apos;AD_VP&apos;,&apos;AD_PRES&apos;);</span><br></pre></td></tr></table></figure>

<p>【4】is null</p>
<blockquote>
<p>=或&lt;&gt;不能用于判断null值<br>is null或is not null 可以判断null值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>【5】安全等于 <code>&lt;=&gt;</code></p>
<blockquote>
<p>可以判断null值，也可以判断普通值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct &lt;=&gt;NULL;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#案例2：查询工资为12000的员工信息</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line"></span><br><span class="line">WHERE </span><br><span class="line">	salary &lt;=&gt; 12000;</span><br></pre></td></tr></table></figure>

<p>【总结】</p>
<p>IS NULL:仅仅可以判断NULL值，可读性较高，建议使用<br>&lt;=&gt;    :既可以判断NULL值，又可以判断普通的数值，可读性较低</p>
<p>【6】面试题</p>
<p>1、表内容如下</p>
<p><img alt="1560413964860" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560413964860.png" class="lazyload"></p>
<p><code>select * from test;</code>和<code>select * from where name like &#39;%%&#39;;</code>查询结果是否一样？</p>
<p>select * from test结果如下：</p>
<p><img alt="1560414017635" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560414017635.png" class="lazyload"></p>
<p>select * from where name like ‘%%’结果如下：</p>
<p><img alt="1560414039763" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560414039763.png" class="lazyload"></p>
<p><strong>%表示任意个数的任意字符(但是不包含null)</strong></p>
<h3 id="3、排序查询"><a href="#3、排序查询" class="headerlink" title="3、排序查询"></a>3、排序查询</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表名</span><br><span class="line">【where  筛选条件】</span><br><span class="line">order by 排序的字段或表达式;</span><br></pre></td></tr></table></figure>



<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1、asc代表的是升序，可以省略，desc代表的是降序</p>
<p>2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段</p>
<p>3、order by子句在查询语句的最后面，除了limit子句</p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1、按单个字段排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees ORDER BY salary DESC;</span><br></pre></td></tr></table></figure>
<p>2、添加筛选条件再排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询部门编号&gt;=90的员工信息，并按员工编号降序</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id&gt;=90</span><br><span class="line">ORDER BY employee_id DESC;</span><br></pre></td></tr></table></figure>

<p>3、按表达式排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息 按年薪降序</span><br><span class="line"></span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;</span><br></pre></td></tr></table></figure>

<p>4、按别名排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息 按年薪升序</span><br><span class="line"></span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY 年薪 ASC;</span><br></pre></td></tr></table></figure>
<p>5、按函数排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工名，并且按名字的长度降序</span><br><span class="line"></span><br><span class="line">SELECT LENGTH(last_name),last_name </span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY LENGTH(last_name) DESC;</span><br></pre></td></tr></table></figure>
<p>6、按多个字段排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息，要求先按工资降序，再按employee_id升序</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC,employee_id ASC;</span><br></pre></td></tr></table></figure>



<h3 id="4、常见函数"><a href="#4、常见函数" class="headerlink" title="4、常见函数"></a>4、常见函数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>1、隐藏了实现细节  2、提高代码的重用性</p>
<p>调用：select 函数名(实参列表) from 表;</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>叫什么（函数名）、干什么（函数功能）</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>1、单行函数<br>    如 concat、length、ifnull等<br>2、分组函数<br>    功能：做统计使用，又称为统计函数、聚合函数、组函数</p>
<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><h5 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h5><h6 id="1、length-获取参数值的字节个数"><a href="#1、length-获取参数值的字节个数" class="headerlink" title="1、length 获取参数值的字节个数"></a>1、length 获取参数值的字节个数</h6><p>获取字节个数(utf-8一个汉字代表3个字节，gbk为2个字节)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&apos;john&apos;);</span><br><span class="line">SELECT LENGTH(&apos;张三丰hahaha&apos;);</span><br><span class="line"># 查看当前字符集</span><br><span class="line">SHOW VARIABLES LIKE &apos;%char%&apos;</span><br></pre></td></tr></table></figure>
<h6 id="2、concat-拼接字符串"><a href="#2、concat-拼接字符串" class="headerlink" title="2、concat 拼接字符串"></a>2、concat 拼接字符串</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(last_name,&apos;_&apos;,first_name) 姓名 FROM employees;</span><br></pre></td></tr></table></figure>
<h6 id="3、upper、lower"><a href="#3、upper、lower" class="headerlink" title="3、upper、lower"></a>3、upper、lower</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&apos;john&apos;);</span><br><span class="line">SELECT LOWER(&apos;joHn&apos;);</span><br><span class="line">#示例：将姓变大写，名变小写，然后拼接</span><br><span class="line">SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;</span><br></pre></td></tr></table></figure>

<h6 id="4、substr、substring"><a href="#4、substr、substring" class="headerlink" title="4、substr、substring"></a>4、substr、substring</h6><p><span style="color:red"><strong>注意：索引从1开始</strong></span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#截取从指定索引处后面所有字符</span><br><span class="line">SELECT SUBSTR(&apos;李莫愁爱上了陆展元&apos;,7)  out_put;</span><br><span class="line"></span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">SELECT SUBSTR(&apos;李莫愁爱上了陆展元&apos;,1,3) out_put;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来</span><br><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&apos;_&apos;,LOWER(SUBSTR(last_name,2)))  out_put</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h6 id="5、instr"><a href="#5、instr" class="headerlink" title="5、instr"></a>5、instr</h6><p>返回子串第一次出现的索引，如果找不到返回0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&apos;杨不殷六侠悔爱上了殷六侠&apos;,&apos;殷六侠&apos;) AS out_put;</span><br></pre></td></tr></table></figure>
<h6 id="6、trim"><a href="#6、trim" class="headerlink" title="6、trim"></a>6、trim</h6><p>只去前后空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(TRIM(&apos;    张翠山    &apos;)) AS out_put;</span><br><span class="line"></span><br><span class="line">SELECT TRIM(&apos;aa&apos; FROM &apos;aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&apos;)  AS out_put;</span><br></pre></td></tr></table></figure>

<h6 id="7、lpad"><a href="#7、lpad" class="headerlink" title="7、lpad"></a>7、lpad</h6><p>用指定的字符实现左填充指定长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&apos;殷素素&apos;,、10,&apos;*&apos;) AS out_put;</span><br></pre></td></tr></table></figure>

<h6 id="8、rpad"><a href="#8、rpad" class="headerlink" title="8、rpad"></a>8、rpad</h6><p>用指定的字符实现右填充指定长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT RPAD(&apos;殷素素&apos;,12,&apos;ab&apos;) AS out_put;</span><br></pre></td></tr></table></figure>



<h6 id="9、replace-替换"><a href="#9、replace-替换" class="headerlink" title="9、replace 替换"></a>9、replace 替换</h6><p>有多个则都替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&apos;周芷若周芷若周芷若周芷若张无忌爱上了周芷若&apos;,&apos;周芷若&apos;,&apos;赵敏&apos;) AS out_put;</span><br></pre></td></tr></table></figure>





<h5 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h5><h6 id="1、round-四舍五入"><a href="#1、round-四舍五入" class="headerlink" title="1、round     四舍五入"></a>1、round     四舍五入</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">SELECT ROUND(1.567,2);</span><br></pre></td></tr></table></figure>
<h6 id="2、ceil-向上取整-返回-gt-该参数的最小整数"><a href="#2、ceil-向上取整-返回-gt-该参数的最小整数" class="headerlink" title="2、ceil         向上取整,返回&gt;=该参数的最小整数"></a>2、ceil         向上取整,返回&gt;=该参数的最小整数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CEIL(-1.02);</span><br></pre></td></tr></table></figure>
<h6 id="3、floor-向下取整，返回-lt-该参数的最大整数"><a href="#3、floor-向下取整，返回-lt-该参数的最大整数" class="headerlink" title="3、floor     向下取整，返回&lt;=该参数的最大整数"></a>3、floor     向下取整，返回&lt;=该参数的最大整数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FLOOR(-9.99);</span><br></pre></td></tr></table></figure>
<h6 id="4、truncate-截断"><a href="#4、truncate-截断" class="headerlink" title="4、truncate 截断"></a>4、truncate 截断</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRUNCATE(1.69999,1);</span><br></pre></td></tr></table></figure>
<h6 id="5、mod取余"><a href="#5、mod取余" class="headerlink" title="5、mod取余"></a>5、mod取余</h6><p>mod(a,b) ： <code>a-a/b*b</code><br>mod(-10,-3):-10- (-10)/(-3)*（-3）=-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MOD(10,-3);</span><br><span class="line">SELECT 10%3;</span><br></pre></td></tr></table></figure>



<h5 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h5><p><img alt="1560432443390" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560432443390.png" class="lazyload"></p>
<h6 id="1、now-返回当前系统日期-时间"><a href="#1、now-返回当前系统日期-时间" class="headerlink" title="1、now 返回当前系统日期+时间"></a>1、now 返回当前系统日期+时间</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW(); #2019-06-13 21:18:30</span><br></pre></td></tr></table></figure>
<h6 id="2、curdate-返回当前系统日期，不包含时间"><a href="#2、curdate-返回当前系统日期，不包含时间" class="headerlink" title="2、curdate 返回当前系统日期，不包含时间"></a>2、curdate 返回当前系统日期，不包含时间</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE(); #2019-06-13</span><br></pre></td></tr></table></figure>
<h6 id="3、curtime-返回当前时间，不包含日期"><a href="#3、curtime-返回当前时间，不包含日期" class="headerlink" title="3、curtime 返回当前时间，不包含日期"></a>3、curtime 返回当前时间，不包含日期</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURTIME(); #21:18:30</span><br></pre></td></tr></table></figure>
<h6 id="4、可以获取指定的部分，年、月、日、小时、分钟、秒"><a href="#4、可以获取指定的部分，年、月、日、小时、分钟、秒" class="headerlink" title="4、可以获取指定的部分，年、月、日、小时、分钟、秒"></a>4、可以获取指定的部分，年、月、日、小时、分钟、秒</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">SELECT YEAR(&apos;1998-1-1&apos;) 年;</span><br><span class="line"></span><br><span class="line">SELECT  YEAR(hiredate) 年 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br></pre></td></tr></table></figure>
<h6 id="5、str-to-date-将字符通过指定的格式转换成日期"><a href="#5、str-to-date-将字符通过指定的格式转换成日期" class="headerlink" title="5、str_to_date 将字符通过指定的格式转换成日期"></a>5、str_to_date 将字符通过指定的格式转换成日期</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&apos;1998-3-2&apos;,&apos;%Y-%m-%d&apos;) AS out_put;</span><br><span class="line"></span><br><span class="line">#案例：查询入职日期为1992--4-3的员工信息</span><br><span class="line">SELECT * FROM employees WHERE hiredate = &apos;1992-4-3&apos;;</span><br><span class="line">#自定义格式化</span><br><span class="line">SELECT * FROM employees WHERE hiredate = STR_TO_DATE(&apos;4-3 1992&apos;,&apos;%c-%d %Y&apos;);</span><br></pre></td></tr></table></figure>
<h6 id="7、date-format-将日期转换成字符"><a href="#7、date-format-将日期转换成字符" class="headerlink" title="7、date_format 将日期转换成字符"></a>7、date_format 将日期转换成字符</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;) AS out_put;</span><br><span class="line"></span><br><span class="line">#案例：查询有奖金的员工名和入职日期(xx月/xx日 xx年)</span><br><span class="line">SELECT last_name,DATE_FORMAT(hiredate,&apos;%m月/%d日 %y年&apos;) 入职日期</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<h5 id="四、其他函数"><a href="#四、其他函数" class="headerlink" title="四、其他函数"></a>四、其他函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br><span class="line">SELECT DATABASE();</span><br><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure>



<h5 id="五、流程控制函数"><a href="#五、流程控制函数" class="headerlink" title="五、流程控制函数"></a>五、流程控制函数</h5><h6 id="1、if函数：-if-else-的效果"><a href="#1、if函数：-if-else-的效果" class="headerlink" title="1、if函数： if else 的效果"></a>1、if函数： if else 的效果</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(10&lt;5,&apos;大&apos;,&apos;小&apos;);</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct,IF(commission_pct IS NULL,&apos;没奖金，呵呵&apos;,&apos;有奖金，嘻嘻&apos;) 备注</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h6 id="2、case函数"><a href="#2、case函数" class="headerlink" title="2、case函数"></a>2、case函数</h6><p>【使用一】 switch case 的效果(适合等值判断)</p>
<p>java中写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量或表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>：语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:语句n;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>mysql中写法：（存储过程使用语句）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case [要判断的字段或表达式]</span><br><span class="line">when 常量1 then 要显示的值1或语句1;</span><br><span class="line">when 常量2 then 要显示的值2或语句2;</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>查询员工的工资，要求</p>
<p>部门号=30，显示的工资为1.1倍<br>部门号=40，显示的工资为1.2倍<br>部门号=50，显示的工资为1.3倍<br>其他部门，显示的工资为原工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">（CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END） AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<p>【使用二】类似于 多重if（适合区间判断）</p>
<p>mysql中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">。。。</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>案例：查询员工的工资的情况<br>如果工资&gt;20000,显示A级别<br>如果工资&gt;15000,显示B级别<br>如果工资&gt;10000，显示C级别<br>否则，显示D级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">WHEN salary&gt;20000 THEN &apos;A&apos;</span><br><span class="line">WHEN salary&gt;15000 THEN &apos;B&apos;</span><br><span class="line">WHEN salary&gt;10000 THEN &apos;C&apos;</span><br><span class="line">ELSE &apos;D&apos;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560435493790" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560435493790.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示系统时间(注：日期+时间)</span><br><span class="line">#SELECT NOW();</span><br><span class="line"></span><br><span class="line"># 查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</span><br><span class="line">select employee_id,last_name,salary,salary*12 as &apos;new salary&apos;</span><br><span class="line">from employees;</span><br><span class="line"></span><br><span class="line">#将员工的姓名按首字母排序，并写出姓名的长度（length）</span><br><span class="line">select last_name,LENGTH(last_name)</span><br><span class="line">from employees</span><br><span class="line">ORDER BY UPPER(SUBSTR(last_name,1,1));</span><br><span class="line"></span><br><span class="line"># 4、</span><br><span class="line">SELECT CONCAT(last_name , &apos; earns &apos; , salary , &apos; monthly but wants &apos;,salary*3)</span><br><span class="line">AS &apos;Dream Salary&apos;</span><br><span class="line">from employees</span><br><span class="line">WHERE salary=24000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5、</span><br><span class="line">SELECT last_name,job_id as job,</span><br><span class="line">CASE job_id</span><br><span class="line">when &apos;AD_PRES&apos; then &apos;A&apos;</span><br><span class="line">when &apos;ST_MAN&apos; then &apos;B&apos;</span><br><span class="line">when &apos;IT_PROG&apos; then &apos;C&apos;</span><br><span class="line">when &apos;SA_REP&apos; then &apos;D&apos;</span><br><span class="line">when &apos;ST_CLERK&apos; then &apos;E&apos;</span><br><span class="line">END</span><br><span class="line">AS grade</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<h3 id="5、分组函数"><a href="#5、分组函数" class="headerlink" title="5、分组函数"></a>5、分组函数</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>用作统计使用，又称为聚合函数或统计函数或组函数</p>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><p>sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>1、sum、avg一般用于处理数值型<br>   max、min、count可以处理任何类型<br>2、以上分组函数都忽略null值</p>
<p>3、可以和distinct搭配实现去重的运算</p>
<p>4、count函数的单独介绍<br>一般使用count(*)用作统计行数</p>
<p>5、和分组函数一同查询的字段要求是group by后的字段</p>
<h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><p>1、简单使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br><span class="line">SELECT AVG(salary) FROM employees;</span><br><span class="line">SELECT MIN(salary) FROM employees;</span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>2、支持的类型</p>
<p>sum、avg一般用于处理数值型，max、min、count可以处理任何类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(last_name) ,AVG(last_name) FROM employees;</span><br><span class="line">SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(last_name),MIN(last_name) FROM employees;</span><br><span class="line">SELECT MAX(hiredate),MIN(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line"># count()只计算不为null的个数</span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT COUNT(last_name) FROM employees;</span><br></pre></td></tr></table></figure>

<p>3、忽略null值</p>
<p>以下分组函数都忽略null值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT commission_pct FROM employees;</span><br></pre></td></tr></table></figure>

<p>4、和distinct搭配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure>



<p>5、count函数详细介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">#一般统计行数，针对所有字段，比如某一行有一个列为空，但是其他列不为空，也算</span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line"></span><br><span class="line">#count参数为常量值，相当于加了一列常量，依然统计行数</span><br><span class="line">SELECT COUNT(1) FROM employees;</span><br></pre></td></tr></table></figure>

<p><strong><em>效率：</em></strong><br><strong>MYISAM存储引擎下  ，<code>COUNT(*)</code>的效率高</strong><br><strong>INNODB存储引擎下，<code>COUNT(*)</code>和COUNT(1)的效率差不多，比COUNT(字段)要高一些</strong></p>
<p>6、和分组函数一同查询的字段有限制</p>
<p>和分组函数一同查询的字段要求是group by后的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#写法不对，AVG为一个值，employee_id为一个列</span><br><span class="line">SELECT AVG(salary),employee_id  FROM employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560478111853" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560478111853.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.查询公司员工工资的最大值，最小值，平均值，总和</span><br><span class="line"></span><br><span class="line">SELECT MAX(salary) 最大值,MIN(salary) 最小值,AVG(salary) 平均值,SUM(salary) 和</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）</span><br><span class="line"></span><br><span class="line">SELECT MAX(hiredate) 最大,MIN(hiredate) 最小,(MAX(hiredate)-MIN(hiredate))/1000/3600/24 DIFFRENCE</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) DIFFRENCE</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(&apos;1995-2-7&apos;,&apos;1995-2-6&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.查询部门编号为90的员工个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM employees WHERE department_id = 90;</span><br></pre></td></tr></table></figure>







<h3 id="6、分组查询"><a href="#6、分组查询" class="headerlink" title="6、分组查询"></a>6、分组查询</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【where 筛选条件】</span><br><span class="line">group by 分组的字段</span><br><span class="line">【order by 排序的字段】;</span><br></pre></td></tr></table></figure>



<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>1、和分组函数一同查询的字段必须是group by后出现的字段<br>2、筛选分为两类：分组前筛选和分组后筛选</p>
<table>
<thead>
<tr>
<th></th>
<th>数据源</th>
<th>位置</th>
<th>连接的关键字</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>group by前</td>
<td>where</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>group by后</td>
<td>having</td>
</tr>
</tbody></table>
<p>问题1：分组函数做筛选能不能放在where后面<br>答：不能</p>
<p>问题2：where——group by——having<br>一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率</p>
<p>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用</p>
<h4 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h4><h5 id="1、简单分组"><a href="#1、简单分组" class="headerlink" title="1、简单分组"></a>1、简单分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询每个工种的员工平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line">#案例2：查询每个位置的部门个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br></pre></td></tr></table></figure>

<h5 id="2、分组前的筛选"><a href="#2、分组前的筛选" class="headerlink" title="2、分组前的筛选"></a>2、分组前的筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询邮箱中包含a字符的 每个部门的最高工资</span><br><span class="line"></span><br><span class="line">SELECT MAX(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &apos;%a%&apos;</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的每个领导手下员工的平均工资</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure>



<h5 id="3、分组后筛选"><a href="#3、分组后筛选" class="headerlink" title="3、分组后筛选"></a>3、分组后筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询哪个部门的员工个数&gt;5</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING COUNT(*)&gt;5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line"></span><br><span class="line">SELECT job_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</span><br><span class="line"></span><br><span class="line">SELECT manager_id,MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id&gt;102</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary)&gt;5000;</span><br></pre></td></tr></table></figure>



<h5 id="4、添加排序"><a href="#4、添加排序" class="headerlink" title="4、添加排序"></a>4、添加排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</span><br><span class="line"></span><br><span class="line">SELECT job_id,MAX(salary) m</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING m&gt;6000</span><br><span class="line">ORDER BY m ;</span><br></pre></td></tr></table></figure>

<h5 id="5、按多个字段分组"><a href="#5、按多个字段分组" class="headerlink" title="5、按多个字段分组"></a>5、按多个字段分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个工种每个部门的最低工资,并按最低工资降序</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),job_id,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br><span class="line">ORDER BY MIN(salary) DESC;</span><br></pre></td></tr></table></figure>



<h3 id="7、连接查询"><a href="#7、连接查询" class="headerlink" title="7、连接查询"></a>7、连接查询</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p>
<p>笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行</p>
<p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p>
<h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><p>按年代分类</p>
<ul>
<li>sql92标准:仅仅支持内连接</li>
<li>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</li>
</ul>
<p><span style="color:red">mysql没有全外连接</span></p>
<p>按功能分类<br>内连接：<br>等值连接、非等值连接、自连接</p>
<p>外连接：<br>左外连接、右外连接、全外连接</p>
<p>交叉连接</p>
<h4 id="1、sql92标准使用"><a href="#1、sql92标准使用" class="headerlink" title="1、sql92标准使用"></a>1、sql92标准使用</h4><h6 id="1、等值连接"><a href="#1、等值连接" class="headerlink" title="1、等值连接"></a>1、等值连接</h6><blockquote>
<p>① 多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③ 多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询女神名和对应的男神名</span><br><span class="line">SELECT NAME,boyName </span><br><span class="line">FROM boys,beauty</span><br><span class="line">WHERE beauty.boyfriend_id= boys.id;</span><br><span class="line"></span><br><span class="line">#案例2：查询员工名和对应的部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees,departments</span><br><span class="line">WHERE employees.`department_id`=departments.`department_id`;</span><br></pre></td></tr></table></figure>



<h6 id="2、为表起别名"><a href="#2、为表起别名" class="headerlink" title="2、为表起别名"></a>2、为表起别名</h6><p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</p>
<p>两个表的顺序可以调换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工名、工种号、工种名</span><br><span class="line"></span><br><span class="line">SELECT e.last_name,e.job_id,j.job_title</span><br><span class="line">FROM employees  e,jobs j</span><br><span class="line">WHERE e.`job_id`=j.`job_id`;</span><br></pre></td></tr></table></figure>



<h6 id="3、加筛选"><a href="#3、加筛选" class="headerlink" title="3、加筛选"></a>3、加筛选</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询有奖金的员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,commission_pct</span><br><span class="line"></span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`commission_pct` IS NOT NULL;</span><br><span class="line"></span><br><span class="line">#案例2：查询城市名中第二个字符为o的部门名和城市名</span><br><span class="line"></span><br><span class="line">SELECT department_name,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id` = l.`location_id`</span><br><span class="line">AND city LIKE &apos;_o%&apos;;</span><br></pre></td></tr></table></figure>



<h6 id="4、加分组"><a href="#4、加分组" class="headerlink" title="4、加分组"></a>4、加分组</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询每个城市的部门个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY city;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span><br><span class="line">SELECT department_name,d.`manager_id`,MIN(salary)</span><br><span class="line">FROM departments d,employees e</span><br><span class="line">WHERE d.`department_id`=e.`department_id`</span><br><span class="line">AND commission_pct IS NOT NULL</span><br><span class="line">GROUP BY department_name,d.`manager_id`</span><br></pre></td></tr></table></figure>

<h6 id="5、加排序"><a href="#5、加排序" class="headerlink" title="5、加排序"></a>5、加排序</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class="line"></span><br><span class="line">SELECT job_title,COUNT(*)</span><br><span class="line">FROM employees e,jobs j</span><br><span class="line">WHERE e.`job_id`=j.`job_id`</span><br><span class="line">GROUP BY job_title</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br></pre></td></tr></table></figure>

<p>6、实现三表连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,departmen t_name,city</span><br><span class="line">FROM employees e,departments d,locations l</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND d.`location_id`=l.`location_id`</span><br><span class="line">AND city LIKE &apos;s%&apos;</span><br><span class="line"></span><br><span class="line">ORDER BY department_name DESC;</span><br></pre></td></tr></table></figure>



<h6 id="2、非等值连接"><a href="#2、非等值连接" class="headerlink" title="2、非等值连接"></a>2、非等值连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询员工的工资和工资级别</span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e,job_grades g</span><br><span class="line">WHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br></pre></td></tr></table></figure>



<h6 id="6、自连接"><a href="#6、自连接" class="headerlink" title="6、自连接"></a>6、自连接</h6><p>自己连接自己</p>
<p><img alt="1560498906057" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560498906057.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">案例：查询 员工名和上级的名称</span><br><span class="line"></span><br><span class="line">SELECT e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure>

<h4 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560499245000" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560499245000.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.显示所有员工的姓名，部门号和部门名称。</span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">SELECT last_name,d.department_id,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id` = d.`department_id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.查询90号部门员工的job_id和90号部门的location_id</span><br><span class="line"></span><br><span class="line">SELECT job_id,location_id</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`department_id`=90;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.	选择所有有奖金的员工的</span><br><span class="line">last_name , department_name , location_id , city</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT last_name , department_name , l.location_id , city</span><br><span class="line">FROM employees e,departments d,locations l</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">AND d.location_id=l.location_id</span><br><span class="line">AND e.commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.选择city在Toronto工作的员工的</span><br><span class="line">last_name , job_id , department_id , department_name </span><br><span class="line"></span><br><span class="line">SELECT last_name , job_id , d.department_id , department_name </span><br><span class="line">FROM employees e,departments d ,locations l</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">AND d.location_id=l.location_id</span><br><span class="line">AND city = &apos;Toronto&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.查询每个工种、每个部门的部门名、工种名和最低工资</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT department_name,job_title,MIN(salary) 最低工资</span><br><span class="line">FROM employees e,departments d,jobs j</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`job_id`=j.`job_id`</span><br><span class="line">GROUP BY department_name,job_title;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.查询每个国家下的部门个数大于2的国家编号</span><br><span class="line"></span><br><span class="line">SELECT country_id,COUNT(*) 部门个数</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY country_id</span><br><span class="line">HAVING 部门个数&gt;2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#7、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式</span><br><span class="line">employees	Emp#	manager	Mgr#</span><br><span class="line">kochhar		101	king	100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT e.last_name employees,e.employee_id &quot;Emp#&quot;,m.last_name manager,m.employee_id &quot;Mgr#&quot;</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.manager_id = m.employee_id</span><br><span class="line">AND e.last_name=&apos;kochhar&apos;;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="2、sql99标准使用"><a href="#2、sql99标准使用" class="headerlink" title="2、sql99标准使用"></a>2、sql99标准使用</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名 【连接类型】</span><br><span class="line">join 表2 别名 </span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组】</span><br><span class="line">【having 筛选条件】</span><br><span class="line">【order by 排序列表】</span><br></pre></td></tr></table></figure>
<h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><p>内连接：inner<br>外连接：左外:left 【outer】、右外：right 【outer】、全外：full【outer】<br>交叉连接：cross </p>
<h5 id="1、内连接使用"><a href="#1、内连接使用" class="headerlink" title="1、内连接使用"></a>1、内连接使用</h5><h6 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">inner join 表2 别名</span><br><span class="line">on 连接条件;</span><br></pre></td></tr></table></figure>

<h6 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h6><p>等值、非等值、自连接</p>
<h6 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h6><p>①添加排序、分组、筛选<br>②inner可以省略<br>③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p>
<h6 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1.查询员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM departments d</span><br><span class="line"> JOIN  employees e</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2.查询名字中包含e的员工名和工种名（添加筛选）</span><br><span class="line">SELECT last_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN jobs j</span><br><span class="line">ON e.`job_id`=  j.`job_id`</span><br><span class="line">WHERE e.`last_name` LIKE &apos;%e%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3. 查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</span><br><span class="line"></span><br><span class="line">#①查询每个城市的部门个数</span><br><span class="line">#②在①结果上筛选满足条件的</span><br><span class="line">SELECT city,COUNT(*) 部门个数</span><br><span class="line">FROM departments d</span><br><span class="line">INNER JOIN locations l</span><br><span class="line">ON d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY city</span><br><span class="line">HAVING COUNT(*)&gt;3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</span><br><span class="line"></span><br><span class="line">#①查询每个部门的员工个数</span><br><span class="line">SELECT COUNT(*),department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.`department_id`=d.`department_id`</span><br><span class="line">GROUP BY department_name</span><br><span class="line"></span><br><span class="line">#② 在①结果上筛选员工个数&gt;3的记录，并排序</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.`department_id`=d.`department_id`</span><br><span class="line">GROUP BY department_name</span><br><span class="line">HAVING COUNT(*)&gt;3</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br><span class="line"></span><br><span class="line">#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d ON e.`department_id`=d.`department_id`</span><br><span class="line">INNER JOIN jobs j ON e.`job_id` = j.`job_id`</span><br><span class="line"></span><br><span class="line">ORDER BY department_name DESC;</span><br></pre></td></tr></table></figure>





<h6 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的工资级别</span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e</span><br><span class="line"> JOIN job_grades g</span><br><span class="line"> ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #查询工资级别的个数&gt;20的个数，并且按工资级别降序</span><br><span class="line"> SELECT COUNT(*),grade_level</span><br><span class="line">FROM employees e</span><br><span class="line"> JOIN job_grades g</span><br><span class="line"> ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`</span><br><span class="line"> GROUP BY grade_level</span><br><span class="line"> HAVING COUNT(*)&gt;20</span><br><span class="line"> ORDER BY grade_level DESC;</span><br></pre></td></tr></table></figure>

<h6 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.`manager_id`= m.`employee_id`;</span><br><span class="line"></span><br><span class="line"> #查询姓名中包含字符k的员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.`manager_id`= m.`employee_id`</span><br><span class="line">WHERE e.`last_name` LIKE &apos;%k%&apos;;</span><br></pre></td></tr></table></figure>



<h5 id="2、外连接使用"><a href="#2、外连接使用" class="headerlink" title="2、外连接使用"></a>2、外连接使用</h5><p> 应用场景：用于查询一个表中有，另一个表没有的记录</p>
<p> 特点：<br> 1、外连接的查询结果为主表中的所有记录。如果从表中有和它匹配的，则显示匹配的值。如果从表中没有和它匹配的，则显示null</p>
<p>外连接查询结果=内连接结果+主表中有而从表没有的记录</p>
<p> 2、左外连接，left join左边的是主表<br>    右外连接，right join右边的是主表</p>
<p> 3、左外和右外交换两个表的顺序，可以实现同样的效果 </p>
<p> 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入：查询男朋友 不在男神表的的女神名</span><br><span class="line"> #左外连接</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM boys bo</span><br><span class="line"> LEFT OUTER JOIN beauty b</span><br><span class="line"> ON b.`boyfriend_id` = bo.`id`</span><br><span class="line"> WHERE b.`id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #案例1：查询哪个部门没有员工</span><br><span class="line"> #左外</span><br><span class="line"> SELECT d.*,e.employee_id</span><br><span class="line"> FROM departments d</span><br><span class="line"> LEFT OUTER JOIN employees e</span><br><span class="line"> ON d.`department_id` = e.`department_id`</span><br><span class="line"> WHERE e.`employee_id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #右外</span><br><span class="line">SELECT d.*,e.employee_id</span><br><span class="line"> FROM employees e</span><br><span class="line"> RIGHT OUTER JOIN departments d</span><br><span class="line"> ON d.`department_id` = e.`department_id`</span><br><span class="line"> WHERE e.`employee_id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #全外	mysql没有全外连接</span><br><span class="line"> USE girls;</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> FULL OUTER JOIN boys bo</span><br><span class="line"> ON b.`boyfriend_id` = bo.id;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> #交叉连接	笛卡尔乘积</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> CROSS JOIN boys bo;</span><br></pre></td></tr></table></figure>



<h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><p>图示内外连接</p>
<p><img alt="1560566711450" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566711450.png" class="lazyload"></p>
<p><img alt="1560566734011" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566734011.png" class="lazyload"></p>
<p><strong><em>sql92和sql99：</em></strong></p>
<p> 功能：sql99支持的较多<br> 可读性：sql99实现连接条件和筛选条件的分离，可读性较高</p>
<h4 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560577215475" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560577215475.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT b.id,b.name,bo.*</span><br><span class="line">FROM beauty b</span><br><span class="line">LEFT OUTER JOIN boys bo</span><br><span class="line">ON b.`boyfriend_id` = bo.`id`</span><br><span class="line">WHERE b.`id`&gt;3;</span><br><span class="line">#二、查询哪个城市没有部门</span><br><span class="line"></span><br><span class="line">SELECT city</span><br><span class="line">FROM departments d</span><br><span class="line">RIGHT OUTER JOIN locations l </span><br><span class="line">ON d.`location_id`=l.`location_id`</span><br><span class="line">WHERE  d.`department_id` IS NULL;</span><br><span class="line"></span><br><span class="line">#三、查询部门名为SAL或IT的员工信息</span><br><span class="line"></span><br><span class="line">SELECT e.*,d.department_name,d.`department_id`</span><br><span class="line">FROM departments  d</span><br><span class="line">LEFT JOIN employees e</span><br><span class="line">ON d.`department_id` = e.`department_id`</span><br><span class="line">WHERE d.`department_name` IN(&apos;SAL&apos;,&apos;IT&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM departments</span><br><span class="line">WHERE `department_name` IN(&apos;SAL&apos;,&apos;IT&apos;);</span><br></pre></td></tr></table></figure>



<h3 id="8、子查询"><a href="#8、子查询" class="headerlink" title="8、子查询"></a>8、子查询</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询</p>
<h4 id="分类-6"><a href="#分类-6" class="headerlink" title="分类"></a>分类</h4><p>按子查询出现的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select后面：</span><br><span class="line">		仅仅支持标量子查询</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">from后面：</span><br><span class="line">		支持表子查询</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">where或having后面：★</span><br><span class="line">		标量子查询（单行） √</span><br><span class="line">		列子查询  （多行） √</span><br><span class="line">		行子查询</span><br><span class="line"></span><br><span class="line">exists后面（相关子查询）</span><br><span class="line">		表子查询</span><br></pre></td></tr></table></figure>



<p>按结果集的行列数不同：<br>    标量子查询（结果集只有一行一列）<br>    列子查询（结果集只有一列多行）<br>    行子查询（结果集有一行多列）<br>    表子查询（结果集一般为多行多列）</p>
<h4 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h4><h5 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、标量子查询（单行子查询）</span><br><span class="line">2、列子查询（多行子查询）</span><br><span class="line"></span><br><span class="line">3、行子查询（多列多行）</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">①子查询放在小括号内</span><br><span class="line">②子查询一般放在条件的右侧</span><br><span class="line">③标量子查询，一般搭配着单行操作符使用</span><br><span class="line">&gt; &lt; &gt;= &lt;= = &lt;&gt;</span><br><span class="line"></span><br><span class="line">列子查询，一般搭配着多行操作符使用</span><br><span class="line">in、any/some、all</span><br><span class="line"></span><br><span class="line">④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</span><br></pre></td></tr></table></figure>



<p>1、标量子查询（一行一列一个值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：谁的工资比 Abel 高?</span><br><span class="line"></span><br><span class="line">#①查询Abel的工资</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &apos;Abel&apos;</span><br><span class="line"></span><br><span class="line">#②查询员工的信息，满足 salary&gt;①结果</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line"></span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = &apos;Abel&apos;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</span><br><span class="line"></span><br><span class="line">#①查询141号员工的job_id</span><br><span class="line">SELECT job_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id = 141</span><br><span class="line"></span><br><span class="line">#②查询143号员工的salary</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id = 143</span><br><span class="line"></span><br><span class="line">#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = (</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id = 141</span><br><span class="line">) AND salary&gt;(</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id = 143</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class="line"></span><br><span class="line">#①查询公司的 最低工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询last_name,job_id和salary，要求salary=①</span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例4：查询 最低工资大于50号部门 的 最低工资的部门id和其最低工资</span><br><span class="line"></span><br><span class="line">#①查询50号部门的最低工资</span><br><span class="line">SELECT  MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 50</span><br><span class="line"></span><br><span class="line">#②查询每个部门的最低工资</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#③ 在②基础上筛选，满足min(salary)&gt;①</span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary)&gt;(</span><br><span class="line">	SELECT  MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE department_id = 50</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>2、列子查询（多行子查询）★</p>
<p><img alt="1560585303384" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560585303384.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：返回location_id是1400或1700的部门中的所有员工姓名</span><br><span class="line"></span><br><span class="line">#①查询location_id是1400或1700的部门编号</span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments</span><br><span class="line">WHERE location_id IN(1400,1700)</span><br><span class="line"></span><br><span class="line">#②查询员工姓名，要求部门号是①列表中的某一个</span><br><span class="line"></span><br><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id  IN(</span><br><span class="line">#WHERE department_id = ANY(</span><br><span class="line">#WHERE department_id &lt;&gt; ALL(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">	FROM departments</span><br><span class="line">	WHERE location_id IN(1400,1700)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">#①查询job_id为‘IT_PROG’部门任一工资</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ANY(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ALL(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MIN( salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br></pre></td></tr></table></figure>

<p>3、行子查询（结果集一行多列或多行多列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工编号最小并且工资最高的员工信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM employees</span><br><span class="line">WHERE (employee_id,salary)=(</span><br><span class="line">	SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#①查询最小的员工编号</span><br><span class="line">SELECT MIN(employee_id)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询最高工资</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#③查询员工信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id=(</span><br><span class="line">	SELECT MIN(employee_id)</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">)AND salary=(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h5 id="select后面"><a href="#select后面" class="headerlink" title="select后面"></a>select后面</h5><p>仅仅支持标量子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的员工个数</span><br><span class="line"></span><br><span class="line">#相当于主查询每查一行都会获取d.`department_id`的常量值，然后利用这个常量值去子查询里面统计人数</span><br><span class="line">SELECT d.*,(</span><br><span class="line"></span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.department_id = d.`department_id`</span><br><span class="line"> ) 个数</span><br><span class="line"> FROM departments d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #案例2：查询员工号=102的部门名</span><br><span class="line"></span><br><span class="line">SELECT (</span><br><span class="line">	SELECT department_name,e.department_id</span><br><span class="line">	FROM departments d</span><br><span class="line">	INNER JOIN employees e</span><br><span class="line">	ON d.department_id=e.department_id</span><br><span class="line">	WHERE e.employee_id=102</span><br><span class="line">	</span><br><span class="line">) 部门名;</span><br></pre></td></tr></table></figure>





<h5 id="from后面"><a href="#from后面" class="headerlink" title="from后面"></a>from后面</h5><p>将子查询结果充当一张表，要求必须起别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的平均工资的工资等级</span><br><span class="line">#①查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">SELECT * FROM job_grades;</span><br><span class="line"></span><br><span class="line">#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line"></span><br><span class="line">SELECT  ag_dep.*,g.`grade_level`</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line">INNER JOIN job_grades g</span><br><span class="line">ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</span><br></pre></td></tr></table></figure>

<h5 id="exists后面（相关子查询）"><a href="#exists后面（相关子查询）" class="headerlink" title="exists后面（相关子查询）"></a>exists后面（相关子查询）</h5><p>语法：<br>exists(完整的查询语句)<br>结果：1或0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);</span><br><span class="line"></span><br><span class="line">#案例1：查询有员工的部门名</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.`department_id` IN(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line"></span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE d.`department_id`=e.`department_id`</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：查询没有女朋友的男神信息</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line"></span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE bo.id NOT IN(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty b</span><br><span class="line">	WHERE bo.`id`=b.`boyfriend_id`</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560608516119" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560608516119.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	查询和Zlotkey相同部门的员工姓名和工资</span><br><span class="line"></span><br><span class="line">#①查询Zlotkey的部门</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &apos;Zlotkey&apos;</span><br><span class="line"></span><br><span class="line">#②查询部门号=①的姓名和工资</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = (</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = &apos;Zlotkey&apos;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#2.查询工资比公司平均工资高的员工的员工号，姓名和工资。</span><br><span class="line"></span><br><span class="line">#①查询平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询工资&gt;①的员工号，姓名和工资。</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line"></span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资</span><br><span class="line">#①查询各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#②连接①结果集和employees表，进行筛选</span><br><span class="line">SELECT employee_id,last_name,salary,e.department_id</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">) ag_dep</span><br><span class="line">ON e.department_id = ag_dep.department_id</span><br><span class="line">WHERE salary&gt;ag_dep.ag ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.	查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</span><br><span class="line">#①查询姓名中包含字母u的员工的部门</span><br><span class="line"></span><br><span class="line">SELECT  DISTINCT department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%u%&apos;</span><br><span class="line"></span><br><span class="line">#②查询部门号=①中的任意一个的员工号和姓名</span><br><span class="line">SELECT last_name,employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN(</span><br><span class="line">	SELECT  DISTINCT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name LIKE &apos;%u%&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5. 查询在部门的location_id为1700的部门工作的员工的员工号</span><br><span class="line"></span><br><span class="line">#①查询location_id为1700的部门</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments </span><br><span class="line">WHERE location_id  = 1700</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②查询部门号=①中的任意一个的员工号</span><br><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id =ANY(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">	FROM departments </span><br><span class="line">	WHERE location_id  = 1700</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#6.查询管理者是King的员工姓名和工资</span><br><span class="line"></span><br><span class="line">#①查询姓名为king的员工编号</span><br><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name  = &apos;K_ing&apos;</span><br><span class="line"></span><br><span class="line">#②查询哪个员工的manager_id = ①</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id IN(</span><br><span class="line">	SELECT employee_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name  = &apos;K_ing&apos;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#7.查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#①查询最高工资</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询工资=①的姓.名</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(first_name,last_name) &quot;姓.名&quot;</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>经典案例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 查询工资最低的员工信息: last_name, salary</span><br><span class="line"></span><br><span class="line">#①查询最低的工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询last_name,salary，要求salary=①</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 2. 查询平均工资最低的部门信息</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">#②查询①结果上的最低平均工资</span><br><span class="line">SELECT MIN(ag)</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line"></span><br><span class="line">#③查询哪个部门的平均工资=②</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)=(</span><br><span class="line">	SELECT MIN(ag)</span><br><span class="line">	FROM (</span><br><span class="line">		SELECT AVG(salary) ag,department_id</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">	) ag_dep</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#④查询部门信息</span><br><span class="line"></span><br><span class="line">SELECT d.*</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.`department_id`=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING AVG(salary)=(</span><br><span class="line">		SELECT MIN(ag)</span><br><span class="line">		FROM (</span><br><span class="line">			SELECT AVG(salary) ag,department_id</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">		) ag_dep</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#②求出最低平均工资的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line"></span><br><span class="line">#③查询部门信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments</span><br><span class="line">WHERE department_id=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY AVG(salary) </span><br><span class="line">	LIMIT 1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3. 查询平均工资最低的部门信息和该部门的平均工资</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">#②求出最低平均工资的部门编号</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line">#③查询部门信息</span><br><span class="line">SELECT d.*,ag</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY AVG(salary) </span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line">) ag_dep</span><br><span class="line">ON d.`department_id`=ag_dep.department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4. 查询平均工资最高的 job 信息</span><br><span class="line">#①查询最高的job的平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id</span><br><span class="line">ORDER BY AVG(salary) DESC</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line">#②查询job信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM jobs</span><br><span class="line">WHERE job_id=(</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY job_id</span><br><span class="line">	ORDER BY AVG(salary) DESC</span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"># 5. 查询平均工资高于公司平均工资的部门有哪些?</span><br><span class="line"></span><br><span class="line">#①查询平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#③筛选②结果集，满足平均工资&gt;①</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)&gt;(</span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 6. 查询出公司中所有 manager 的详细信息.</span><br><span class="line">#①查询所有manager的员工编号</span><br><span class="line">SELECT DISTINCT manager_id</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询详细信息，满足employee_id=①</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id =ANY(</span><br><span class="line">	SELECT DISTINCT manager_id</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少</span><br><span class="line"></span><br><span class="line">#①查询各部门的最高工资中最低的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY MAX(salary)</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②查询①结果的那个部门的最低工资</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary) ,department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY MAX(salary)</span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"># 8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</span><br><span class="line">#①查询平均工资最高的部门编号</span><br><span class="line">SELECT </span><br><span class="line">    department_id </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">ORDER BY AVG(salary) DESC </span><br><span class="line">LIMIT 1 </span><br><span class="line"></span><br><span class="line">#②将employees和departments连接查询，筛选条件是①</span><br><span class="line">    SELECT </span><br><span class="line">        last_name, d.department_id, email, salary </span><br><span class="line">    FROM</span><br><span class="line">        employees e </span><br><span class="line">        INNER JOIN departments d </span><br><span class="line">            ON d.manager_id = e.employee_id </span><br><span class="line">    WHERE d.department_id = </span><br><span class="line">        (SELECT </span><br><span class="line">            department_id </span><br><span class="line">        FROM</span><br><span class="line">            employees </span><br><span class="line">        GROUP BY department_id </span><br><span class="line">        ORDER BY AVG(salary) DESC </span><br><span class="line">        LIMIT 1) ;</span><br></pre></td></tr></table></figure>





<h3 id="9、分页查询"><a href="#9、分页查询" class="headerlink" title="9、分页查询"></a>9、分页查询</h3><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
<h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【join type join 表2】</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by 排序的字段】</span><br><span class="line">limit 【offset,】size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset要显示条目的起始索引（起始索引从0开始）</span><br><span class="line">size 要显示的条目个数</span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>①limit语句放在查询语句的最后<br>②公式<br>要显示的页数 page，每页的条目数size</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">limit (page-1)*size,size;</span><br></pre></td></tr></table></figure>



<h4 id="使用-7"><a href="#使用-7" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询前五条员工信息</span><br><span class="line">SELECT * FROM  employees LIMIT 0,5;</span><br><span class="line">SELECT * FROM  employees LIMIT 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询第11条——第25条</span><br><span class="line">SELECT * FROM  employees LIMIT 10,15;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：有奖金的员工信息，并且工资较高的前10名显示出来</span><br><span class="line">SELECT </span><br><span class="line">    * </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 ;</span><br></pre></td></tr></table></figure>



<h3 id="10、查询大练习"><a href="#10、查询大练习" class="headerlink" title="10、查询大练习"></a>10、查询大练习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、查询每个专业的学生人数</span><br><span class="line">SELECT majorid,COUNT(*)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY majorid;</span><br><span class="line"></span><br><span class="line">#二、查询参加考试的学生中，每个学生的平均分、最高分</span><br><span class="line">SELECT AVG(score),MAX(score),studentno</span><br><span class="line">FROM result</span><br><span class="line">GROUP BY studentno;</span><br><span class="line"></span><br><span class="line">#三、查询姓张的每个学生的最低分大于60的学号、姓名</span><br><span class="line">SELECT s.studentno,s.`studentname`,MIN(score)</span><br><span class="line">FROM student s</span><br><span class="line">JOIN result r</span><br><span class="line">ON s.`studentno`=r.`studentno`</span><br><span class="line">WHERE s.`studentname` LIKE &apos;张%&apos;</span><br><span class="line">GROUP BY s.`studentno`</span><br><span class="line">HAVING MIN(score)&gt;60;</span><br><span class="line">#四、查询每个专业生日在“1988-1-1”后的学生姓名、专业名称</span><br><span class="line"></span><br><span class="line">SELECT m.`majorname`,s.`studentname`</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m</span><br><span class="line">ON m.`majorid`=s.`majorid`</span><br><span class="line">WHERE DATEDIFF(borndate,&apos;1988-1-1&apos;)&gt;0</span><br><span class="line">GROUP BY m.`majorid`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#五、查询每个专业的男生人数和女生人数分别是多少</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),sex,majorid</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY sex,majorid;</span><br><span class="line">#六、查询专业和张翠山一样的学生的最低分</span><br><span class="line">#①查询张翠山的专业编号</span><br><span class="line">SELECT majorid</span><br><span class="line">FROM student</span><br><span class="line">WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">#②查询编号=①的所有学生编号</span><br><span class="line">SELECT studentno</span><br><span class="line">FROM student</span><br><span class="line">WHERE majorid=(</span><br><span class="line">	SELECT majorid</span><br><span class="line">	FROM student</span><br><span class="line">	WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">#②查询最低分</span><br><span class="line">SELECT MIN(score)</span><br><span class="line">FROM result</span><br><span class="line">WHERE studentno IN(</span><br><span class="line"></span><br><span class="line">	SELECT studentno</span><br><span class="line">	FROM student</span><br><span class="line">	WHERE majorid=(</span><br><span class="line">		SELECT majorid</span><br><span class="line">		FROM student</span><br><span class="line">		WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#七、查询大于60分的学生的姓名、密码、专业名</span><br><span class="line"></span><br><span class="line">SELECT studentname,loginpwd,majorname</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m ON s.majorid=  m.majorid</span><br><span class="line">JOIN result r ON s.studentno=r.studentno</span><br><span class="line">WHERE r.score&gt;60;</span><br><span class="line">#八、按邮箱位数分组，查询每组的学生个数</span><br><span class="line">SELECT COUNT(*),LENGTH(email)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY LENGTH(email);</span><br><span class="line">#九、查询学生名、专业名、分数</span><br><span class="line"></span><br><span class="line">SELECT studentname,score,majorname</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m ON s.majorid=  m.majorid</span><br><span class="line">LEFT JOIN result r ON s.studentno=r.studentno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#十、查询哪个专业没有学生，分别用左连接和右连接实现</span><br><span class="line">#左</span><br><span class="line">SELECT m.`majorid`,m.`majorname`,s.`studentno`</span><br><span class="line">FROM major m</span><br><span class="line">LEFT JOIN student s ON m.`majorid` = s.`majorid`</span><br><span class="line">WHERE s.`studentno` IS NULL;</span><br><span class="line"></span><br><span class="line">#右</span><br><span class="line">SELECT m.`majorid`,m.`majorname`,s.`studentno`</span><br><span class="line">FROM student s</span><br><span class="line">RIGHT JOIN  major m ON m.`majorid` = s.`majorid`</span><br><span class="line">WHERE s.`studentno` IS NULL;</span><br><span class="line">#十一、查询没有成绩的学生人数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM student s</span><br><span class="line">LEFT JOIN result r ON s.`studentno` = r.`studentno`</span><br><span class="line">WHERE r.`id` IS NULL</span><br></pre></td></tr></table></figure>

<h3 id="11、union联合查询"><a href="#11、union联合查询" class="headerlink" title="11、union联合查询"></a>11、union联合查询</h3><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>
<h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p>
<h4 id="特点：★"><a href="#特点：★" class="headerlink" title="特点：★"></a>特点：★</h4><p>1、要求多条查询语句的查询列数是一致的！<br>2、<strong>要求多条查询语句的查询的每一列的类型和顺序最好一致</strong><br>3、union关键字默认去重，如果使用union all 可以包含重复项</p>
<h4 id="使用-8"><a href="#使用-8" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees WHERE email LIKE &apos;%a%&apos; OR department_id&gt;90;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees  WHERE email LIKE &apos;%a%&apos;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees  WHERE department_id&gt;90;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息</span><br><span class="line">SELECT id,cname FROM t_ca WHERE csex=&apos;男&apos;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT t_id,tname FROM t_ua WHERE tGender=&apos;male&apos;;</span><br></pre></td></tr></table></figure>







<h2 id="4、DML语言学习"><a href="#4、DML语言学习" class="headerlink" title="4、DML语言学习"></a>4、DML语言学习</h2><blockquote>
<p>Data Manipulate Language —— 数据操作语言</p>
<p>insert 、update、delete</p>
</blockquote>
<h3 id="1、插入语句"><a href="#1、插入语句" class="headerlink" title="1、插入语句"></a>1、插入语句</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名(列名,...) </span><br><span class="line">values(值1,...);</span><br></pre></td></tr></table></figure>

<h5 id="使用-9"><a href="#使用-9" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM beauty;</span><br><span class="line">#1.插入的值的类型要与列的类型一致或兼容</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&apos;唐艺昕&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br><span class="line"></span><br><span class="line">#2.为空的列可以赋值null，也可以不对其列赋值</span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&apos;唐艺昕&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,sex,phone)</span><br><span class="line">VALUES(15,&apos;娜扎&apos;,&apos;女&apos;,&apos;1388888888&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.列的顺序可以调换</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&apos;蒋欣&apos;,&apos;女&apos;,16,&apos;110&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.列数和值的个数必须一致</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&apos;关晓彤&apos;,&apos;女&apos;,17,&apos;110&apos;);</span><br><span class="line"></span><br><span class="line">#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致   </span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(18,&apos;张飞&apos;,&apos;男&apos;,NULL,&apos;119&apos;,NULL,NULL);</span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">set 列名=值,列名=值,...</span><br></pre></td></tr></table></figure>

<h5 id="使用-10"><a href="#使用-10" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">SET id=19,NAME=&apos;刘涛&apos;,phone=&apos;999&apos;;</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1、方式一支持插入多行,方式二不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(23,&apos;唐艺昕1&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2)</span><br><span class="line">,(24,&apos;唐艺昕2&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2)</span><br><span class="line">,(25,&apos;唐艺昕3&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br></pre></td></tr></table></figure>



<p>2、方式一支持子查询，方式二不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT 26,&apos;宋茜&apos;,&apos;11809866&apos;;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">(</span><br><span class="line">    SELECT id,boyname,&apos;1234567&apos;</span><br><span class="line">	FROM boys WHERE id&lt;3;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>方式一使用较多</p>
<h3 id="2、修改语句"><a href="#2、修改语句" class="headerlink" title="2、修改语句"></a>2、修改语句</h3><h4 id="1、修改单表的记录★"><a href="#1、修改单表的记录★" class="headerlink" title="1、修改单表的记录★"></a>1、修改单表的记录★</h4><h5 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 列 = 新值,列 = 新值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="使用-11"><a href="#使用-11" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.修改单表的记录</span><br><span class="line">#案例1：修改beauty表中姓唐的女神的电话为13899888899</span><br><span class="line"></span><br><span class="line">UPDATE beauty SET phone = &apos;13899888899&apos;</span><br><span class="line">WHERE NAME LIKE &apos;唐%&apos;;</span><br><span class="line"></span><br><span class="line">#案例2：修改boys表中id好为2的名称为张飞，魅力值 10</span><br><span class="line">UPDATE boys SET boyname=&apos;张飞&apos;,usercp=10</span><br><span class="line">WHERE id=2;</span><br></pre></td></tr></table></figure>



<h4 id="2、修改多表的记录【补充】"><a href="#2、修改多表的记录【补充】" class="headerlink" title="2、修改多表的记录【补充】"></a>2、修改多表的记录【补充】</h4><h5 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql92语法：</span><br><span class="line">update 表1 别名,表2 别名</span><br><span class="line">set 列=值,...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 列=值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="使用-12"><a href="#使用-12" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例 1：修改张无忌的女朋友的手机号为114</span><br><span class="line"></span><br><span class="line">UPDATE boys bo</span><br><span class="line">INNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`</span><br><span class="line">SET b.`phone`=&apos;114&apos;,bo.`userCP`=1000</span><br><span class="line">WHERE bo.`boyName`=&apos;张无忌&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：修改没有男朋友的女神的男朋友编号都为2号</span><br><span class="line"></span><br><span class="line">UPDATE boys bo</span><br><span class="line">RIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`</span><br><span class="line">SET b.`boyfriend_id`=2</span><br><span class="line">WHERE bo.`id` IS NULL;</span><br><span class="line"></span><br><span class="line">SELECT * FROM boys;</span><br></pre></td></tr></table></figure>



<h3 id="3、删除语句"><a href="#3、删除语句" class="headerlink" title="3、删除语句"></a>3、删除语句</h3><h4 id="方式一：delete"><a href="#方式一：delete" class="headerlink" title="方式一：delete"></a>方式一：delete</h4><h5 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h5><p>1、单表的删除【★】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 筛选条件;</span><br></pre></td></tr></table></figure>

<p>2、多表的删除【补充】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql92语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line"></span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>
<h5 id="使用-13"><a href="#使用-13" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">======================单表删除==================</span><br><span class="line">#案例：删除手机号以9结尾的女神信息</span><br><span class="line"></span><br><span class="line">DELETE FROM beauty WHERE phone LIKE &apos;%9&apos;;</span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：删除张无忌的女朋友的信息</span><br><span class="line"></span><br><span class="line">DELETE b</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`</span><br><span class="line">WHERE bo.`boyName`=&apos;张无忌&apos;;</span><br><span class="line"></span><br><span class="line">======================多表删除==================</span><br><span class="line">#案例：删除黄晓明的信息以及他女朋友的信息</span><br><span class="line">DELETE b,bo</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`</span><br><span class="line">WHERE bo.`boyName`=&apos;黄晓明&apos;;</span><br></pre></td></tr></table></figure>



<h4 id="方式二：truncate"><a href="#方式二：truncate" class="headerlink" title="方式二：truncate"></a>方式二：truncate</h4><p>清除表所有数据</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><p>1、delete 可以加where 条件，truncate不能加</p>
<p>2、truncate删除，效率高一丢丢</p>
<p><strong>3、假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</strong></p>
<p>4、truncate删除没有返回值，delete删除有返回值</p>
<p>5、truncate删除不能回滚，delete删除可以回滚.</p>
<h3 id="4、练习"><a href="#4、练习" class="headerlink" title="4、练习"></a>4、练习</h3><p><img alt="1560740250627" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560740250627.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	运行以下脚本创建表my_employees</span><br><span class="line"></span><br><span class="line">USE myemployees;</span><br><span class="line">CREATE TABLE my_employees(</span><br><span class="line">	Id INT(10),</span><br><span class="line">	First_name VARCHAR(10),</span><br><span class="line">	Last_name VARCHAR(10),</span><br><span class="line">	Userid VARCHAR(10),</span><br><span class="line">	Salary DOUBLE(10,2)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE users(</span><br><span class="line">	id INT,</span><br><span class="line">	userid VARCHAR(10),</span><br><span class="line">	department_id INT</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#2.	显示表my_employees的结构</span><br><span class="line">DESC my_employees;</span><br><span class="line"></span><br><span class="line">#3.	向my_employees表中插入下列数据</span><br><span class="line">ID	FIRST_NAME	LAST_NAME	USERID	SALARY</span><br><span class="line">1	patel		Ralph		Rpatel	895</span><br><span class="line">2	Dancs		Betty		Bdancs	860</span><br><span class="line">3	Biri		Ben		Bbiri	1100</span><br><span class="line">4	Newman		Chad		Cnewman	750</span><br><span class="line">5	Ropeburn	Audrey		Aropebur	1550</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">VALUES(1,&apos;patel&apos;,&apos;Ralph&apos;,&apos;Rpatel&apos;,895),</span><br><span class="line">(2,&apos;Dancs&apos;,&apos;Betty&apos;,&apos;Bdancs&apos;,860),</span><br><span class="line">(3,&apos;Biri&apos;,&apos;Ben&apos;,&apos;Bbiri&apos;,1100),</span><br><span class="line">(4,&apos;Newman&apos;,&apos;Chad&apos;,&apos;Cnewman&apos;,750),</span><br><span class="line">(5,&apos;Ropeburn&apos;,&apos;Audrey&apos;,&apos;Aropebur&apos;,1550);</span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">SELECT 1,&apos;patel&apos;,&apos;Ralph&apos;,&apos;Rpatel&apos;,895 UNION</span><br><span class="line">SELECT 2,&apos;Dancs&apos;,&apos;Betty&apos;,&apos;Bdancs&apos;,860 UNION</span><br><span class="line">SELECT 3,&apos;Biri&apos;,&apos;Ben&apos;,&apos;Bbiri&apos;,1100 UNION</span><br><span class="line">SELECT 4,&apos;Newman&apos;,&apos;Chad&apos;,&apos;Cnewman&apos;,750 UNION</span><br><span class="line">SELECT 5,&apos;Ropeburn&apos;,&apos;Audrey&apos;,&apos;Aropebur&apos;,1550;</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line">#4.	 向users表中插入数据</span><br><span class="line">1	Rpatel	10</span><br><span class="line">2	Bdancs	10</span><br><span class="line">3	Bbiri	20</span><br><span class="line">4	Cnewman	30</span><br><span class="line">5	Aropebur	40</span><br><span class="line"></span><br><span class="line">INSERT INTO users</span><br><span class="line">VALUES(1,&apos;Rpatel&apos;,10),</span><br><span class="line">(2,&apos;Bdancs&apos;,10),</span><br><span class="line">(3,&apos;Bbiri&apos;,20);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.将3号员工的last_name修改为“drelxer”</span><br><span class="line">UPDATE my_employees SET last_name=&apos;drelxer&apos; WHERE id = 3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.将所有工资少于900的员工的工资修改为1000</span><br><span class="line">UPDATE my_employees SET salary=1000 WHERE salary&lt;900;</span><br><span class="line"></span><br><span class="line">#7.将userid 为Bbiri的user表和my_employees表的记录全部删除</span><br><span class="line"></span><br><span class="line">DELETE u,e</span><br><span class="line">FROM users u</span><br><span class="line">JOIN my_employees e ON u.`userid`=e.`Userid`</span><br><span class="line">WHERE u.`userid`=&apos;Bbiri&apos;;</span><br><span class="line"></span><br><span class="line">#8.删除所有数据</span><br><span class="line"></span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line">DELETE FROM users;</span><br><span class="line">#9.检查所作的修正</span><br><span class="line"></span><br><span class="line">SELECT * FROM my_employees;</span><br><span class="line">SELECT * FROM users;</span><br><span class="line"></span><br><span class="line">#10.清空表my_employees</span><br><span class="line">TRUNCATE TABLE my_employees;</span><br></pre></td></tr></table></figure>











<h2 id="5、DDL语言学习"><a href="#5、DDL语言学习" class="headerlink" title="5、DDL语言学习"></a>5、DDL语言学习</h2><blockquote>
<p>Data Define Languge —— 数据定义语言</p>
</blockquote>
<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>一、库的管理<br>创建、修改、删除<br>二、表的管理<br>创建、修改、删除</p>
<p>创建： create<br>修改： alter<br>删除： drop</p>
<p>数据库的位置</p>
<p><img alt="1560924243469" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560924243469.png" class="lazyload"></p>
<h3 id="2、库的管理"><a href="#2、库的管理" class="headerlink" title="2、库的管理"></a>2、库的管理</h3><h4 id="1、库的创建"><a href="#1、库的创建" class="headerlink" title="1、库的创建"></a>1、库的创建</h4><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database  [if not exists]库名;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<p>创建库Books</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS books ;</span><br></pre></td></tr></table></figure>



<h4 id="2、库的修改"><a href="#2、库的修改" class="headerlink" title="2、库的修改"></a>2、库的修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME DATABASE books TO 新库名;	#废弃</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<p>更改库的字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE books CHARACTER SET gbk;</span><br></pre></td></tr></table></figure>



<h4 id="3、库的删除"><a href="#3、库的删除" class="headerlink" title="3、库的删除"></a>3、库的删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS books;</span><br></pre></td></tr></table></figure>



<h3 id="3、表的管理"><a href="#3、表的管理" class="headerlink" title="3、表的管理"></a>3、表的管理</h3><h4 id="1、表的创建"><a href="#1、表的创建" class="headerlink" title="1、表的创建"></a>1、表的创建</h4><h5 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">create [if not exist] table 表名(</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	...</span><br><span class="line">	列名 列的类型【(长度) 约束】</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="使用-14"><a href="#使用-14" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：创建表Book</span><br><span class="line"></span><br><span class="line">CREATE TABLE book(</span><br><span class="line">	id INT,#编号</span><br><span class="line">	bName VARCHAR(20),#图书名</span><br><span class="line">	price DOUBLE,#价格</span><br><span class="line">	authorId  INT,#作者编号</span><br><span class="line">	publishDate DATETIME#出版日期</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看表结构</span><br><span class="line">DESC book;</span><br><span class="line"></span><br><span class="line">#案例：创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author(</span><br><span class="line">	id INT,</span><br><span class="line">	au_name VARCHAR(20),</span><br><span class="line">	nation VARCHAR(10)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">#查看表结构</span><br><span class="line">DESC author;</span><br></pre></td></tr></table></figure>





<h4 id="2、表的修改"><a href="#2、表的修改" class="headerlink" title="2、表的修改"></a>2、表的修改</h4><h5 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</span><br></pre></td></tr></table></figure>

<h5 id="使用-15"><a href="#使用-15" class="headerlink" title="使用"></a>使用</h5><p>1、修改列名<code>CHANGE</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE [表名] CHANGE COLUMN [原列名] [新列名] [列名类型];</span><br><span class="line"></span><br><span class="line">ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</span><br></pre></td></tr></table></figure>

<p>2、修改列的类型或约束<code>MODIFY</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</span><br></pre></td></tr></table></figure>
<p>3、添加新列<code>ADD</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE author ADD COLUMN annual DOUBLE;</span><br></pre></td></tr></table></figure>
<p>4、删除列<code>DROP</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book_author DROP COLUMN  annual;</span><br></pre></td></tr></table></figure>

<p>5、修改表名<code>RENAME</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE author RENAME TO book_author;</span><br><span class="line"></span><br><span class="line">DESC book;</span><br></pre></td></tr></table></figure>



<h4 id="3、表的删除"><a href="#3、表的删除" class="headerlink" title="3、表的删除"></a>3、表的删除</h4><h5 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS 表明;</span><br></pre></td></tr></table></figure>



<h5 id="使用-16"><a href="#使用-16" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS book_author;</span><br><span class="line"></span><br><span class="line">#查看所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">#通用的写法：</span><br><span class="line"># 删库名 + 创建库名 </span><br><span class="line">DROP DATABASE IF EXISTS 旧库名;</span><br><span class="line">CREATE DATABASE 新库名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS 旧表名;</span><br><span class="line">CREATE TABLE  表名();</span><br></pre></td></tr></table></figure>



<h4 id="4、表的复制"><a href="#4、表的复制" class="headerlink" title="4、表的复制"></a>4、表的复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO author VALUES</span><br><span class="line">(1,&apos;村上春树&apos;,&apos;日本&apos;),</span><br><span class="line">(2,&apos;莫言&apos;,&apos;中国&apos;),</span><br><span class="line">(3,&apos;冯唐&apos;,&apos;中国&apos;),</span><br><span class="line">(4,&apos;金庸&apos;,&apos;中国&apos;);</span><br></pre></td></tr></table></figure>

<p>1、仅仅复制表的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy LIKE author;</span><br></pre></td></tr></table></figure>
<p>2、复制表的结构+数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT * FROM author;</span><br></pre></td></tr></table></figure>
<p>3、只复制部分数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy3</span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author </span><br><span class="line">WHERE nation=&apos;中国&apos;;</span><br></pre></td></tr></table></figure>

<p>4、仅仅复制某些字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy4 </span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author</span><br><span class="line">WHERE 0;	#让where的条件置为0</span><br></pre></td></tr></table></figure>

<h3 id="4、练习-1"><a href="#4、练习-1" class="headerlink" title="4、练习"></a>4、练习</h3><p><img alt="1560995258950" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560995258950.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	创建表dept1</span><br><span class="line">NAME	NULL?	TYPE</span><br><span class="line">id		INT(7)</span><br><span class="line">NAME		VARCHAR(25)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USE test;</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept1(</span><br><span class="line">	id INT(7),</span><br><span class="line">	NAME VARCHAR(25)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#2.	将表departments中的数据插入新表dept2中</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept2</span><br><span class="line">SELECT department_id,department_name</span><br><span class="line">FROM myemployees.departments;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.	创建表emp5</span><br><span class="line">NAME	NULL?	TYPE</span><br><span class="line">id		INT(7)</span><br><span class="line">First_name	VARCHAR (25)</span><br><span class="line">Last_name	VARCHAR(25)</span><br><span class="line">Dept_id		INT(7)</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp5(</span><br><span class="line">id INT(7),</span><br><span class="line">first_name VARCHAR(25),</span><br><span class="line">last_name VARCHAR(25),</span><br><span class="line">dept_id INT(7)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.	将列Last_name的长度增加到50</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);</span><br><span class="line">#5.	根据表employees创建employees2</span><br><span class="line"></span><br><span class="line">CREATE TABLE employees2 LIKE myemployees.employees;</span><br><span class="line"></span><br><span class="line">#6.	删除表emp5</span><br><span class="line">DROP TABLE IF EXISTS emp5;</span><br><span class="line"></span><br><span class="line">#7.	将表employees2重命名为emp5</span><br><span class="line"></span><br><span class="line">ALTER TABLE employees2 RENAME TO emp5;</span><br><span class="line"></span><br><span class="line">#8.在表dept和emp5中添加新列test_column，并检查所作的操作</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp5 ADD COLUMN test_column INT;</span><br><span class="line">#9.直接删除表emp5中的列 dept_id</span><br><span class="line">DESC emp5;</span><br><span class="line">ALTER TABLE emp5 DROP COLUMN test_column;</span><br></pre></td></tr></table></figure>

<h3 id="5、常见数据类型"><a href="#5、常见数据类型" class="headerlink" title="5、常见数据类型"></a>5、常见数据类型</h3><h4 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>1、数值型<br>    整型<br>    小数：定点数、浮点数<br>2、字符型<br>    较短的文本：char、varchar<br>    较长的文本：text、blob（较长的二进制数据）</p>
<p>日期型：</p>
<h4 id="2、整型"><a href="#2、整型" class="headerlink" title="2、整型"></a>2、整型</h4><h5 id="分类-7"><a href="#分类-7" class="headerlink" title="分类"></a>分类</h5><table>
<thead>
<tr>
<th></th>
<th>tinyint</th>
<th>smallint</th>
<th>mediumint</th>
<th>int/integer</th>
<th>bigint</th>
</tr>
</thead>
<tbody><tr>
<td>字节</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<h5 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h5><p>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值（5.7不插入，亲测）<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p>
<h5 id="使用-17"><a href="#使用-17" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#1.如何设置无符号和有符号</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS tab_int;</span><br><span class="line">CREATE TABLE tab_int(</span><br><span class="line">	t1 INT(7) ZEROFILL,</span><br><span class="line">	t2 INT(7) ZEROFILL </span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC tab_int;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES(-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(-123456,-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(2147483648,4294967296);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES(123,123);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_int;</span><br></pre></td></tr></table></figure>



<h4 id="3、小数"><a href="#3、小数" class="headerlink" title="3、小数"></a>3、小数</h4><h5 id="分类-8"><a href="#分类-8" class="headerlink" title="分类"></a>分类</h5><p>1.浮点型<br>float(M,D)、double(M,D)<br>2.定点型<br>dec(M，D)、decimal(M,D)</p>
<h5 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h5><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p>
<p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p>
<p>③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p>
<h5 id="使用-18"><a href="#使用-18" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE if EXISTS tab_float;</span><br><span class="line">#M：整数部位+小数部位	D：小数部位</span><br><span class="line">CREATE TABLE tab_float(</span><br><span class="line">	f1 FLOAT(5,2),</span><br><span class="line">	f2 DOUBLE(5,2),</span><br><span class="line">	f3 DECIMAL(5,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_float;</span><br><span class="line">INSERT INTO tab_float VALUES(123.4,123.4,123.4);</span><br><span class="line">SELECT * FROM tab_float;</span><br></pre></td></tr></table></figure>

<p><img alt="1560999089824" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560999089824.png" class="lazyload"></p>
<h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
<h4 id="4、字符型"><a href="#4、字符型" class="headerlink" title="4、字符型"></a>4、字符型</h4><p>较短的文本：char、varchar</p>
<p>其他：</p>
<p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p>
<p>较长的文本：text、blob(较大的二进制)</p>
<p>特点：</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char    char(M)</td>
<td>最大的字符数，可以省略，默认为1</td>
<td>固定长度的字符</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td>varchar varchar(M)</td>
<td>最大的字符数，不可以省略</td>
<td>可变长度的字符</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody></table>
<p>若设置char为2时，插入的数据必须&lt;=2个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_float(</span><br><span class="line">	id INT,</span><br><span class="line">	name CHAR(2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into test_float</span><br><span class="line">-- VALUES(1,&apos;123&apos;); 	#插入123会报错</span><br><span class="line">VALUES(1,&apos;12&apos;);	-- 正确</span><br><span class="line"></span><br><span class="line">SELECT * from test_float;</span><br></pre></td></tr></table></figure>

<h4 id="5、Enum枚举类型"><a href="#5、Enum枚举类型" class="headerlink" title="5、Enum枚举类型"></a>5、Enum枚举类型</h4><p>要求插入的值必须属于列表中指定的值之一<br>如果列表成员为1-255，则需要1个字节存储。如果列表成员为255-65535，则需要2个字节存储。最多需要65535个成员！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_char(</span><br><span class="line">	c1 ENUM(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_char VALUES(&apos;a&apos;);</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;b&apos;);</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;c&apos;);</span><br><span class="line">-- INSERT INTO tab_char VALUES(&apos;m&apos;);	-- 插入错误</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;A&apos;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_char;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>结果会将大写变成小写</p>
<p><img alt="1561014495446" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014495446.png" class="lazyload"></p>
<h4 id="6、set类型"><a href="#6、set类型" class="headerlink" title="6、set类型"></a>6、set类型</h4><p>和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_set(</span><br><span class="line">	s1 SET(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_set VALUES(&apos;a&apos;);</span><br><span class="line">INSERT INTO tab_set VALUES(&apos;A,B&apos;);</span><br><span class="line">INSERT INTO tab_set VALUES(&apos;a,c,d&apos;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>结果会将大写变成小写，存储多个数据<br><img alt="1561014348114" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014348114.png" class="lazyload"></p>
<h4 id="7、日期型"><a href="#7、日期型" class="headerlink" title="7、日期型"></a>7、日期型</h4><p><img alt="1561014587100" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014587100.png" class="lazyload"></p>
<p><img alt="1561014664165" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014664165.png" class="lazyload"></p>
<h5 id="分类-9"><a href="#分类-9" class="headerlink" title="分类"></a>分类</h5><p>date只保存日期<br>time 只保存时间<br>year只保存年</p>
<p>datetime保存日期+时间<br>timestamp保存日期+时间</p>
<h5 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h5><table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th>时区等的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000——9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<h5 id="使用-19"><a href="#使用-19" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 TIMESTAMP</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_date VALUES(NOW(),NOW());</span><br><span class="line">SET time_zone=&apos;+9:00&apos;;	-- 修改时区</span><br><span class="line">SELECT * FROM tab_date;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><code>TIMESTAMP</code>收拾去影响</p>
<p><img alt="1561015012652" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561015012652.png" class="lazyload"></p>
<h3 id="6、常见约束"><a href="#6、常见约束" class="headerlink" title="6、常见约束"></a>6、常见约束</h3><h4 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h4><p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p>
<h4 id="分类-10"><a href="#分类-10" class="headerlink" title="分类"></a>分类</h4><p>六大约束</p>
<ul>
<li><p>NOT NULL：非空，用于保证该字段的值不能为空</p>
<p>  比如姓名、学号等</p>
</li>
<li><p>DEFAULT:默认，用于保证该字段有默认值</p>
<p>  比如性别</p>
</li>
<li><p>PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空</p>
<p>  比如学号、员工编号等</p>
</li>
<li><p>UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空</p>
<p>  比如座位号</p>
</li>
<li><p>CHECK:检查约束【mysql中不支持】</p>
<p>  比如年龄、性别</p>
</li>
<li><p>FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p>
<pre><code>在从表添加外键约束，用于引用主表中某列的值</code></pre><p>  比如学生表的专业编号，员工表的部门编号，员工表的工种编号</p>
</li>
</ul>
<p>添加约束的时机：</p>
<ul>
<li>创建表时</li>
<li>修改表时</li>
</ul>
<p>约束的添加分类：</p>
<ul>
<li><p>列级约束：六大约束语法上都支持，但外键约束没有效果</p>
</li>
<li><p>表级约束：除了非空、默认，其他的都支持</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型 列级约束,</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	表级约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>主键和唯一的大对比：</p>
<p>| |保证唯一性|  是否允许为空 |   一个表中可以有多少个  | 是否允许组合|<br>| —- | —- | —- | —- |<br>|主键|    √    |    ×    |    至多有1个      |     √，但不推荐|<br>|唯一|    √    |    √    |    可以有多个     |     √，但不推荐|<br>外键：<br>    1、要求在从表设置外键关系<br>    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>    3、主表的关联列必须是一个key（一般是主键或唯一）<br>    4、插入数据时，先插入主表，再插入从表。删除数据时，先删除从表，再删除主表</p>
<p>可以通过以下两种方式来删除主表的记录<br><strong>方式一：级联删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>
<p><strong>方式二：级联置空</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</span><br></pre></td></tr></table></figure>



<h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><p>修改表时添加或删除约束</p>
<p>1、非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加非空</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 not null;</span><br><span class="line">删除非空</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
<p>2、默认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加默认</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 default 值;</span><br><span class="line">删除默认</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
<p>3、主键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加主键</span><br><span class="line">alter table 表名 add【 constraint 约束名】 primary key(字段名);</span><br><span class="line">删除主键</span><br><span class="line">alter table 表名 drop primary key;</span><br></pre></td></tr></table></figure>
<p>4、唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加唯一</span><br><span class="line">alter table 表名 add【 constraint 约束名】 unique(字段名);</span><br><span class="line">删除唯一</span><br><span class="line">alter table 表名 drop index 索引名;</span><br></pre></td></tr></table></figure>
<p>5、外键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加外键</span><br><span class="line">alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;</span><br><span class="line">删除外键</span><br><span class="line">alter table 表名 drop foreign key 约束名;</span><br></pre></td></tr></table></figure>





<h4 id="使用-20"><a href="#使用-20" class="headerlink" title="使用"></a>使用</h4><h5 id="1、创建表时添加约束"><a href="#1、创建表时添加约束" class="headerlink" title="1、创建表时添加约束"></a>1、创建表时添加约束</h5><h6 id="1、添加列级约束"><a href="#1、添加列级约束" class="headerlink" title="1、添加列级约束"></a>1、添加列级约束</h6><p>直接在字段名和类型后面追加 约束类型即可。</p>
<p>只支持：默认、非空、主键、唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE students;</span><br><span class="line">DROP TABLE stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,#主键</span><br><span class="line">	stuName VARCHAR(20) NOT NULL UNIQUE,#非空</span><br><span class="line">    -- 检查	也可以用in,CHECK(gender in(&apos;男&apos;&apos;女&apos;))</span><br><span class="line">	gender CHAR(1) CHECK(gender=&apos;男&apos; OR gender =&apos;女&apos;),</span><br><span class="line">	seat INT UNIQUE,#唯一</span><br><span class="line">	age INT DEFAULT  18,#默认约束</span><br><span class="line">	majorId INT REFERENCES major(id)#外键</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE major(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	majorName VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<h6 id="2、添加表级约束"><a href="#2、添加表级约束" class="headerlink" title="2、添加表级约束"></a>2、添加表级约束</h6><p>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名) </p>
<p>约束名自己起，不支持非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT,</span><br><span class="line">	</span><br><span class="line">	CONSTRAINT pk PRIMARY KEY(id),#主键</span><br><span class="line">	CONSTRAINT uq UNIQUE(seat),#唯一键</span><br><span class="line">	CONSTRAINT ck CHECK(gender =&apos;男&apos; OR gender  = &apos;女&apos;),#检查</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<p>通用写法：</p>
<p>一般外键用表级约束写，其余的用列级约束写。外键的约束名<code>fk_表名1_表名2</code>，表示foreign key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	sex CHAR(1),</span><br><span class="line">	age INT DEFAULT 18,</span><br><span class="line">	seat INT UNIQUE,</span><br><span class="line">	majorid INT,</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>组合主键：</p>
<p>约束名(列名1，列名2，….)</p>
<h5 id="2、修改表时添加约束"><a href="#2、修改表时添加约束" class="headerlink" title="2、修改表时添加约束"></a>2、修改表时添加约束</h5><p><strong>1、添加列级约束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br></pre></td></tr></table></figure>
<p><strong>2、添加表级约束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br></pre></td></tr></table></figure>

<h6 id="使用-21"><a href="#使用-21" class="headerlink" title="使用"></a>使用</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT</span><br><span class="line">)</span><br><span class="line">DESC stuinfo;</span><br><span class="line">#1.添加非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;</span><br><span class="line">#2.添加默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;</span><br><span class="line">#3.添加主键</span><br><span class="line">#①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line">#②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD PRIMARY KEY(id);</span><br><span class="line"></span><br><span class="line">#4.添加唯一</span><br><span class="line"></span><br><span class="line">#①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</span><br><span class="line">#②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD UNIQUE(seat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.添加外键</span><br><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorId) REFERENCES major(majorid);</span><br></pre></td></tr></table></figure>



<h5 id="3、修改表时删除约束"><a href="#3、修改表时删除约束" class="headerlink" title="3、修改表时删除约束"></a>3、修改表时删除约束</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.删除非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</span><br><span class="line"></span><br><span class="line">#2.删除默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT ;</span><br><span class="line"></span><br><span class="line">#3.删除主键</span><br><span class="line">ALTER TABLE stuinfo DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">#4.删除唯一</span><br><span class="line">ALTER TABLE stuinfo DROP INDEX seat;</span><br><span class="line"></span><br><span class="line">#5.删除外键</span><br><span class="line">ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<h5 id="4、练习-2"><a href="#4、练习-2" class="headerlink" title="4、练习"></a>4、练习</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.向表emp2的id列中添加PRIMARY KEY约束（my_emp_id_pk）</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line">ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);</span><br><span class="line"></span><br><span class="line">#2.	向表dept2的id列中添加PRIMARY KEY约束（my_dept_id_pk）</span><br><span class="line"></span><br><span class="line">#3.	向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。</span><br><span class="line">ALTER TABLE emp2 ADD COLUMN dept_id INT;</span><br><span class="line">ALTER TABLE emp2 ADD CONSTRAINT fk_emp2_dept2 FOREIGN KEY(dept_id) REFERENCES dept2(id);</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th></th>
<th>位置</th>
<th>支持的约束类型</th>
<th>是否可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>所有列的下面</td>
<td>默认和非空不支持，其他支持</td>
<td>可以（主键没有效果）</td>
</tr>
</tbody></table>
<h3 id="7、标识列"><a href="#7、标识列" class="headerlink" title="7、标识列"></a>7、标识列</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>又称为自增长列，可以不用手动的插入值，系统提供默认的序列值</p>
<p><strong>mysql不能设置起始值，可以设置步长</strong></p>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型（INT、float、double）<br>4、标识列可以通过 <code>SET auto_increment_increment=3;</code>设置步长<br>可以通过 手动插入值，设置起始值</p>
<h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><h5 id="1、创建表时设置自增长列"><a href="#1、创建表时设置自增长列" class="headerlink" title="1、创建表时设置自增长列"></a>1、创建表时设置自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表(</span><br><span class="line">	字段名 字段类型 约束 auto_increment</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="2、修改表时设置自增长列"><a href="#2、修改表时设置自增长列" class="headerlink" title="2、修改表时设置自增长列"></a>2、修改表时设置自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束 auto_increment</span><br></pre></td></tr></table></figure>
<h5 id="3、删除自增长列"><a href="#3、删除自增长列" class="headerlink" title="3、删除自增长列"></a>3、删除自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束</span><br></pre></td></tr></table></figure>

<h4 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS tab_identity;</span><br><span class="line">CREATE TABLE tab_identity(</span><br><span class="line">	id INT  ,</span><br><span class="line">	NAME FLOAT UNIQUE AUTO_INCREMENT,</span><br><span class="line">	seat INT </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">TRUNCATE TABLE tab_identity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_identity(id,NAME) VALUES(NULL,&apos;john&apos;);</span><br><span class="line">INSERT INTO tab_identity(NAME) VALUES(&apos;lucy&apos;);</span><br><span class="line">SELECT * FROM tab_identity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &apos;%auto_increment%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET auto_increment_increment=3;	#设置步长</span><br></pre></td></tr></table></figure>













<h2 id="6、TCL语言学习"><a href="#6、TCL语言学习" class="headerlink" title="6、TCL语言学习"></a>6、TCL语言学习</h2><blockquote>
<p>Transaction Control Language —— 事务控制语言</p>
</blockquote>
<h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>​        在mysql中的数据用各种不同的技术存储在文件（或内存）中。通过<code>show engines；</code>来查看mysql支持的存储引擎。</p>
<p>​        在mysql中用的最多的存储引擎有：innodb，myisam,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>
<h4 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h4><p>1、原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>2、一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
<p>3、隔离性（Isolation）<br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>4、持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
<h3 id="2、事务的创建"><a href="#2、事务的创建" class="headerlink" title="2、事务的创建"></a>2、事务的创建</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</li>
</ul>
<p>delete from 表 where id =1;</p>
<ul>
<li>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用</li>
</ul>
<p>手动设置关闭事务<code>set autocommit=0;</code></p>
<p>使用<code>SHOW VARIABLES LIKE &#39;autocommit&#39;;</code>查看语句是否开启事务</p>
<h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤1：开启事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">start transaction;可选的</span><br><span class="line">步骤2：编写事务中的sql语句(select insert update delete)</span><br><span class="line">语句1;</span><br><span class="line">语句2;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">步骤3：结束事务</span><br><span class="line">commit;提交事务</span><br><span class="line">rollback;回滚事务</span><br></pre></td></tr></table></figure>



<h4 id="使用-22"><a href="#使用-22" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;#可以省略</span><br><span class="line">#编写一组事务的语句</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;张无忌&apos;;</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;赵敏&apos;;</span><br><span class="line"></span><br><span class="line">#结束事务	二选一</span><br><span class="line">ROLLBACK;</span><br><span class="line">#commit;</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

<h3 id="3、事务隔离级别"><a href="#3、事务隔离级别" class="headerlink" title="3、事务隔离级别"></a>3、事务隔离级别</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>​        对于同时运行的多个事务, 当这些事务访问<strong>数据库中相同的数据</strong>时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务T1, T2, <strong>T1 读取了已经被T2 更新但还没有被提交的字段</strong>. 之后, 若T2 回滚, T1读取的内容就是临时且无效的.</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后T2 在该表中插入了一些新的行. 之后, 如果T1 再次读取同一个表, 就会多出几行.</li>
</ul>
<p>​        <strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p>
<p>​        <strong>一个事务与其他事务隔离的程度称为隔离级别.</strong> 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.</p>
<h4 id="4-种事务隔离级别"><a href="#4-种事务隔离级别" class="headerlink" title="4 种事务隔离级别"></a>4 种事务隔离级别</h4><p>数据库提供的4 种事务隔离级别</p>
<p><img alt="1561098719029" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561098719029.png" class="lazyload"></p>
<p>​        Oracle 支持的2 种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED<br>​        Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>讲得很好<a href="https://www.bilibili.com/video/av49181542/?p=137" target="_blank" rel="noopener">https://www.bilibili.com/video/av49181542/?p=137</a></p>
<p>每启动一个mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量<code>@@tx_isolation</code>, 表示当前的事务隔离级别.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看当前隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line">设置当前mySQL 连接的隔离级别:</span><br><span class="line">set transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">设置数据库系统的全局的隔离级别:</span><br><span class="line"># set session|global transaction isolation level 隔离级别;</span><br><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>隔离级别，由上往下级别越来越高</p>
<p>x：不能避免    √：避免</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted:读未提交</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>read committed：读已提交</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>repeatable read：可重复读</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>serializable：串行化</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>mysql中默认 第三个隔离级别 repeatable read<br>oracle中默认第二个隔离级别 read committed</p>
<h3 id="4、savepoint"><a href="#4、savepoint" class="headerlink" title="4、savepoint"></a>4、savepoint</h3><p>用来回滚到某个保存点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id=25;</span><br><span class="line">SAVEPOINT a;#设置保存点</span><br><span class="line">DELETE FROM account WHERE id=28;</span><br><span class="line">ROLLBACK TO a;#回滚到保存点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

<h3 id="5、truncate和delete的区别"><a href="#5、truncate和delete的区别" class="headerlink" title="5、truncate和delete的区别"></a>5、truncate和delete的区别</h3><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>回滚之后数据还在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">DELETE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>



<h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>回滚之后数据不在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">TRUNCATE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>







<h2 id="7、视图"><a href="#7、视图" class="headerlink" title="7、视图"></a>7、视图</h2><h3 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h3><p>虚拟表，和普通表一样使用。mysql5.1版本出现的新特性，是通过表动态生成的数据。</p>
<p>比如：舞蹈班和普通班级的对比</p>
<p><strong>案例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询姓张的学生名和专业名</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.`majorid`= m.`id`</span><br><span class="line">WHERE s.`stuname` LIKE &apos;张%&apos;;</span><br><span class="line"></span><br><span class="line">-- ========================================================</span><br><span class="line">CREATE VIEW v1</span><br><span class="line">AS</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.`majorid`= m.`id`;</span><br><span class="line"></span><br><span class="line">-- 方便使用</span><br><span class="line">SELECT * FROM v1 WHERE stuname LIKE &apos;张%&apos;;</span><br></pre></td></tr></table></figure>


<p><strong>应用场景：</strong></p>
<ul>
<li><p>多个地方用到同样的查询结果</p>
</li>
<li><p>该查询结果使用的sql语句较复杂</p>
</li>
</ul>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><h4 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h4 id="使用-23"><a href="#使用-23" class="headerlink" title="使用"></a>使用</h4><p>1、查询姓名中包含a字符的员工名、部门名和工种信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#①创建</span><br><span class="line">CREATE VIEW myv1</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d ON e.department_id  = d.department_id</span><br><span class="line">JOIN jobs j ON j.job_id  = e.job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②使用</span><br><span class="line">SELECT * FROM myv1 WHERE last_name LIKE &apos;%a%&apos;;</span><br></pre></td></tr></table></figure>


<p>2、查询各部门的平均工资级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①创建视图查看每个部门的平均工资</span><br><span class="line">CREATE VIEW myv2</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#②使用</span><br><span class="line">SELECT myv2.`ag`,g.grade_level</span><br><span class="line">FROM myv2</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON myv2.`ag` BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br></pre></td></tr></table></figure>


<p>3、询平均工资最低的部门信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br></pre></td></tr></table></figure>
<p>4、查询平均工资最低的部门名和工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT d.*,m.ag</span><br><span class="line">FROM myv3 m</span><br><span class="line">JOIN departments d</span><br><span class="line">ON m.`department_id`=d.`department_id`;</span><br></pre></td></tr></table></figure>

<h4 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW emp_v1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,salary,email</span><br><span class="line">FROM employees</span><br><span class="line">WHERE phone_number LIKE &apos;011%&apos;;</span><br><span class="line"></span><br><span class="line">#二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW emp_v2</span><br><span class="line">AS</span><br><span class="line">SELECT MAX(salary) mx_dep,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT d.*,m.mx_dep</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN emp_v2 m</span><br><span class="line">ON m.department_id = d.`department_id`;</span><br></pre></td></tr></table></figure>







<h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><h4 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h4><h5 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view  视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h5 id="使用-24"><a href="#使用-24" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM myv3 </span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure>

<h4 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h4><h5 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h5><p>类似表的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as </span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h5 id="使用-25"><a href="#使用-25" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure>



<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图名,视图名,...;</span><br><span class="line">DROP VIEW emp_v1,emp_v2,myv3;</span><br></pre></td></tr></table></figure>

<h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 方式一</span><br><span class="line">DESC myv3;</span><br><span class="line">-- 方式二</span><br><span class="line">SHOW CREATE VIEW myv3;</span><br></pre></td></tr></table></figure>



<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图中数据的增删改，和DML类似</p>
<p>对视图进行增删改，对应的原始表也会进行增删改，数据同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) &quot;annual salary&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">#1.插入</span><br><span class="line">INSERT INTO myv1 VALUES(&apos;张飞&apos;,&apos;zf@qq.com&apos;);</span><br><span class="line"></span><br><span class="line">#2.修改</span><br><span class="line">UPDATE myv1 SET last_name = &apos;张无忌&apos; WHERE last_name=&apos;张飞&apos;;</span><br><span class="line"></span><br><span class="line">#3.删除</span><br><span class="line">DELETE FROM myv1 WHERE last_name = &apos;张无忌&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>具备以下特点的视图不允许更新（基本上全部了）</strong><br>①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT MAX(salary) m,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">UPDATE myv1 SET m=9000 WHERE department_id=10;</span><br></pre></td></tr></table></figure>

<p>②常量视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv2</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT &apos;john&apos; NAME;</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv2;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">UPDATE myv2 SET NAME=&apos;lucy&apos;;</span><br></pre></td></tr></table></figure>




<p>③Select中包含子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资</span><br><span class="line">FROM departments;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line">UPDATE myv3 SET 最高工资=100000;</span><br></pre></td></tr></table></figure>

<p>④join</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv4</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d</span><br><span class="line">ON e.department_id  = d.department_id;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv4;</span><br><span class="line">UPDATE myv4 SET last_name  = &apos;张飞&apos; WHERE last_name=&apos;Whalen&apos;;</span><br><span class="line">INSERT INTO myv4 VALUES(&apos;陈真&apos;,&apos;xxxx&apos;);</span><br></pre></td></tr></table></figure>


<p>⑤from一个不能更新的视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv5</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv5;</span><br><span class="line"></span><br><span class="line">UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;</span><br></pre></td></tr></table></figure>

<p>⑥where子句的子查询引用了from子句中的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv6</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,email,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN(</span><br><span class="line">	SELECT  manager_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE manager_id IS NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv6;</span><br><span class="line">UPDATE myv6 SET salary=10000 WHERE last_name = &apos;k_ing&apos;;</span><br></pre></td></tr></table></figure>





<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><h4 id="视图的好处"><a href="#视图的好处" class="headerlink" title="视图的好处"></a>视图的好处</h4><p>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>
<table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>是否实际占用物理空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>增删改查，只是一般不能增删改</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
<h2 id="8、变量"><a href="#8、变量" class="headerlink" title="8、变量"></a>8、变量</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>系统变量：全局变量、会话变量</p>
<p>自定义变量：用户变量、局部变量</p>
<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>说明：变量由系统定义，不是用户定义，属于服务器层面<br><span style="color:red"><strong>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别</strong></span><br>使用步骤：<br>1、查看所有系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show [global|session] variables;</span><br></pre></td></tr></table></figure>
<p>2、查看满足条件的部分系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show [global|session] variables like &apos;%char%&apos;;</span><br></pre></td></tr></table></figure>
<p>3、查看指定的系统变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@[global|session].系统变量名;</span><br></pre></td></tr></table></figure>
<p>4、为某个系统变量赋值<br>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set [global|session] 系统变量名=值;</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@[global|session].系统变量名=值;</span><br></pre></td></tr></table></figure>

<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">#②查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">#③查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line"></span><br><span class="line">#④为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit=0;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure>



<h4 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h4><p>作用域：针对于当前会话（连接）有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line"></span><br><span class="line">#②查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">#③查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line"></span><br><span class="line">#④为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation=&apos;read-uncommitted&apos;;</span><br><span class="line">SET SESSION tx_isolation=&apos;read-committed&apos;;</span><br></pre></td></tr></table></figure>



<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p>
<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>作用域：针对于当前会话（连接）有效，作用域同于会话变量</p>
<p><strong>应用在任何地方，也就是<code>begin</code> <code>end</code>里面/外面</strong></p>
<p>赋值操作符：<code>=</code>或<code>:=</code></p>
<p>①声明并初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set可以用两种方式</span><br><span class="line">SET @变量名=值;</span><br><span class="line">SET @变量名:=值;</span><br><span class="line"></span><br><span class="line">#select只能用:=</span><br><span class="line">SELECT @变量名:=值;</span><br></pre></td></tr></table></figure>

<p>②赋值（更新变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">	SET @变量名=值;</span><br><span class="line">	SET @变量名:=值;</span><br><span class="line">	SELECT @变量名:=值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO @变量名</span><br><span class="line">	FROM 表;</span><br></pre></td></tr></table></figure>

<p>③使用（查看变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @变量名;</span><br></pre></td></tr></table></figure>

<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、创建name变量赋值并打印</span><br><span class="line">set @name=&apos;john&apos;;</span><br><span class="line">set @name=100;</span><br><span class="line">select @name;</span><br><span class="line"></span><br><span class="line"># 2、创建count变量并将employees的总个数赋给ocunt后打印</span><br><span class="line">set @count=1;</span><br><span class="line">select COUNT(*) into @count</span><br><span class="line">from employees;</span><br><span class="line">SELECT @count;</span><br></pre></td></tr></table></figure>







<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>作用域：仅仅在定义它的begin end块中有效</p>
<p>应用在 begin end中的第一句话</p>
<p>使用步骤：<br>1、声明<br>2、赋值</p>
<p>①声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 类型;</span><br><span class="line">DECLARE 变量名 类型 【DEFAULT 值】;</span><br></pre></td></tr></table></figure>

<p>②赋值（更新变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">	SET 局部变量名=值;</span><br><span class="line">	SET 局部变量名:=值;</span><br><span class="line">	SELECT 局部变量名:=值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO 具备变量名</span><br><span class="line">	FROM 表;</span><br><span class="line">#③使用（查看变量的值）</span><br><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>用户变量和局部变量的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：声明两个变量，求和并打印</span><br><span class="line"></span><br><span class="line">#用户变量</span><br><span class="line">SET @m=1;</span><br><span class="line">SET @n=1;</span><br><span class="line">SET @sum=@m+@n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"></span><br><span class="line">#局部变量	会报错，没有放在begin end中</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 1;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line">SET SUM=m+n;</span><br><span class="line">SELECT SUM;</span><br></pre></td></tr></table></figure>







<h2 id="9、存储过程和函数"><a href="#9、存储过程和函数" class="headerlink" title="9、存储过程和函数"></a>9、存储过程和函数</h2><p>存储过程和函数：类似于java中的方法</p>
<p>好处：<br>1、提高代码的重用性<br>2、简化操作</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<h4 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(参数列表)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	存储过程体（一组合法的SQL语句）</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong><br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)</p>
<p>参数模式：<br>in：该参数可以作为输入，也就是该<strong>参数需要调用方传入值</strong><br>out：该参数可以作为输出，也就是该参数可以作为<strong>返回值</strong><br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p>
<p>2、如果存储过程体仅仅只有一句话，begin end可以省略(类似循环语句一句话省略括号)<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br><code>delimiter 结束标记</code><br>案例：<br><code>delimiter $</code></p>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(实参列表);</span><br></pre></td></tr></table></figure>



<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：drop procedure 存储过程名</span><br></pre></td></tr></table></figure>



<h5 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>





<h4 id="使用-26"><a href="#使用-26" class="headerlink" title="使用"></a>使用</h4><h5 id="1、空参列表"><a href="#1、空参列表" class="headerlink" title="1、空参列表"></a>1、空参列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：插入到admin表中五条记录</span><br><span class="line"></span><br><span class="line">SELECT * FROM admin;</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp1()</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO admin(username,`password`) </span><br><span class="line">	VALUES(&apos;john1&apos;,&apos;0000&apos;),(&apos;lily&apos;,&apos;0000&apos;),(&apos;rose&apos;,&apos;0000&apos;),(&apos;jack&apos;,&apos;0000&apos;),(&apos;tom&apos;,&apos;0000&apos;);</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#调用 navicat不加$</span><br><span class="line">CALL myp1()</span><br></pre></td></tr></table></figure>



<h5 id="2、带in模式参数"><a href="#2、带in模式参数" class="headerlink" title="2、带in模式参数"></a>2、带in模式参数</h5><p><strong>案例1：创建存储过程实现 根据女神名，查询对应的男神信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create PROCEDURE search(in girl_name VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	select b1.* ,b2.boyName</span><br><span class="line">	from beauty b1</span><br><span class="line">	join boys b2</span><br><span class="line">	on b1.boyfriend_id = b2.id</span><br><span class="line">	WHERE b1.`name` = girl_name;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call search(&apos;赵敏&apos;)</span><br></pre></td></tr></table></figure>



<p><strong>案例2 ：创建存储过程实现，用户是否登录成功</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE result INT DEFAULT 0;#声明并初始化</span><br><span class="line">	</span><br><span class="line">	SELECT COUNT(*) INTO result#赋值</span><br><span class="line">	FROM admin</span><br><span class="line">	WHERE admin.username = username</span><br><span class="line">	AND admin.password = PASSWORD;</span><br><span class="line">	</span><br><span class="line">	SELECT IF(result&gt;0,&apos;成功&apos;,&apos;失败&apos;);#使用</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp3(&apos;张飞&apos;,&apos;8888&apos;)</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img alt="1561429038620" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429038620.png" class="lazyload"><br><img alt="1561429053798" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429053798.png" class="lazyload"></p>
<h5 id="3、in-amp-out-模式参数"><a href="#3、in-amp-out-模式参数" class="headerlink" title="3、in &amp; out 模式参数"></a>3、in &amp; out 模式参数</h5><p><strong>案例1：根据输入的女神名，返回对应的男神名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create PROCEDURE search1(in girl_name VARCHAR(20) , out boy_name VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	select b2.boyName into boy_name</span><br><span class="line">	from beauty b1</span><br><span class="line">	join boys b2</span><br><span class="line">	on b1.boyfriend_id = b2.id</span><br><span class="line">	WHERE b1.`name` = girl_name;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call search1(&apos;赵敏&apos;,@boy_name)</span><br><span class="line">select @boy_name</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img alt="1561429397840" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429397840.png" class="lazyload"></p>
<p><strong>案例2：根据输入的女神名，返回对应的男神名和魅力值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT boys.boyname ,boys.usercp INTO boyname,usercp</span><br><span class="line">	FROM boys </span><br><span class="line">	RIGHT JOIN</span><br><span class="line">	beauty b ON b.boyfriend_id = boys.id</span><br><span class="line">	WHERE b.name=beautyName ;</span><br><span class="line">	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp7(&apos;小昭&apos;,@name,@cp)$</span><br></pre></td></tr></table></figure>

<h5 id="4、inout模式参数"><a href="#4、inout模式参数" class="headerlink" title="4、inout模式参数"></a>4、inout模式参数</h5><p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SET a=a*2;</span><br><span class="line">	SET b=b*2;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">SET @m=10$</span><br><span class="line">SET @n=20$</span><br><span class="line">CALL myp8(@m,@n)$</span><br><span class="line">SELECT @m,@n$</span><br></pre></td></tr></table></figure>



<h4 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h4><p>1、创建存储过程实现传入用户名和密码，插入到admin表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO admin(admin.username,PASSWORD)</span><br><span class="line">	VALUES(username,loginpwd);</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>2、创建存储过程实现传入女神编号，返回女神名称和女神电话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">	SELECT b.name ,b.phone INTO NAME,phone</span><br><span class="line">	FROM beauty b</span><br><span class="line">	WHERE b.id = id;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>3、创建存储存储过程或函数实现传入两个女神生日，返回大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT DATEDIFF(birth1,birth2) INTO result;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>4、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT DATE_FORMAT(mydate,&apos;%y年%m月%d日&apos;) INTO strDate;</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro4(NOW(),@str)</span><br><span class="line">SELECT @str</span><br></pre></td></tr></table></figure>


<p>5、创建存储过程或函数实现传入女神名称，返回：女神 and 男神  格式的字符串<br>如 传入 ：小昭<br>返回： 小昭 AND 张无忌</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE test_pro5</span><br><span class="line">CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT CONCAT(beautyName,&apos; and &apos;,IFNULL(boyName,&apos;null&apos;)) INTO str</span><br><span class="line">	FROM boys bo</span><br><span class="line">	RIGHT JOIN beauty b ON b.boyfriend_id = bo.id</span><br><span class="line">	WHERE b.name=beautyName;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	SET str=</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro5(&apos;赵敏&apos;,@str)</span><br><span class="line">SELECT @str</span><br></pre></td></tr></table></figure>

<p><img alt="1561446772615" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561446772615.png" class="lazyload"></p>
<p>6、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE test_pro6</span><br><span class="line">CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT * FROM beauty LIMIT startIndex,size;</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro6(3,5)</span><br></pre></td></tr></table></figure>



<p>7、删除存储过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE p1;</span><br><span class="line">DROP PROCEDURE p2,p3;#× 不支持多个删除</span><br></pre></td></tr></table></figure>


<p>8、查看存储过程的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>





<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<p>区别：</p>
<p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p>
<h4 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">	函数体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型</p>
<p>2.函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议</p>
<p>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记</p>
<h5 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(参数列表)</span><br></pre></td></tr></table></figure>



<h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION myf3;</span><br></pre></td></tr></table></figure>
<p>在mysql的proc表中会有创建的存储过程和函数<br><img alt="1561448603681" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561448603681.png" class="lazyload"></p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION myf3;</span><br></pre></td></tr></table></figure>



<h4 id="使用-27"><a href="#使用-27" class="headerlink" title="使用"></a>使用</h4><p>1、无参返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 案例1：返回公司的员工个数</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf1() <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">DECLARE</span> c <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;<span class="comment">#定义局部变量</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> c<span class="comment">#赋值</span></span><br><span class="line">	<span class="keyword">FROM</span> employees;</span><br><span class="line">	RETURN c;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf1()$</span><br></pre></td></tr></table></figure>



<p>2、有参返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例1：根据部门名，返回该部门的平均工资</span><br><span class="line">delimiter $</span><br><span class="line">CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	SET @sal=0;#定义用户变量 </span><br><span class="line">	SELECT salary INTO @sal   #赋值</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = empName;</span><br><span class="line">	</span><br><span class="line">	RETURN @sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf2(&apos;Kochhar&apos;) $</span><br><span class="line"></span><br><span class="line"># =============================================</span><br><span class="line"></span><br><span class="line">#案例2：根据部门名，返回该部门的平均工资</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE sal DOUBLE ;</span><br><span class="line">	SELECT AVG(salary) INTO sal</span><br><span class="line">	FROM employees e</span><br><span class="line">	JOIN departments d ON e.department_id = d.department_id</span><br><span class="line">	WHERE d.department_name=deptName;</span><br><span class="line">	RETURN sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf3(&apos;IT&apos;)$</span><br></pre></td></tr></table></figure>



<p>3、求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、创建函数，实现传入两个float，返回二者之和</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE SUM FLOAT DEFAULT 0;</span><br><span class="line">	SET SUM=num1+num2;</span><br><span class="line">	RETURN SUM;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT test_fun1(1,2)$</span><br></pre></td></tr></table></figure>









<h2 id="10、流程控制结构"><a href="#10、流程控制结构" class="headerlink" title="10、流程控制结构"></a>10、流程控制结构</h2><h3 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h3><h4 id="1、if结构"><a href="#1、if结构" class="headerlink" title="1、if结构"></a>1、if结构</h4><h5 id="if函数语法"><a href="#if函数语法" class="headerlink" title="if函数语法"></a>if函数语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件,值1，值2)</span><br></pre></td></tr></table></figure>

<p>如果条件成立，则if返回值1，否则返回值2</p>
<p>功能：实现简单的双分支，应用在任何地方</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @num = 0;</span><br><span class="line">SELECT if(@num,&apos;true&apos;,&apos;false&apos;);</span><br></pre></td></tr></table></figure>

<p><img alt="1561519881501" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519881501.png" class="lazyload"></p>
<h5 id="if结构语法"><a href="#if结构语法" class="headerlink" title="if结构语法"></a>if结构语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">....</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br><span class="line">功能：类似于多重if</span><br></pre></td></tr></table></figure>

<p>只能应用在begin end 中</p>
<h5 id="使用-28"><a href="#使用-28" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ch CHAR DEFAULT &apos;A&apos;;</span><br><span class="line">	IF score&gt;90 THEN SET ch=&apos;A&apos;;</span><br><span class="line">	ELSEIF score&gt;80 THEN SET ch=&apos;B&apos;;</span><br><span class="line">	ELSEIF score&gt;60 THEN SET ch=&apos;C&apos;;</span><br><span class="line">	ELSE SET ch=&apos;D&apos;;</span><br><span class="line">	END IF;</span><br><span class="line">	RETURN ch;</span><br><span class="line">END</span><br><span class="line">SELECT test_if(87)</span><br></pre></td></tr></table></figure>

<p><img alt="1561519907951" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519907951.png" class="lazyload"></p>
<h4 id="2、case结构"><a href="#2、case结构" class="headerlink" title="2、case结构"></a>2、case结构</h4><h5 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h5><p>情况1：类似于java中的switch，一般用于实现等值判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 变量|表达式</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end case</span><br></pre></td></tr></table></figure>



<p>情况2：类似于java中的多重if语句，一般用于实现区间判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end case</span><br></pre></td></tr></table></figure>



<h5 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h5><p>1、可以作为表达式，[嵌套在其他语句中使用](# 2、case函数)，可以放在任何地方，<code>BEGIN END</code>中或者<code>BEGIN END</code>的外面</p>
<p>2、可以作为独立的语句去使用，只能放在<code>BEGIN END</code>中</p>
<p>3、<code>ELSE</code>可以省略，如果<code>ELSE</code>省略了，并且所有<code>WHEN</code>条件都不满足，则返回NULL</p>
<h5 id="使用-29"><a href="#使用-29" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：创建函数，实现传入成绩，</span><br><span class="line">#如果成绩&gt;90,返回A，</span><br><span class="line">#如果成绩&gt;80,返回B，</span><br><span class="line">#如果成绩&gt;60,返回C，</span><br><span class="line">#否则返回D</span><br><span class="line"></span><br><span class="line">create PROCEDURE test_case(IN score INT)</span><br><span class="line">BEGIN</span><br><span class="line">	case </span><br><span class="line">	WHEN score&gt;=90 AND score &lt;= 100 THEN SELECT &apos;A&apos;;</span><br><span class="line">	WHEN score &gt;= 80 THEN SELECT &apos;B&apos;;</span><br><span class="line">	WHEN score &gt;= 60 THEN SELECT &apos;C&apos;; </span><br><span class="line">	ELSE SELECT &apos;D&apos;;</span><br><span class="line">	END CASE;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call test_case(59)</span><br></pre></td></tr></table></figure>

<p><img alt="1561519331629" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519331629.png" class="lazyload"></p>
<h3 id="2、循环"><a href="#2、循环" class="headerlink" title="2、循环"></a>2、循环</h3><p>分类：<br>while、loop、repeat</p>
<p>循环控制：</p>
<p>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环</p>
<h4 id="1、while-使用较多"><a href="#1、while-使用较多" class="headerlink" title="1、while(使用较多)"></a>1、while(使用较多)</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[标签:] while 循环条件 do</span><br><span class="line">	循环体;</span><br><span class="line">end while [标签];</span><br></pre></td></tr></table></figure>



<h4 id="2、loop"><a href="#2、loop" class="headerlink" title="2、loop"></a>2、loop</h4><p>无条件死循环</p>
<h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【标签:】loop</span><br><span class="line">	循环体;</span><br><span class="line">end loop 【标签】;</span><br></pre></td></tr></table></figure>

<p>可以用来模拟简单的死循环</p>
<h4 id="3、repeat"><a href="#3、repeat" class="headerlink" title="3、repeat"></a>3、repeat</h4><p>类似java中的do…while…    先执行后判断</p>
<h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【标签：】repeat</span><br><span class="line">	循环体;</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat 【标签】;</span><br></pre></td></tr></table></figure>



<h4 id="使用-30"><a href="#使用-30" class="headerlink" title="使用"></a>使用</h4><p>1、没有添加循环控制语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录</span><br><span class="line"># 分开执行</span><br><span class="line">DROP PROCEDURE pro_while1</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	WHILE i&lt;=insertCount DO</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;Rose&apos;,i),&apos;666&apos;);</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">CALL pro_while1(100)</span><br></pre></td></tr></table></figure>



<p>2、添加leave语句</p>
<p>使用leave必须要对循环起一个别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止</span><br><span class="line">TRUNCATE TABLE admin</span><br><span class="line">DROP PROCEDURE test_while1</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line">		IF i&gt;=20 THEN LEAVE a;</span><br><span class="line">		END IF;</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE a;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure>

<p><img alt="1562207994395" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562207994395.png" class="lazyload"></p>
<p>3、添加iterate语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</span><br><span class="line">TRUNCATE TABLE admin</span><br><span class="line">DROP PROCEDURE test_while1</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		SET i=i+1;</span><br><span class="line">		IF MOD(i,2)!=0 THEN ITERATE a;</span><br><span class="line">		END IF;</span><br><span class="line">		</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line">		</span><br><span class="line">	END WHILE a;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure>



<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>已知表stringcontent，向该表插入指定个数的，随机的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stringcontent;</span><br><span class="line">CREATE TABLE stringcontent(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	content VARCHAR(20)</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line">DELIMITER</span><br><span class="line">CREATE PROCEDURE test_randstr_insert(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	DECLARE str VARCHAR(26) DEFAULT &apos;abcdefghijklmnopqrstuvwxyz&apos;;</span><br><span class="line">	DECLARE startIndex INT;#代表初始索引</span><br><span class="line">	DECLARE len INT;#代表截取的字符长度</span><br><span class="line">	WHILE i&lt;=insertcount DO</span><br><span class="line">		SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26</span><br><span class="line">		SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）</span><br><span class="line">		INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">CALL test_randstr_insert(10)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>医学图像评价指标</title>
    <url>/2019/11/25/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<p>最近写论文需要一些评价指标数据，做个总结，实现python代码</p>
<h1 id="基本评价指标"><a href="#基本评价指标" class="headerlink" title="基本评价指标"></a>基本评价指标</h1><h2 id="FP、FN、TP、TN"><a href="#FP、FN、TP、TN" class="headerlink" title="FP、FN、TP、TN"></a>FP、FN、TP、TN</h2><p><img alt="640?wx_fmt=png" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/p.png" class="lazyload"></p>
<ul>
<li><p>TP：T（预测对了true） P(预测为正样本positive)；真的正值，说明被预测为正样本，预测是真的，即真实值为正样本</p>
</li>
<li><p>TN：T（预测对了true） P(预测为负样本negative)；真的负值，说明被预测为负样本，预测是真的，即真实值为负样本</p>
</li>
<li><p>FP：T（预测错了false）P(预测为正样本positive)；假的正直：说明被预测为正样本，但预测是假的，即真实值为负样本</p>
</li>
<li><p>FN：T（预测错了false）P(预测为负样本negative)；假的负值，说明被预测为负样本，但预测是假的，即真实值为正样</p>
</li>
</ul>
<h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.seterr(divide=<span class="string">'ignore'</span>,invalid=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line">labels=[<span class="string">"dog"</span>, <span class="string">"cat"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_base</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    C2 = confusion_matrix(y_true, y_pred, labels=labels)</span><br><span class="line">    TN, FP, FN, TP = C2.ravel()</span><br><span class="line">    <span class="keyword">return</span> TN, FP, FN, TP</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    y_true = [<span class="string">"dog"</span>, <span class="string">"dog"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>]</span><br><span class="line">    y_pred = [<span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>]</span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br></pre></td></tr></table></figure>





<h2 id="精确率-Precision-、召回率-Recall-、准确率-Accuracy"><a href="#精确率-Precision-、召回率-Recall-、准确率-Accuracy" class="headerlink" title="精确率(Precision)、召回率(Recall)、准确率(Accuracy)"></a>精确率(Precision)、召回率(Recall)、准确率(Accuracy)</h2><p><strong>准确率(Accuracy)</strong>：这三个指标里最直观的就是准确率: 模型判断正确的数据(TP+TN)占总数据的比例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Accuracy: "</span>+str(round((tp+tn)/(tp+fp+fn+tn), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>召回率(Recall)：</strong>针对数据集中的所有正例(TP+FN)而言,模型正确判断出的正例(TP)占数据集中所有正例的比例.FN表示被模型误认为是负例但实际是正例的数据.召回率也叫查全率,以物体检测为例,我们往往把图片中的物体作为正例,此时召回率高代表着模型可以找出图片中更多的物体!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Recall: "</span>+str(round((tp)/(tp+fn), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>精确率(Precision)：</strong>针对模型判断出的所有正例(TP+FP)而言,其中真正例(TP)占的比例.精确率也叫查准率,还是以物体检测为例,精确率高表示模型检测出的物体中大部分确实是物体,只有少量不是物体的对象被当成物体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Precision: "</span>+str(round((tp)/(tp+fp), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<h3 id="python代码-1"><a href="#python代码-1" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    classification accuracy，描述分类器的分类准确率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    ACC = str(round((TP + TN)/(TP + FP + FN + TN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Accuracy: "+ ACC)</span></span><br><span class="line">    <span class="keyword">return</span> ACC</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    敏感度（sensitivity）、查全率（Recall）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Recall = str(round((TP)/(TP+FN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Recall: "+ Recall)</span></span><br><span class="line">    <span class="keyword">return</span> Recall</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    查准率（Precision）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Precision</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Precision = str(round(TP/(TP + FP), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("Precision: "+ Precision)</span></span><br><span class="line">    <span class="keyword">return</span> Precision</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    描述识别出的负例占所有负例的比例，特异度（specificity）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specificity</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    <span class="comment">#Positive predictive value</span></span><br><span class="line">    NPV = str(round(TN/(TN + FP + <span class="number">0.01</span>), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("PPV:" + NPV)</span></span><br><span class="line">    <span class="keyword">return</span> NPV</span><br></pre></td></tr></table></figure>









<h1 id="医学图像分割"><a href="#医学图像分割" class="headerlink" title="医学图像分割"></a>医学图像分割</h1><h2 id="DICE"><a href="#DICE" class="headerlink" title="DICE"></a>DICE</h2><p>DICE（值域为[0,1]）: 使用频率最高。数学定义如下，具体表示两个物体相交的面积占总面积的比值，完美分割该值为1</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612115855632.png" class="lazyload"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    python numpy版 dice损失函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">smooth = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DICE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = np.sum(y_true_f * y_pred_f)</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br></pre></td></tr></table></figure>



<h2 id="VOE"><a href="#VOE" class="headerlink" title="VOE"></a>VOE</h2><p>与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612155245106.png" class="lazyload"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    VOE（volumetric overlap error）</span></span><br><span class="line"><span class="string">    与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VOE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = abs(np.sum(y_true_f) - np.sum(y_pred_f))</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br></pre></td></tr></table></figure>



<h2 id="RVD"><a href="#RVD" class="headerlink" title="RVD"></a>RVD</h2><p>表示两者体积之间的差异</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612160043818.png" class="lazyload"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    RVD（relative volume difference）：表示两者体积之间的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RVD</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    numerator = abs(np.sum(y_pred_f) - np.sum(y_true_f))</span><br><span class="line">    denominator = np.sum(y_true_f)</span><br><span class="line">    <span class="keyword">return</span> numerator / (denominator + smooth)</span><br></pre></td></tr></table></figure>



<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/11/25 15:37</span></span><br><span class="line"><span class="comment"># @Author  : MxRanger</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : eval.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.seterr(divide=<span class="string">'ignore'</span>,invalid=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># labels=["dog", "cat"]</span></span><br><span class="line">labels = [<span class="number">1</span> , <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_base</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    C2 = confusion_matrix(y_true, y_pred, labels=labels)</span><br><span class="line">    <span class="comment">#print(C2)</span></span><br><span class="line">    <span class="comment">#print("-------------")</span></span><br><span class="line">    TN, FP, FN, TP = C2.ravel()</span><br><span class="line">    <span class="keyword">return</span> TN, FP, FN, TP</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    classification accuracy，描述分类器的分类准确率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    ACC = str(round((TP + TN)/(TP + FP + FN + TN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Accuracy: "+ ACC)</span></span><br><span class="line">    <span class="keyword">return</span> ACC</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    敏感度（sensitivity）、查全率（Recall）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Recall = str(round((TP)/(TP+FN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Recall: "+ Recall)</span></span><br><span class="line">    <span class="keyword">return</span> Recall</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    查准率（Precision）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Precision</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Precision = str(round(TP/(TP + FP), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("Precision: "+ Precision)</span></span><br><span class="line">    <span class="keyword">return</span> Precision</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    描述识别出的负例占所有负例的比例，特异度（specificity）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specificity</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    <span class="comment">#Positive predictive value</span></span><br><span class="line">    NPV = str(round(TN/(TN + FP + <span class="number">0.01</span>), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("PPV:" + NPV)</span></span><br><span class="line">    <span class="keyword">return</span> NPV</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    python numpy版 dice损失函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">smooth = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DICE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = np.sum(y_true_f * y_pred_f)</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    VOE（volumetric overlap error）</span></span><br><span class="line"><span class="string">    与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VOE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = abs(np.sum(y_true_f) - np.sum(y_pred_f))</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    RVD（relative volume difference）：表示两者体积之间的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RVD</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    numerator = abs(np.sum(y_pred_f) - np.sum(y_true_f))</span><br><span class="line">    denominator = np.sum(y_true_f)</span><br><span class="line">    <span class="keyword">return</span> numerator / (denominator + smooth)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(mha_path)</span>:</span></span><br><span class="line">    img = sitk.ReadImage(mha_path)</span><br><span class="line">    image = sitk.GetArrayFromImage(img)  <span class="comment"># indexes are z,y,x (notice the ordering)</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># y_true = ["dog", "dog", "dog", "cat", "cat", "cat", "cat"]</span></span><br><span class="line">    <span class="comment"># y_pred = ["cat", "cat", "dog", "cat", "cat", "cat", "cat"]</span></span><br><span class="line">    <span class="comment"># arr = [1,2,0,3,4,5,6]</span></span><br><span class="line">    <span class="comment"># arr[arr == 2] = 7</span></span><br><span class="line">    <span class="comment"># print(arr)</span></span><br><span class="line"></span><br><span class="line">    gt = read(<span class="string">'xxx#gt.mha'</span>)</span><br><span class="line">    pre = read(<span class="string">'xxx.mha'</span>)</span><br><span class="line"></span><br><span class="line">    print(acc(gt.flatten(),pre.flatten()))</span><br><span class="line">    print(DICE(gt,pre))</span><br><span class="line">    print(VOE(gt,pre))</span><br><span class="line">    print(RVD(gt,pre))</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191125174329852" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/image-20191125174329852.png" class="lazyload"></p>
]]></content>
  </entry>
  <entry>
    <title>JAVA多线程、高并发编程</title>
    <url>/2019/11/17/JAVA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="高并发编程一"><a href="#高并发编程一" class="headerlink" title="高并发编程一"></a>高并发编程一</h1><h2 id="1、synchronized关键字"><a href="#1、synchronized关键字" class="headerlink" title="1、synchronized关键字"></a>1、synchronized关键字</h2><h3 id="1-1、对象锁"><a href="#1-1、对象锁" class="headerlink" title="1.1、对象锁"></a>1.1、对象锁</h3><blockquote>
<p>同步代码块，将需要线性安全的某个操作放入到改代码块中，可以避免超卖，破坏对象的原子性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T1</span></span><br><span class="line"><span class="comment">* synchronized关键字</span></span><br><span class="line"><span class="comment">* 对某个对象加锁</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:47</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object(); <span class="comment">// o 是引用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    栈          __________________</span></span><br><span class="line"><span class="comment">     * |        |    |   new Object()   |</span></span><br><span class="line"><span class="comment">     * |        |   /|------------------|</span></span><br><span class="line"><span class="comment">     * |        |  / |                  |</span></span><br><span class="line"><span class="comment">     * |--------| /  |                  |</span></span><br><span class="line"><span class="comment">     * |___o____|/   |__________________|</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123; <span class="comment">//任何线程要执行下面的代码，必须先拿到o的锁</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t1 = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、this对象"><a href="#1-2、this对象" class="headerlink" title="1.2、this对象"></a>1.2、this对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized关键字</span></span><br><span class="line"><span class="comment">     * 对某个对象加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">//任何线程要执行下面的代码，必须先拿到this的锁</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、synchronized修饰函数"><a href="#1-3、synchronized修饰函数" class="headerlink" title="1.3、synchronized修饰函数"></a>1.3、synchronized修饰函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//等同于在方法的代码执行时要synchronized(this)</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、静态方法"><a href="#1-4、静态方法" class="headerlink" title="1.4、静态方法"></a>1.4、静态方法</h3><blockquote>
<p>synchronized 修饰static方法的时候，等同于synchronized(T.class)，</p>
<p>但是不能写synchronized(this)，静态的属性和方法不能new出当前对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//这里等同于synchronized(yxxy.c_004.T.class)</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(T<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">//考虑一下这里写synchronized(this)是否可以？不可以，静态的属性和方法不能new出当前对象</span></span><br><span class="line">            count --;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【5】有无synchronized修饰的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T5;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T5</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分析一下这个程序的输出</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T5</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T5 t = <span class="keyword">new</span> T5();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不加结果如下：</p>
<p><img alt="1552033919404" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552033919404.png" class="lazyload"></p>
<p>加了结果如下：</p>
<p><img alt="1552033984991" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552033984991.png" class="lazyload"></p>
<p><strong>得出结论，有synchronized修饰可以保证count在修改操作的时候保证只有一个线程可以操作，而其他线程必须等待，知道拿到锁才可以进行修改</strong></p>
<h3 id="1-5、synchronized优化"><a href="#1-5、synchronized优化" class="headerlink" title="1.5、synchronized优化"></a>1.5、synchronized优化</h3><blockquote>
<p>同步代码块中的语句越少越好,细粒度锁，提高效率</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">        count ++;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">        <span class="comment">//采用细粒度的锁，可以使线程争用时间变短，从而提高效率</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="【面试1】、同步方法和非同步方法是否可以同时调用？"><a href="#【面试1】、同步方法和非同步方法是否可以同时调用？" class="headerlink" title="【面试1】、同步方法和非同步方法是否可以同时调用？"></a>【面试1】、同步方法和非同步方法是否可以同时调用？</h2><blockquote>
<p>可以调用，两者没有冲突</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T7;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T7</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:57</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同步和非同步方法是否可以同时调用？</span></span><br><span class="line"><span class="comment">* 可以，两者没有冲突</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T7 t = <span class="keyword">new</span> T7();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*new Thread(()-&gt;t.m1(), "t1").start();</span></span><br><span class="line"><span class="comment">        new Thread(()-&gt;t.m2(), "t2").start();*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【面试2】、一个Account类的set、get方法是否会产生脏读"><a href="#【面试2】、一个Account类的set、get方法是否会产生脏读" class="headerlink" title="【面试2】、一个Account类的set、get方法是否会产生脏读?"></a>【面试2】、一个Account类的set、get方法是否会产生脏读?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对业务写方法加锁</span></span><br><span class="line"><span class="comment">* 对业务读方法不加锁</span></span><br><span class="line"><span class="comment">* 容易产生脏读问题（dirtyRead）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 在set的时候可能会出现balance未赋值时刚好另一个在取值，若不加锁，则会以默认值输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T8Account</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">double</span> <span class="title">getBalance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T8Account a = <span class="keyword">new</span> T8Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;a.set(<span class="string">"zhangsan"</span>, <span class="number">100.0</span>)).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552035524226" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035524226.png" class="lazyload"></p>
<p>给set和get加上synchronized后结果如下：</p>
<p><img alt="1552035597466" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035597466.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：在使用set方法存储信息的时候，假设利用sleep来模拟这期间的其他进程get的时候，可能会读出默认值的情况，所以需要给set和get方法加上synchronized关键字</strong></span></p>
</blockquote>
<h2 id="【面试3】、synchronized是否可以重获锁？"><a href="#【面试3】、synchronized是否可以重获锁？" class="headerlink" title="【面试3】、synchronized是否可以重获锁？"></a>【面试3】、synchronized是否可以重获锁？</h2><h3 id="【1】同类中的两个方法"><a href="#【1】同类中的两个方法" class="headerlink" title="【1】同类中的两个方法"></a>【1】同类中的两个方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T9;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T9</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      11:02</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment">* 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current::this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">"m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m2 start"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current::this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m2 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T9 t = <span class="keyword">new</span> T9();</span><br><span class="line">        t.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552035830633" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035830633.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：    一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。也就是说synchronized获得的锁是可重入的。</strong></span></p>
</blockquote>
<h3 id="【2】父子类的情形"><a href="#【2】父子类的情形" class="headerlink" title="【2】父子类的情形"></a>【2】父子类的情形</h3><h5 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T10;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment">* 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment">* 这里是继承中有可能发生的情形，子类调用父类的同步方法</span></span><br><span class="line"><span class="comment">* 子类的同步方法可以调用父类的同步方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this::"</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">        System.out.println(<span class="string">"child m start"</span>);</span><br><span class="line">        <span class="keyword">super</span>.m();</span><br><span class="line">        System.out.println(<span class="string">"child m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TT().m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552036140086" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552036140086.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：在对子类进行创建对象，调用子类函数同时调用父类函数，两边的synchronized对象都是子类对象</strong></span></p>
</blockquote>
<h2 id="4、程序在执行过程中，如果出现异常，锁会被释放"><a href="#4、程序在执行过程中，如果出现异常，锁会被释放" class="headerlink" title="4、程序在执行过程中，如果出现异常，锁会被释放"></a>4、程序在执行过程中，如果出现异常，锁会被释放</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T11;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T11</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      11:06</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 程序在执行过程中，如果出现异常，默认情况锁会被释放</span></span><br><span class="line"><span class="comment">* 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。</span></span><br><span class="line"><span class="comment">* 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，</span></span><br><span class="line"><span class="comment">* 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。</span></span><br><span class="line"><span class="comment">* 因此要非常小心的处理同步业务逻辑中的异常</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">5</span>) &#123;</span><br><span class="line">               <span class="comment">/* try&#123;</span></span><br><span class="line"><span class="comment">                    int i = 1/0; //此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span></span><br><span class="line"><span class="comment">                    System.out.println(i);</span></span><br><span class="line"><span class="comment">                &#125;catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*        Runnable r1 = ()-&gt;&#123;</span></span><br><span class="line"><span class="comment">          t.m();</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="chair" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/chair.gif" class="lazyload"></p>
<p>若将异常放在try…catch中，则锁不会被释放</p>
<p><img alt="chair1" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/chair1.gif" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：线程中出现异常则会释放锁，为保证安全性，将出现异常的代码放在try…catch中，以保证线程的安全。</strong></span></p>
</blockquote>
<h2 id="5、volatile-关键字"><a href="#5、volatile-关键字" class="headerlink" title="5、volatile 关键字"></a>5、volatile 关键字</h2><h3 id="5-1、可见性"><a href="#5-1、可见性" class="headerlink" title="5.1、可见性"></a>5.1、可见性</h3><blockquote>
<pre><code>volatile 关键字，使一个变量在多个线程间可见
A、B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道
使用volatile关键字，会让所有线程都会读到变量的修改值</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>; <span class="comment">//对比一下有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;</span><br><span class="line">            <span class="comment">/* 睡眠了一段时间，cpu会去堆内存中重新获取running的值，就会结束掉。</span></span><br><span class="line"><span class="comment">                若不设置，cpu没空去获取修改后的值</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.MILLISECONDS.sleep(10);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>结论：若不加volatile，则代码会一直运行

在上面的代码中，running是存在于堆内存的t对象中当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行

使用volatile，将会强制所有线程都去堆内存中读取running的值

![1552048554763](/images/java高并发编程/1552048554763.png)

可以阅读这篇文章进行更深入的理解
http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html

volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized

 保证线程之间的内存可见性 能用volatile的时候就不用加锁，无锁同步，synchronized做同步效率低</code></pre></blockquote>
<h3 id="5-2、原子性"><a href="#5-2、原子性" class="headerlink" title="5.2、原子性"></a>5.2、原子性</h3><blockquote>
<pre><code>volatile具备可见性，不具备原子性

synchronized保证可见性和原子性。效率低

volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) count++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o)-&gt;o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o)-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();    <span class="comment">//调用join方法，等待线程o执行完毕</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552048954983" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552048954983.png" class="lazyload"></p>
<blockquote>
<p>由此可见，volatile只保证了可见性，不保证原子性，效率高。</p>
<p>比如A、B线程，A获取到count是100，正准备+1，</p>
<p>B线程此时获取count的时候也是100，也在+1，那么最终的count不是102，应该是101。</p>
<p>volatile可以重复读取，没有保证数据的原子性。</p>
</blockquote>
<p>对以上代码做修改，将需要同步的代码用synchronized修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对比上一个程序，可以用synchronized解决，synchronized可以保证可见性和原子性，volatile只能保证可见性</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552049314896" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552049314896.png" class="lazyload"></p>
<h2 id="6、AtomicXXX类"><a href="#6、AtomicXXX类" class="headerlink" title="6、AtomicXXX类"></a>6、AtomicXXX类</h2><blockquote>
<p>AtomXXX类效率非常高<br>AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="comment">//int count = 0;</span></span><br><span class="line"> </span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            <span class="comment">//if count.get() &lt; 1000     若同时调用AtomXXX类的多个方法，而之间不加锁的话，还是会被打断</span></span><br><span class="line">            <span class="comment">// ++ 不具备原子性    incrementAndGet具备原子性</span></span><br><span class="line">            <span class="comment">//保证线程执行时不会被其他线程打断</span></span><br><span class="line">            count.incrementAndGet(); <span class="comment">//count++</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552049484456" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552049484456.png" class="lazyload"></p>
<blockquote>
<p>结论： ++不保证原子性，AtomXXX类保证原子性</p>
<p>AtomXXX类对象不可使用使用多个方法，方法彼此之间不保证具有原子性</p>
</blockquote>
<h2 id="7、对象锁改变"><a href="#7、对象锁改变" class="headerlink" title="7、对象锁改变"></a>7、对象锁改变</h2><blockquote>
<p>锁定某对象o，如果o的属性发生改变，不影响锁的使用。但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">//启动第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建第二个线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t::m, <span class="string">"t2"</span>);</span><br><span class="line"> </span><br><span class="line">        t.o = <span class="keyword">new</span> Object(); <span class="comment">//锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object.gif" class="lazyload"></p>
<h2 id="8、不要以字符串常量作为锁定对象"><a href="#8、不要以字符串常量作为锁定对象" class="headerlink" title="8、不要以字符串常量作为锁定对象"></a>8、不要以字符串常量作为锁定对象</h2><blockquote>
<p>不要以字符串常量作为锁定对象<br>在下面的例子中，m1和m2其实锁定的是同一个对象<br>这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，<br>但是你读不到源码，所以你在自己的代码中也锁定了”Hello”,这时候就有可能发生非常诡异的死锁阻塞，<br>因为你的程序和你用到的类库不经意间使用了同一把锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    String s2 = <span class="string">"Hello"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="【面试9】"><a href="#【面试9】" class="headerlink" title="【面试9】"></a>【面试9】</h2><blockquote>
<p>题目：<br> 实现一个容器，提供两个方法，add，size<br> 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</p>
</blockquote>
<h3 id="解法一：使用volatile"><a href="#解法一：使用volatile" class="headerlink" title="解法一：使用volatile"></a>解法一：使用volatile</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer2 c = <span class="keyword">new</span> MyContainer2();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red"><strong>结论：给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu</strong></span></p>
</blockquote>
<h3 id="解法二：使用wait-、notify"><a href="#解法二：使用wait-、notify" class="headerlink" title="解法二：使用wait()、notify()"></a>解法二：使用wait()、notify()</h3><blockquote>
<p>需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以<br>这里使用wait和notify做到，wait会释放锁，而notify不会释放锁,所以若想t1执行，则必须再次wait()让t2释放锁才行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer4</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer4 c = <span class="keyword">new</span> MyContainer4();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">                <span class="keyword">if</span>(c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">                <span class="comment">//通知t1继续执行</span></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                    c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        <span class="comment">//释放锁，让t2得以执行</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object1" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object1.gif" class="lazyload"></p>
<h3 id="解法三：使用CountDownLatch"><a href="#解法三：使用CountDownLatch" class="headerlink" title="解法三：使用CountDownLatch"></a>解法三：使用CountDownLatch</h3><blockquote>
<p>使用Latch（门闩）替代wait notify来进行通知<br>好处是通信方式简单，同时也可以指定等待时间<br>使用await和countdown方法替代wait和notify<br>CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行<br>当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了<br>这时应该考虑countdownlatch/cyclicbarrier/semaphore</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer5</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer5 c = <span class="keyword">new</span> MyContainer5();</span><br><span class="line"> </span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">            <span class="keyword">if</span> (c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"size为5"</span>);</span><br><span class="line">                    <span class="comment">//也可以指定等待时间</span></span><br><span class="line">                    <span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打开门闩，让t2得以执行</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object12" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object12.gif" class="lazyload"></p>
<h1 id="java多线程、高并发编程二"><a href="#java多线程、高并发编程二" class="headerlink" title="java多线程、高并发编程二"></a>java多线程、高并发编程二</h1><blockquote>
<h3 id="java多线程三个主要部分"><a href="#java多线程三个主要部分" class="headerlink" title="java多线程三个主要部分"></a>java多线程三个主要部分</h3><ul>
<li>synchronizer</li>
<li>同步容器</li>
<li>ThreadPool、executor</li>
</ul>
</blockquote>
<h2 id="1、ReentrantLock关键字"><a href="#1、ReentrantLock关键字" class="headerlink" title="1、ReentrantLock关键字"></a>1、ReentrantLock关键字</h2><h3 id="1、手动锁"><a href="#1、手动锁" class="headerlink" title="1、手动锁"></a>1、手动锁</h3><blockquote>
<p>使用reentrantlock可以完成同样的功能</p>
<ul>
<li>需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</li>
<li>使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</li>
</ul>
<p><span style="color:red"><strong>ReentrantLock是手动锁，自己创建自己释放</strong></span></p>
<p><span style="color:red"><strong>synchronized是自动锁，{}范围就行</strong></span></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//synchronized(this)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"m2 ..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock2 rl = <span class="keyword">new</span> ReentrantLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552119906562" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552119906562.png" class="lazyload"></p>
<h3 id="2、尝试锁定"><a href="#2、尝试锁定" class="headerlink" title="2、尝试锁定"></a>2、尝试锁定</h3><blockquote>
<pre><code>使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待

根据tryLock的返回值来判定是否锁定  lock.lock()

可以指定tryLock的时间  lock.tryLock(5, TimeUnit.SECONDS)</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行</span></span><br><span class="line"><span class="comment">     * 可以根据tryLock的返回值来判定是否锁定</span></span><br><span class="line"><span class="comment">     * 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean locked = lock.tryLock();</span></span><br><span class="line"><span class="comment">        System.out.println("m2 ..." + locked);</span></span><br><span class="line"><span class="comment">        if(locked) lock.unlock();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">"m2 ..."</span> + locked);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked) lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock3 rl = <span class="keyword">new</span> ReentrantLock3();</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、打断线程"><a href="#3、打断线程" class="headerlink" title="3、打断线程"></a>3、打断线程</h3><blockquote>
<p>使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，在一个线程等待锁的过程中，可以被打断。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T20;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ReentrantLock1</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      22:49</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* reentrantlock用于替代synchronized</span></span><br><span class="line"><span class="comment">* 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span></span><br><span class="line"><span class="comment">* 这里是复习synchronized最原始的语义</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用reentrantlock可以完成同样的功能</span></span><br><span class="line"><span class="comment">* 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span></span><br><span class="line"><span class="comment">* 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，</span></span><br><span class="line"><span class="comment">* 在一个线程等待锁的过程中，可以被打断</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//lock.lock();</span></span><br><span class="line">                System.out.println(<span class="string">"----------3"</span>);</span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">//可以对interrupt()方法做出响应</span></span><br><span class="line">                System.out.println(<span class="string">"----------4"</span>);</span><br><span class="line">                System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="string">"t2 end"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> locked = ((ReentrantLock) lock).isLocked();<span class="comment">//查询此锁是否由任何线程持有</span></span><br><span class="line">                System.out.println(<span class="string">"locked::"</span>+locked);</span><br><span class="line">                <span class="keyword">if</span> (locked != <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//不能释放别人打开的锁，否则报错Exception in thread "Thread-1" java.lang.IllegalMonitorStateException</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------1"</span>);</span><br><span class="line">        t2.interrupt(); <span class="comment">//打断线程2的等待</span></span><br><span class="line">        System.out.println(<span class="string">"-----------2"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552120908663" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552120908663.png" class="lazyload"></p>
<p>程序执行流程如下：</p>
<p><img alt="1552121643790" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552121643790.png" class="lazyload"></p>
<h3 id="4、公平锁"><a href="#4、公平锁" class="headerlink" title="4、公平锁"></a>4、公平锁</h3><blockquote>
<p>每一个线程都能平等分配到lock，只需在创建对象带入参数true即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//参数为true表示为公平锁，请对比输出结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock5 rl=<span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        Thread th1=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th2=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th3=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th4=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">        th4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>每个线程都能平等有序的分配到锁</p>
<p><img alt="1552121776463" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552121776463.png" class="lazyload"></p>
<h2 id="2、面试题"><a href="#2、面试题" class="headerlink" title="2、面试题"></a>2、面试题</h2><blockquote>
<p>面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</p>
<p>假设：生产者2个，每个生产25件。消费者10个，每个消费5件</p>
</blockquote>
<h3 id="解法一：使用synchronized、wait、notify"><a href="#解法一：使用synchronized、wait、notify" class="headerlink" title="解法一：使用synchronized、wait、notify"></a>解法一：使用synchronized、wait、notify</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T21;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/9</span></span><br><span class="line"><span class="comment"> * Time      21:34</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">10</span>;    <span class="comment">//限制容器大小10</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(list.size() == NUM)&#123;</span><br><span class="line">            System.out.println(<span class="string">"容器已满..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"正在存 ..."</span>+obj);</span><br><span class="line">        list.add(obj);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();<span class="comment">//通知所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"容器空,等待中..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T first = list.removeFirst();</span><br><span class="line">        System.out.println(<span class="string">"正在取..."</span> + first);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();<span class="comment">//通知所有等待线程</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test&lt;String&gt; test = <span class="keyword">new</span> Test&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;<span class="comment">//消费者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+test.get());</span><br><span class="line">            &#125;,<span class="string">"consumer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;<span class="comment">//生产者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++)</span><br><span class="line">                    test.put(Thread.currentThread().getName()+<span class="string">" "</span>+j);</span><br><span class="line">            &#125;,<span class="string">"producer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object123" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object123-1552145403929.gif" class="lazyload"></p>
<p>程序原理图如下：</p>
<h3 id="解法二：使用Lock、Condition"><a href="#解法二：使用Lock、Condition" class="headerlink" title="解法二：使用Lock、Condition"></a>解法二：使用Lock、Condition</h3><blockquote>
<p>使用Lock和Condition来实现<br>对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size() == MAX) &#123; <span class="comment">//想想为什么用while而不是用if？</span></span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            lists.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll(); <span class="comment">//通知消费者线程进行消费</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = lists.removeFirst();</span><br><span class="line">            count --;</span><br><span class="line">            producer.signalAll(); <span class="comment">//通知生产者进行生产</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer2&lt;String&gt; c = <span class="keyword">new</span> MyContainer2&lt;&gt;();</span><br><span class="line">        <span class="comment">//启动消费者线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) System.out.println(c.get());</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//启动生产者线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">            &#125;, <span class="string">"p"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、ThreadLocal关键字"><a href="#3、ThreadLocal关键字" class="headerlink" title="3、ThreadLocal关键字"></a>3、ThreadLocal关键字</h2><blockquote>
<p>ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
</blockquote>
<p>抛砖引玉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T22;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ThreadLocal1</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocal线程局部变量</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 马士兵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(p.name);</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            p.name = <span class="string">"lisi"</span>;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552181901880" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552181901880.png" class="lazyload"></p>
<blockquote>
<p>程序执行过程：</p>
<p>两个线程同时启动，第一个线程先睡2秒，第二个线程睡1秒后将name改掉后第一个线程输出lisi</p>
</blockquote>
<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><blockquote>
<p>ThreadLocal 用来提供线程的局部变量</p>
<p><span style="color:red"><strong>当前线程存的变量只能在当前线程中使用，其他线程无法使用</strong></span></p>
<p><span style="color:red"><strong>使用ThreadLocal的数据不用上锁</strong></span></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T22;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ThreadLocal2</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocal线程局部变量</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ThreadLocal是使用空间换时间，synchronized是使用时间换空间</span></span><br><span class="line"><span class="comment">* 比如在hibernate中session就存在与ThreadLocal中，避免synchronized的使用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 运行下面的程序，理解ThreadLocal</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 马士兵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile static Person p = new Person();</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Person&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(tl.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            tl.set(<span class="keyword">new</span> Person());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="1552182492710" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552182492710.png" class="lazyload"></p>
<blockquote>
<p>闲谈：</p>
<p>数据库的高并发的处理：</p>
<p>加索引、分库、分表、读写分离、主从结构</p>
</blockquote>
<h2 id="4、Singleton-单例模式"><a href="#4、Singleton-单例模式" class="headerlink" title="4、Singleton 单例模式"></a>4、Singleton 单例模式</h2><blockquote>
<p><strong>单例模式就是说系统中对于某类的只能有一个对象，不可能出来第二个</strong></p>
</blockquote>
<h3 id="1、实例一（不使用同步锁）"><a href="#1、实例一（不使用同步锁）" class="headerlink" title="1、实例一（不使用同步锁）"></a>1、实例一（不使用同步锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sin=<span class="keyword">new</span> Singleton();    <span class="comment">///直接初始化一个实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;    <span class="comment">///private类型的构造函数，保证其他类对象不能直接new一个该对象的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSin</span><span class="params">()</span></span>&#123;    <span class="comment">///该类唯一的一个public方法  </span></span><br><span class="line">        <span class="keyword">return</span> sin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中的一个缺点是该类加载的时候就会直接new 一个静态对象出来，当系统中这样的类较多时，会使得启动速度变慢 。现在流行的设计都是讲<strong>“延迟加载”</strong>，我们可以在第一次使用的时候才初始化第一个该类对象。所以这种适合在小系统。</p>
</blockquote>
<h3 id="2、实例二（使用同步锁）"><a href="#2、实例二（使用同步锁）" class="headerlink" title="2、实例二（使用同步锁）"></a>2、实例二（使用同步锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>)   </span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、实例三（小粒度双重同步锁）"><a href="#3、实例三（小粒度双重同步锁）" class="headerlink" title="3、实例三（小粒度双重同步锁）"></a>3、实例三（小粒度双重同步锁）</h3><blockquote>
<p>上述代码中的一次锁住了一个方法， 这个粒度有点大 ，改进就是只锁住其中的new语句就OK。就是所谓的“双重锁”机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                   instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、内部类方式："><a href="#4、内部类方式：" class="headerlink" title="4、内部类方式："></a>4、内部类方式：</h3><blockquote>
<p> 既不用加锁，也能实现懒加载</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"single"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">200</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Singleton.getSingle());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Arrays.asList(ths).forEach(o-&gt;o.start());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、面试题-买票"><a href="#5、面试题-买票" class="headerlink" title="5、面试题 买票"></a>5、面试题 买票</h2><blockquote>
<p>有N张火车票，每张票都有一个编号<br>同时有10个窗口对外售票<br>请写一个模拟程序</p>
</blockquote>
<h3 id="程序一："><a href="#程序一：" class="headerlink" title="程序一："></a>程序一：</h3><blockquote>
<p>出现超卖的情况</p>
<p>list的方法不具备原子性操作，会出现只剩一个的时候多个线程同时remove导致下面的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) tickets.add(<span class="string">"票编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552194906999" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552194906999.png" class="lazyload"></p>
<h3 id="程序二：使用Vector"><a href="#程序二：使用Vector" class="headerlink" title="程序二：使用Vector"></a>程序二：使用Vector</h3><blockquote>
<p>以下代码在while中加入睡眠10秒后依然会出现上面的问题</p>
<p>原因：</p>
<p>Vector的方法虽然具备原子操作，但是同时使用两个方法不能保证原子操作，size()的原子操作范围只在判断处，remove()的原子操作在后面，判断操作和修改操作分离了，不在同一个原子操作中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Vector&lt;String&gt; tickets = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：<br>就算操作A和B都是同步的，但A和B组成的复合操作也未必是同步的，仍然需要自己进行同步<br>就像这个程序，判断size和进行remove必须是一整个的原子操作</strong></p>
</blockquote>
<h3 id="程序三：使用synchronized"><a href="#程序三：使用synchronized" class="headerlink" title="程序三：使用synchronized"></a>程序三：使用synchronized</h3><blockquote>
<p>下面程序不会出现问题，synchronized保证了tickets操作时的原子性，但是synchronized的效率很低。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(tickets) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(tickets.size() &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="程序四：使用ConcurrentLinkedQueue"><a href="#程序四：使用ConcurrentLinkedQueue" class="headerlink" title="程序四：使用ConcurrentLinkedQueue"></a>程序四：使用ConcurrentLinkedQueue</h3><blockquote>
<p>程序正常运行，不会出错。</p>
<p>ConcurrentLinkedQueue 的底层使用的是CAS算法，而非synchronized，效率高。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Queue&lt;String&gt; tickets = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    String s = tickets.poll();</span><br><span class="line">                    <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> System.out.println(<span class="string">"销售了--"</span> + s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、Map、Set"><a href="#6、Map、Set" class="headerlink" title="6、Map、Set"></a>6、Map、Set</h2><blockquote>
<p>对于map、set<br>不使用多线程（不加锁）：HashMap、TreeMap、LinkedHashMap</p>
<p>并发量小（加锁）：Hashtable、Collections.sychronizedXXX  （不怎么用，将不加锁的map转成上锁的map）</p>
<p>并发量大：ConcurrentHashMap  ConcurrentSkipListMap</p>
</blockquote>
<h3 id="1、ConcurrentMap关键字"><a href="#1、ConcurrentMap关键字" class="headerlink" title="1、ConcurrentMap关键字"></a>1、ConcurrentMap关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* http://blog.csdn.net/sunxianghuang/article/details/52221913</span></span><br><span class="line"><span class="comment">* http://www.educity.cn/java/498061.html</span></span><br><span class="line"><span class="comment">* 阅读concurrentskiplistmap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ConcurrentMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();    //262ms 大锁分成小锁</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(); <span class="comment">//高并发并且排序  340ms</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();    //370ms</span></span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //Collections.synchronizedXXX</span></span><br><span class="line">        <span class="comment">//TreeMap</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(ths.length);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) map.put(<span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>), <span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7、队列"><a href="#7、队列" class="headerlink" title="7、队列"></a>7、队列</h2><blockquote>
<p>不需要同步队列：ArrayList、LinkedList</p>
<p>并发量比较低：Collections.synchronizedXXX</p>
<p>写少读多（没有脏读，不需要锁）：CopyOnWriteList</p>
<p>并发量高：Queue<br> [1]高并发加锁队列<br> CocurrentLinkedQueue //concurrentArrayQueue<br> [2]阻塞式队列<br> BlockingQueue<br>     LinkedBQ<br>     ArrayBQ<br>     TransferQueue<br>     SynchronusQueue<br> DelayQueue——执行定时任务</p>
</blockquote>
<h3 id="1、CopyOnWriteArrayList关键字"><a href="#1、CopyOnWriteArrayList关键字" class="headerlink" title="1、CopyOnWriteArrayList关键字"></a>1、CopyOnWriteArrayList关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 写时复制容器 copy on write</span></span><br><span class="line"><span class="comment">* 多线程环境下，写时效率低，读时效率高</span></span><br><span class="line"><span class="comment">* 适合写少读多的环境</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; lists =</span><br><span class="line">                <span class="comment">//new ArrayList&lt;&gt;(); //这个会出并发问题！</span></span><br><span class="line">                <span class="comment">//new Vector();</span></span><br><span class="line">                <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) lists.add(<span class="string">"a"</span> + r.nextInt(<span class="number">10000</span>));</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        runAndComputeTime(ths);</span><br><span class="line"> </span><br><span class="line">        System.out.println(lists.size());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAndComputeTime</span><span class="params">(Thread[] ths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();<span class="comment">//Waits for this thread to die.</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(s2 - s1);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Collections-synchronizedListXXX"><a href="#2、Collections-synchronizedListXXX" class="headerlink" title="2、Collections.synchronizedListXXX"></a>2、Collections.synchronizedListXXX</h3><blockquote>
<p>给list加锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SynchronizedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//给strs加锁，所有方法都上了锁</span></span><br><span class="line">        List&lt;String&gt; strsSync = Collections.synchronizedList(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、ConcurrentLinkedQueue-关键字"><a href="#3、ConcurrentLinkedQueue-关键字" class="headerlink" title="3、ConcurrentLinkedQueue 关键字"></a>3、ConcurrentLinkedQueue 关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ConcurrentQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; strs = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            strs.offer(<span class="string">"a"</span> + i);  <span class="comment">//add 若满了，add会报异常，offer会返回false</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs);</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.poll());<span class="comment">//拿头出来并删除</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.peek());<span class="comment">//拿头出来不删除</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//双端队列Deque</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4、LinkedBlockingQueue关键字"><a href="#4、LinkedBlockingQueue关键字" class="headerlink" title="4、LinkedBlockingQueue关键字"></a>4、LinkedBlockingQueue关键字</h3><blockquote>
<p>生产一个，消费一个，不论空的还是满的都会在等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();<span class="comment">//如果不指定容量，默认为Integer.MAX_VALUE 无界队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个生产者，生产100个</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"生产 -"</span>+i);</span><br><span class="line">                    strs.put(<span class="string">"a"</span> + i); <span class="comment">//如果满了，就会等待</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"p1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//5个消费者进行消费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" take -"</span> + strs.take()); <span class="comment">//如果空了，就会等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552303987293" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552303987293.png" class="lazyload"></p>
<h3 id="5、ArrayBlockingQueue关键字"><a href="#5、ArrayBlockingQueue关键字" class="headerlink" title="5、ArrayBlockingQueue关键字"></a>5、ArrayBlockingQueue关键字</h3><blockquote>
<p>有序队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);<span class="comment">//有界队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            strs.put(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        strs.put(<span class="string">"aaa"</span>); <span class="comment">//满了就会等待，程序阻塞</span></span><br><span class="line">        <span class="comment">//strs.add("aaa");</span></span><br><span class="line">        <span class="comment">//strs.offer("aaa");//add 若满了，add会报异常，offer会返回false</span></span><br><span class="line">        <span class="comment">//strs.offer("aaa", 1, TimeUnit.SECONDS);//按时间段加值，若加不进去就不加</span></span><br><span class="line"> </span><br><span class="line">        System.out.println(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、DelayQueue-关键字"><a href="#6、DelayQueue-关键字" class="headerlink" title="6、DelayQueue 关键字"></a>6、DelayQueue 关键字</h3><blockquote>
<p>DelayQueue 常用于执行定时任务，且队列中的对象必须实现Delayed的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();<span class="comment">//无界队列，但是消费的时候需要在一定固定时间后才能拿出来</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> runningTime;</span><br><span class="line"> </span><br><span class="line">        MyTask(<span class="keyword">long</span> rt) &#123;</span><br><span class="line">            <span class="keyword">this</span>.runningTime = rt;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还剩多长时间才能拿出</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span> + runningTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        MyTask t1 = <span class="keyword">new</span> MyTask(now + <span class="number">1000</span>);</span><br><span class="line">        MyTask t2 = <span class="keyword">new</span> MyTask(now + <span class="number">2000</span>);</span><br><span class="line">        MyTask t3 = <span class="keyword">new</span> MyTask(now + <span class="number">1500</span>);</span><br><span class="line">        MyTask t4 = <span class="keyword">new</span> MyTask(now + <span class="number">2500</span>);</span><br><span class="line">        MyTask t5 = <span class="keyword">new</span> MyTask(now + <span class="number">500</span>);</span><br><span class="line"> </span><br><span class="line">        tasks.put(t1);</span><br><span class="line">        tasks.put(t2);</span><br><span class="line">        tasks.put(t3);</span><br><span class="line">        tasks.put(t4);</span><br><span class="line">        tasks.put(t5);</span><br><span class="line"> </span><br><span class="line">        System.out.println(tasks);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(tasks.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、SynchronousQueue-关键字"><a href="#7、SynchronousQueue-关键字" class="headerlink" title="7、SynchronousQueue 关键字"></a>7、SynchronousQueue 关键字</h3><blockquote>
<p>不进入队列，当生产者生产出来的时候，必须要有消费者进行消费</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SynchronusQueue</span> </span>&#123;<span class="comment">//容量为0，有东西来消费者必须要消费掉</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(strs.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        strs.put(<span class="string">"aaa"</span>); <span class="comment">//阻塞等待消费者消费</span></span><br><span class="line">        <span class="comment">//strs.add("aaa");</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="案例：依次打印ABABABAB…"><a href="#案例：依次打印ABABABAB…" class="headerlink" title="案例：依次打印ABABABAB…."></a>案例：依次打印ABABABAB….</h2><h3 id="解法一：使用wait-notify"><a href="#解法一：使用wait-notify" class="headerlink" title="解法一：使用wait()  notify()"></a>解法一：使用wait()  notify()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T25.printAB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/10</span></span><br><span class="line"><span class="comment"> * Time      22:21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.print(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.print(<span class="string">"B"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    object.notify();<span class="comment">//先通知</span></span><br><span class="line">                    object.wait();<span class="comment">//后释放</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.A();</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.B();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="AB" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AB.gif" class="lazyload"></p>
<h3 id="解法二：使用ReentrantLock"><a href="#解法二：使用ReentrantLock" class="headerlink" title="解法二：使用ReentrantLock"></a>解法二：使用ReentrantLock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T25.printAB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test2</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/10</span></span><br><span class="line"><span class="comment"> * Time      23:12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition ca = lock.newCondition();</span><br><span class="line">    Condition cb = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            System.out.print(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                ca.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cb.signalAll();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            System.out.print(<span class="string">"B"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                ca.signalAll();</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test2.A();</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test2.B();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="java多线程、高并发编程三"><a href="#java多线程、高并发编程三" class="headerlink" title="java多线程、高并发编程三"></a>java多线程、高并发编程三</h1><h2 id="1、线程池须知的一些接口和类"><a href="#1、线程池须知的一些接口和类" class="headerlink" title="1、线程池须知的一些接口和类"></a>1、线程池须知的一些接口和类</h2><h3 id="1、Executor-关键字"><a href="#1、Executor-关键字" class="headerlink" title="1、Executor 关键字"></a>1、Executor 关键字</h3><blockquote>
<p>调用executor的execute方法会执行Runnable的run方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 认识Executor   执行任务的接口，只有一个方法execute</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T01_MyExecutor().execute(()-&gt;System.out.println(<span class="string">"hello executor"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Thread(command).run();</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、ExecutorService-关键字"><a href="#2、ExecutorService-关键字" class="headerlink" title="2、ExecutorService 关键字"></a>2、ExecutorService 关键字</h3><blockquote>
<p>对Executor的拓展接口，其中的submit方法带有返回值</p>
</blockquote>
<p><img alt="1552379303479" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552379303479.png" class="lazyload"></p>
<h3 id="3、Callable-关键字"><a href="#3、Callable-关键字" class="headerlink" title="3、Callable 关键字"></a>3、Callable 关键字</h3><blockquote>
<p>Callable类似于Runnable</p>
<p>Runnable的run方法没有返回值，Callable的call方法有返回值</p>
</blockquote>
<p><img alt="1552379414728" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552379414728.png" class="lazyload"></p>
<h3 id="4、Executors-、Executor"><a href="#4、Executors-、Executor" class="headerlink" title="4、Executors 、Executor"></a>4、Executors 、Executor</h3><blockquote>
<p>Executor用来执行提交的对象Runnable任务</p>
<p>Executors用来调度何种线程池</p>
</blockquote>
<h2 id="2、Executors-线程池"><a href="#2、Executors-线程池" class="headerlink" title="2、Executors 线程池"></a>2、Executors 线程池</h2><h3 id="1、newFixedThreadPool"><a href="#1、newFixedThreadPool" class="headerlink" title="1、newFixedThreadPool"></a>1、newFixedThreadPool</h3><table>
<thead>
<tr>
<th>newFixedThreadPool(int nThreads)</th>
</tr>
</thead>
<tbody><tr>
<td>创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。</td>
</tr>
</tbody></table>
<p>static ExecutorService newFixedThreadPool(int nThreads)</p>
<blockquote>
<p><img alt="1552380480772" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552380480772.png" class="lazyload"></p>
<p>创建一个线程池，传入固定的线程数</p>
<p>将线程放入LinkedBlockingQueue队列中</p>
</blockquote>
<p><strong>下述代码中：</strong></p>
<pre><code>使用Executor的子接口ExecutorService来创建5个固定线程的线程池，调用execute方法便是执行了Runnable的run方法，执行了睡500毫秒打印当前线程名的任务</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//execute执行无返回值 submit执行有/无返回值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        service.shutdown();<span class="comment">//等所有任务执行完才能关闭</span></span><br><span class="line">        System.out.println(service.isTerminated());<span class="comment">//查看是否所有任务执行完</span></span><br><span class="line">        System.out.println(service.isShutdown());<span class="comment">//是不是关闭了</span></span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(service.isTerminated());</span><br><span class="line">        System.out.println(service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552380940265" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552380940265.png" class="lazyload"></p>
<h4 id="1、Future接口实现类——FutureTask"><a href="#1、Future接口实现类——FutureTask" class="headerlink" title="1、Future接口实现类——FutureTask"></a>1、Future接口实现类——FutureTask</h4><blockquote>
<p>线程可以输出返回值</p>
</blockquote>
<table>
<thead>
<tr>
<th>FutureTask(Callable<v> callable)</v></th>
</tr>
</thead>
<tbody><tr>
<td>创建一个 <code>FutureTask</code> ，它将在运行时执行给定的 <code>Callable</code>，并给出返回值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_Future</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;); <span class="comment">//new Callable () &#123; Integer call();&#125;</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(task.get()); <span class="comment">//阻塞，直到拿到Callable的call返回的值</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Future&lt;Integer&gt; f = service.submit(()-&gt;&#123;<span class="comment">//重写Callable的call方法</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">        System.out.println(f.isDone());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552398499806" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552398499806.png" class="lazyload"></p>
<h4 id="2、并行计算"><a href="#2、并行计算" class="headerlink" title="2、并行计算"></a>2、并行计算</h4><blockquote>
<p>5个线程并行计算1-200000以内的素数的时间</p>
</blockquote>
<p>在上述提到ExecutorService的submit方法的参数可以是Runnable，也可以是Callable，本次采用Callable可以收到返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池的概念</span></span><br><span class="line"><span class="comment">* nasa</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_ParallelComputing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//=====================不用线程，直接算1-200000之间的素数==============================</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        getPrime(<span class="number">1</span>, <span class="number">200000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> processors = Runtime.getRuntime().availableProcessors();<span class="comment">//返回当前电脑的cpu核数</span></span><br><span class="line">        System.out.println(<span class="string">"processorsNum::"</span>+processors);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//==========使用4个线程，将1-200000进行切片并行计算得到返回值============================</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpuCoreNum = <span class="number">4</span>;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class="line"> </span><br><span class="line">        MyTask t1 = <span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">80000</span>); <span class="comment">//1-5 5-10 10-15 15-20</span></span><br><span class="line">        MyTask t2 = <span class="keyword">new</span> MyTask(<span class="number">80001</span>, <span class="number">130000</span>);</span><br><span class="line">        MyTask t3 = <span class="keyword">new</span> MyTask(<span class="number">130001</span>, <span class="number">170000</span>);</span><br><span class="line">        MyTask t4 = <span class="keyword">new</span> MyTask(<span class="number">170001</span>, <span class="number">200000</span>);</span><br><span class="line"> </span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(t1);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(t2);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(t3);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(t4);</span><br><span class="line"> </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        f1.get();</span><br><span class="line">        f2.get();</span><br><span class="line">        f3.get();</span><br><span class="line">        f4.get();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startPos, endPos;</span><br><span class="line"> </span><br><span class="line">        MyTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = s;</span><br><span class="line">            <span class="keyword">this</span>.endPos = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; r = getPrime(startPos, endPos);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是素数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出start到end之间的素数，并放入list中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i)) results.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><strong>并行计算速度很快</strong></p>
<p><img alt="1552399229946" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552399229946.png" class="lazyload"></p>
<h3 id="2、CachedPool"><a href="#2、CachedPool" class="headerlink" title="2、CachedPool"></a>2、CachedPool</h3><blockquote>
<pre><code>弹性线程池，有一个任务，就开启一个线程，每个线程都activetime，超过这个时间未开启则销毁该线程

查看源码：存活时间为60s，无界队列，最大Integer.MAX_VALUE基本达不到
![1552399339664](/images/java高并发编程/1552399339664.png)</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T08_CachedPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:51</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 弹性线程池，有一个任务，就开启一个线程，每个线程都activetime，超过这个时间未开启则销毁该线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_CachedPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">80</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552399699835" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552399699835.png" class="lazyload"></p>
<h3 id="3、newSingleThreadExecutor"><a href="#3、newSingleThreadExecutor" class="headerlink" title="3、newSingleThreadExecutor"></a>3、newSingleThreadExecutor</h3><blockquote>
<p>查看源码：线程数限制为1个</p>
<p><img alt="1552400118289" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400118289.png" class="lazyload"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line"> </span><br><span class="line">                System.out.println(j + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：只有一个线程在执行</strong></p>
<p><img alt="1552400068650" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400068650.png" class="lazyload"></p>
<h3 id="4、newScheduledThreadPool"><a href="#4、newScheduledThreadPool" class="headerlink" title="4、newScheduledThreadPool"></a>4、newScheduledThreadPool</h3><blockquote>
<p>源码查看：每隔一段时间执行一个线程</p>
<p><img alt="1552400446939" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400446939.png" class="lazyload"></p>
<p>service.scheduleAtFixedRate的相关参数</p>
<p><img alt="1552400730234" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400730234.png" class="lazyload"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_ScheduledPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="schedule" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/schedule.gif" class="lazyload"></p>
<h3 id="5、ForkJoinPool"><a href="#5、ForkJoinPool" class="headerlink" title="5、ForkJoinPool"></a>5、ForkJoinPool</h3><blockquote>
<p>原理和MapReduce类似</p>
</blockquote>
<p><img alt="1552401802490" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552401802490.png" class="lazyload"></p>
<blockquote>
<p>ForkJoinPool的execute方法的参数是ForkJoinTask类</p>
<p>ForkJoinTask类有两个直接子类分类为： RecursiveAction和RecursiveTask</p>
</blockquote>
<h4 id="案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算"><a href="#案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算" class="headerlink" title="案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算"></a><strong>案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算</strong></h4><p>下面代码的原理图如下：</p>
<p><img alt="1552465325571" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552465325571.png" class="lazyload"></p>
<h5 id="1、RecursiveAction子类实现"><a href="#1、RecursiveAction子类实现" class="headerlink" title="1、RecursiveAction子类实现"></a>1、RecursiveAction子类实现</h5><blockquote>
<p>无返回值，只能在compute方法中打印查看</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T12_ForkJoinPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.stream(nums).sum()); <span class="comment">//stream api</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"> </span><br><span class="line">        AddTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">                System.out.println(<span class="string">"from:"</span> + start + <span class="string">" to:"</span> + end + <span class="string">" = "</span> + sum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">                AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">                AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        <span class="comment">//long result = task.join();</span></span><br><span class="line">        <span class="comment">//System.out.println(result);</span></span><br><span class="line"> </span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552464765077" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552464765077.png" class="lazyload"></p>
<h5 id="2、RecursiveTask子类实现"><a href="#2、RecursiveTask子类实现" class="headerlink" title="2、RecursiveTask子类实现"></a>2、RecursiveTask子类实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T12_ForkJoinPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.stream(nums).sum()); <span class="comment">//stream api</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"> </span><br><span class="line">        AddTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">            AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">            subTask1.fork();</span><br><span class="line">            subTask2.fork();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        <span class="keyword">long</span> result = task.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//System.in.read();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、WorkStealingPool"><a href="#6、WorkStealingPool" class="headerlink" title="6、WorkStealingPool"></a>6、WorkStealingPool</h3><blockquote>
<p><strong>WorkStealingPool是在ForkJoinPool的基础上做了封装</strong></p>
<p>WorkStealingPool中的每个线程都有自己的任务队列，如果某一个线程完成后队列也没有任务，就会去其他的线程任务队列中拿任务做。主动找活干</p>
<p>由于我的电脑是12线程，所以我开了14个线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T11_WorkStealingPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:52</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 主动找活干</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_WorkStealingPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));<span class="comment">//daemon</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//由于产生的是精灵线程（守护线程、后台线程），主线程不阻塞的话，看不到输出</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line"> </span><br><span class="line">        R(<span class="keyword">int</span> t) &#123;</span><br><span class="line">            <span class="keyword">this</span>.time = t;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(time  + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552466044537" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552466044537.png" class="lazyload"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>如果想要自己打造一个线程池，可以继承ThreadPoolExecutor来创造自己的线程池</p>
<h2 id="parallelStream-API（多线程）"><a href="#parallelStream-API（多线程）" class="headerlink" title="parallelStream API（多线程）"></a>parallelStream API（多线程）</h2><blockquote>
<p><strong>jdk1.8新增的比较方便的接口，使用多线程来进行一起做事</strong></p>
<p>List中存着10000个数，并判断是否为素数，常规方法是遍历所有的数进行判断，速度慢。</p>
<p>Collection中提供了parallelStream的方式进行遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T14_ParallelStreamAPI</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:54</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T14_ParallelStreamAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) nums.add(<span class="number">1000000</span> + r.nextInt(<span class="number">1000000</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//System.out.println(nums);</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        nums.forEach(v-&gt;isPrime(v));</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用parallel stream api</span></span><br><span class="line"> </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        nums.parallelStream().forEach(T14_ParallelStreamAPI::isPrime);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>在判断10000个数是否为素数上速度差距很大</p>
<p><img alt="1552466241334" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552466241334.png" class="lazyload"></p>
]]></content>
  </entry>
  <entry>
    <title>python实现微信公众号信息推送</title>
    <url>/2019/11/17/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<blockquote>
<p>本教程使用的是个人测试账号，企业微信公众号稍有出入<br>主要用来做服务异常报警处理，也可以使用推送邮件，但是显得过重，所以使用微信推送消息简洁</p>
</blockquote>
<h2 id="1、注册账号"><a href="#1、注册账号" class="headerlink" title="1、注册账号"></a>1、注册账号</h2><p>前往网站 <em><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></em> 注册账号</p>
<p>获取 appID 、 appsecret，后面有用</p>
<p><img alt="1557989221693" data-src="http://img.mxranger.cn/1557989221693.png" class="lazyload"></p>
<h2 id="2、获取ACCESS-TOKEN"><a href="#2、获取ACCESS-TOKEN" class="headerlink" title="2、获取ACCESS_TOKEN"></a>2、获取ACCESS_TOKEN</h2><blockquote>
<p> 官网教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183</a></p>
</blockquote>
<p><strong>注意：access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试账号id secret</span></span><br><span class="line">    appid = <span class="string">"xxxxxxxxxxxxxxxxxx"</span></span><br><span class="line">    secret = <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="</span>+appid+<span class="string">"&amp;secret="</span>+secret</span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    access_token = res.json()[<span class="string">"access_token"</span>]</span><br><span class="line">    print(access_token)</span><br></pre></td></tr></table></figure>

<h2 id="3、设置信息模板"><a href="#3、设置信息模板" class="headerlink" title="3、设置信息模板"></a>3、设置信息模板</h2><p>首先添加用户，用来收信息的微信号，扫二维码即可,微信号后面有用</p>
<p><img alt="1557989476566" data-src="http://img.mxranger.cn/1557989476566.png" class="lazyload"><br>添加模板，按照要求填写即可</p>
<p>注意：企业公众号有固定的信息模板，个人测试则自定义即可</p>
<p><img alt="1557989560258" data-src="http://img.mxranger.cn/1557989560258.png" class="lazyload"></p>
<p>添加完成</p>
<p><img alt="1557989621986" data-src="http://img.mxranger.cn/1557989621986.png" class="lazyload"></p>
<h2 id="4、发送模板信息"><a href="#4、发送模板信息" class="headerlink" title="4、发送模板信息"></a>4、发送模板信息</h2><blockquote>
<p>官网教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433751277" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433751277</a></p>
<p><img alt="1557989712618" data-src="http://img.mxranger.cn/1557989712618.png" class="lazyload"></p>
</blockquote>
<p>代码如下：</p>
<blockquote>
<p> 解释：</p>
<pre><code>touser : 是扫二维码后生成的微信号id

template_id ：创建模板后的模板id

data：模板内容一一对应的数据，value是值，color为颜色字体</code></pre></blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url1 = <span class="string">"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="</span> + access_token</span><br><span class="line"></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">"touser"</span>:<span class="string">"xxxxxxxxxxxxxxxxxxxx"</span>, <span class="comment"># 接收信息的用户id</span></span><br><span class="line">        <span class="string">"template_id"</span>:<span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>, <span class="comment">#模板id</span></span><br><span class="line">        <span class="string">"topcolor"</span>:<span class="string">"#FF0000"</span>,</span><br><span class="line">        <span class="string">"data"</span>:&#123;</span><br><span class="line">                <span class="string">"first"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:<span class="string">"服务器正常,爬虫数据已更新"</span>,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#ff0000"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"time"</span>: &#123; </span><br><span class="line">                    <span class="string">"value"</span>:time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time())),</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#173177"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"content"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:con,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#173177"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"remark"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:<span class="string">"稳定运行"</span>,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#ff0000"</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res1 = requests.post(url=url1,data=json.dumps(param))</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="微信图片编辑_20190516150303" data-src="http://img.mxranger.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20190516150303.jpg" class="lazyload"></p>
<p>推荐一家消息推送的网站，叫Server酱，使用简单方便</p>
<p><a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">http://sc.ftqq.com/3.version</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用教程</title>
    <url>/2019/11/17/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、docker"><a href="#一、docker" class="headerlink" title="一、docker"></a>一、docker</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><h3 id="1、什么是Dokcer"><a href="#1、什么是Dokcer" class="headerlink" title="1、什么是Dokcer"></a>1、什么是Dokcer</h3><pre><code>百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口；
使用go语言编写，在LCX（linux容器）基础上进行的封装
简单来说：
1）就是可以快速部署启动应用
2）实现虚拟化，完整资源隔离
3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用）</code></pre><h3 id="2、为什么要用"><a href="#2、为什么要用" class="headerlink" title="2、为什么要用"></a>2、为什么要用</h3><p>1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就可以直接启动运行   </p>
<p>2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动</p>
<p>3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用</p>
<p>4、更好的资源隔离和共享</p>
<p>一句话：开箱即用，快速部署，可移植性强，环境隔离</p>
<h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="1、linux安装"><a href="#1、linux安装" class="headerlink" title="1、linux安装"></a>1、linux安装</h3><p><strong>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</strong> </p>
<p>1、通过<strong>uname -r</strong>命令查看你当前的内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>2、使用 <code>root</code> 权限登录 Centos。确保 yum 包更新到最新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<p>3、卸载旧版本(如果安装过旧版本的话)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>

<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>5、设置yum源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>

<p>7、安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce #repo中默认只开启stable仓库</span><br></pre></td></tr></table></figure>

<p>8、启动并加入开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><img alt="1557193586913" data-src="http://img.mxranger.cn/docker/img/1557193586913.png" class="lazyload"></p>
<p><code>lsb_release -a</code>命令查看linux版本</p>
<p><img alt="1557133258261" data-src="http://img.mxranger.cn/docker/img/1557133258261.png" class="lazyload"></p>
<h3 id="2、win10安装"><a href="#2、win10安装" class="headerlink" title="2、win10安装"></a>2、win10安装</h3><h4 id="1、去官网注册账号，点击"><a href="#1、去官网注册账号，点击" class="headerlink" title="1、去官网注册账号，点击"></a>1、去官网注册账号，点击</h4><p><img alt="1557649468894" data-src="http://img.mxranger.cn/docker/img/1557649468894.png" class="lazyload"></p>
<p><img alt="1557649485009" data-src="http://img.mxranger.cn/docker/img/1557649485009.png" class="lazyload"></p>
<p>安装完成</p>
<p><img alt="QQ图片20180227225058.png" data-src="http://img.mxranger.cn/docker/img/201802284475_4291.png" class="lazyload"></p>
<p>单击Close and log out，会自动注销当前用户</p>
<h4 id="2、打开docker"><a href="#2、打开docker" class="headerlink" title="2、打开docker"></a>2、打开docker</h4><p>桌面打开docker，如果系统没有启动hyper-v的话，会提示你启动，点击ok启动。这个时候系统可能会重启安装hyper-v。等它重启完毕后，在桌面的右下角就能看到docker的图标，说明docker开始运行了。</p>
<p>[<img alt="windows10上安装docker" data-src="http://img.mxranger.cn/docker/img/6159252dd42a2834b433c56656b5c9ea14cebfc2.jpg" class="lazyload"></p>
<p><img alt="1557649614054" data-src="http://img.mxranger.cn/docker/img/1557649614054.png" class="lazyload"></p>
<h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p>cmd命令输入<code>docker version</code></p>
<p><img alt="1557649657623" data-src="http://img.mxranger.cn/docker/img/1557649657623.png" class="lazyload"></p>
<p>则安装完成</p>
<h3 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h3><p>由于Vmware和docker不能共用，当使用vmware时需要关闭Hyper-V，否则报错</p>
<p><img alt="vmware 报错" data-src="http://img.mxranger.cn/docker/img/Snipaste_2018-06-08_21-50-16.png" class="lazyload"></p>
<p>控制面板-&gt;程序-&gt;程序和功能-&gt;启用或关闭 Windows 功能</p>
<p><img alt="start Hyper-V" data-src="http://img.mxranger.cn/docker/img/markdown-img-paste-20180611095532509.png" class="lazyload"></p>
<p><strong>只能二选一</strong></p>
<h2 id="3、概念"><a href="#3、概念" class="headerlink" title="3、概念"></a>3、概念</h2><p>1、Docker 镜像 - Docker images：<br>容器运行时的只读模板，操作系统+软件运行环境+用户程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Docker 容器 - Docker containers：<br>容器包含了某个应用运行所需要的全部环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user = new User()</span><br></pre></td></tr></table></figure>
<p>3、Docker 仓库 - Docker registeries：<br>用来保存镜像，有公有和私有仓库，好比Maven的中央仓库和本地私服</p>
<p>镜像仓库：    </p>
<p>（参考）配置国内镜像仓库：<a href="https://blog.csdn.net/zzy1078689276/article/details/77371782" target="_blank" rel="noopener">https://blog.csdn.net/zzy1078689276/article/details/77371782</a></p>
<p>对比面向对象的方式<br>Dokcer 里面的镜像 : Java里面的类 Class<br>Docker 里面的容器 : Java里面的对象 Object<br>通过类创建对象，通过镜像创建容器</p>
<h2 id="4、docker常见命令"><a href="#4、docker常见命令" class="headerlink" title="4、docker常见命令"></a>4、docker常见命令</h2><p>常用命令（安装部署好Dokcer后，执行的命令是docker开头）,xxx是镜像名称</p>
<pre><code>搜索镜像：docker search xxx

列出当前系统存在的镜像：docker images

拉取镜像：docker pull xxx
xxx是具体某个镜像名称(格式 REPOSITORY:TAG)
REPOSITORY：表示镜像的仓库源,TAG：镜像的标签

运行一个容器：docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management
docker run - 运行一个容器
-d 后台运行
-p 端口映射
rabbitmq:management  (格式 REPOSITORY:TAG)，如果不指定tag，默认使用最新的
--name &quot;xxx&quot;

列举当前运行的容器：docker ps

检查容器内部信息：docker inspect 容器名称

删除镜像：docker rmi IMAGE_NAME
强制移除镜像不管是否有容器使用该镜像 增加 -f 参数，

停止某个容器：docker stop 容器名称/容器id

启动某个容器：docker start 容器名称/容器id

移除某个容器： docker rm 容器名称 （容器必须是停止状态）</code></pre><h3 id="安装rabbitmq镜像"><a href="#安装rabbitmq镜像" class="headerlink" title="安装rabbitmq镜像"></a>安装rabbitmq镜像</h3><p>查看镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>从仓库中拉取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>查看已安装的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img alt="1557193935767" data-src="http://img.mxranger.cn/docker/img/1557193935767.png" class="lazyload"></p>
<p>运行rabbitmq</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>查看运行的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img alt="1557193914859" data-src="http://img.mxranger.cn/docker/img/1557193914859.png" class="lazyload"></p>
<p>防火墙打开15672端口</p>
<p>RabbitMQ默认创建了一个 guest 用户，密码也是 guest, 如果访问不了记得查看防火墙，端口或者云服务器的安全组<br>          管理后台：<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></p>
<p><img alt="1557194025594" data-src="http://img.mxranger.cn/docker/img/1557194025594.png" class="lazyload"></p>
<p>停止工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称/容器id</span><br></pre></td></tr></table></figure>



<p>其他命令文档：<br>            <a href="https://blog.csdn.net/permike/article/details/51879578" target="_blank" rel="noopener">https://blog.csdn.net/permike/article/details/51879578</a></p>
<h3 id="安装nginx镜像"><a href="#安装nginx镜像" class="headerlink" title="安装nginx镜像"></a>安装nginx镜像</h3><p>1、获取镜像 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run (首先会从本地找镜像，如果有则直接启动，没有的话，从镜像仓库拉起，再启动)</span><br><span class="line"></span><br><span class="line">docker search nignx</span><br></pre></td></tr></table></figure>

<p>2、列举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>3、拉取</p>
<p>若不加-tag 则下载最新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nignx</span><br></pre></td></tr></table></figure>
<p>4、启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name &quot;xdclass_nginx&quot; -p 8088:80 nginx</span><br><span class="line">docker run -d --name &quot;xdclass_nginx2&quot; -p 8089:80 nginx</span><br><span class="line">docker run -d --name &quot;xdclass_nginx3&quot; -p 8090:80 nginx</span><br></pre></td></tr></table></figure>
<p>5、访问<br>如果是阿里云服务，记得配置安全组，腾讯云也需要配置，这个就是一个防火墙</p>
<p><img alt="1557306207106" data-src="http://img.mxranger.cn/docker/img/1557306207106.png" class="lazyload"></p>
<h3 id="安装redis镜像"><a href="#安装redis镜像" class="headerlink" title="安装redis镜像"></a>安装redis镜像</h3><p>1、搜索镜像<br><code>docker search redis</code></p>
<p>2、拉取<br><code>docker pull docker.io/redis</code></p>
<p>3、启动<br><code>docker run --name &quot;xd_redis&quot; -p 6379:6379 -d [IMAGE ID]</code><br>参考：<br><code>docker run --name &quot;xd_redis&quot; -p 6379:6379 -d [IMAGE ID] --requirepass &quot;123456&quot; -v $PWD/data:/data</code></p>
<p><code>--requirepass</code>设置密码        <code>-v</code> 本机路径:容器路径</p>
<p>4、访问redis容器里面，进行操作<br><code>docker exec -it bb5b092b5483 redis-cli</code></p>
<p><img alt="1557660802359" data-src="http://img.mxranger.cn/docker/img/1557660802359.png" class="lazyload"></p>
<p><img alt="1557660925504" data-src="http://img.mxranger.cn/docker/img/1557660925504.png" class="lazyload"></p>
<p>redis镜像配置成功</p>
<h2 id="5、镜像仓库"><a href="#5、镜像仓库" class="headerlink" title="5、镜像仓库"></a>5、镜像仓库</h2><h3 id="官方公共镜像仓库和私有镜像仓库"><a href="#官方公共镜像仓库和私有镜像仓库" class="headerlink" title="官方公共镜像仓库和私有镜像仓库"></a>官方公共镜像仓库和私有镜像仓库</h3><p>1、公共镜像仓库：<br>        官方：<a href="https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的" target="_blank" rel="noopener">https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的</a><br>        非官方：其他组织或者公司开发的镜像，供大家免费试用</p>
<p>2、私有镜像仓库：<br>        用于存放公司内部的镜像，不提供给外部试用； </p>
<pre><code>SpringCloud 开发了一个支付系统 -》做成一个镜像 （操作系统+软件运行环境+用户程序）</code></pre><p><img alt="WechatIMG1" data-src="http://img.mxranger.cn/docker/img/WechatIMG1.png" class="lazyload"></p>
<h2 id="6、镜像仓库配置"><a href="#6、镜像仓库配置" class="headerlink" title="6、镜像仓库配置"></a>6、镜像仓库配置</h2><p>使用自己的镜像仓库</p>
<p>1、点击容器镜像服务，需要设置密码</p>
<p><img alt="1557471756133" data-src="http://img.mxranger.cn/docker/img/1557471756133.png" class="lazyload"></p>
<p>2、创建镜像仓库</p>
<p><img alt="1557472324271" data-src="http://img.mxranger.cn/docker/img/1557472324271.png" class="lazyload"></p>
<p>代码源：选择本地仓库即可</p>
<p>3、管理</p>
<p><img alt="1557472406587" data-src="http://img.mxranger.cn/docker/img/1557472406587.png" class="lazyload"></p>
<p>4、根据所给命令进行pull和push</p>
<p><img alt="1557472829459" data-src="http://img.mxranger.cn/docker/img/1557472829459.png" class="lazyload"></p>
<h2 id="7、推送自己的镜像"><a href="#7、推送自己的镜像" class="headerlink" title="7、推送自己的镜像"></a>7、推送自己的镜像</h2><p>1、登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>2、推送本地镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:[镜像版本号]</span><br><span class="line"></span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:[镜像版本号]</span><br></pre></td></tr></table></figure>



<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>将之前下载的rabbitmq镜像推送到自己的镜像仓库</p>
<p><img alt="1557473073919" data-src="http://img.mxranger.cn/docker/img/1557473073919.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录	输入密码</span><br><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com  </span><br><span class="line"></span><br><span class="line">#推送</span><br><span class="line">docker tag ac759a4f2d38 registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br><span class="line"></span><br><span class="line">#push</span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br></pre></td></tr></table></figure>

<p>推送中：</p>
<p><img alt="1557473325362" data-src="http://img.mxranger.cn/docker/img/1557473325362.png" class="lazyload"></p>
<p>推送完，镜像推送成功</p>
<p><img alt="1557475433518" data-src="http://img.mxranger.cn/docker/img/1557475433518.png" class="lazyload"></p>
<h2 id="8、拉取自己仓库的镜像"><a href="#8、拉取自己仓库的镜像" class="headerlink" title="8、拉取自己仓库的镜像"></a>8、拉取自己仓库的镜像</h2><p>线上服务器拉取镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com </span><br><span class="line"></span><br><span class="line">docker pull registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br><span class="line"></span><br><span class="line">#启动容器</span><br><span class="line">docker run -d --name &quot;mxranger_rabbitmq&quot; -p 15672:15672 ac759a4f2d38</span><br></pre></td></tr></table></figure>

<p><img alt="1557536682388" data-src="http://img.mxranger.cn/docker/img/1557536682388.png" class="lazyload"></p>
<h2 id="9、springboot项目打包docker镜像"><a href="#9、springboot项目打包docker镜像" class="headerlink" title="9、springboot项目打包docker镜像"></a>9、springboot项目打包docker镜像</h2><blockquote>
<p>简介:使用Docker的maven插件，构建springboot应用<br>官方文档：<a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot-docker/</a></p>
</blockquote>
<h3 id="1、简单编写springboot程序"><a href="#1、简单编写springboot程序" class="headerlink" title="1、简单编写springboot程序"></a>1、简单编写springboot程序</h3><p>只添加了web依赖，建一个controller的方法做测试用</p>
<p><img alt="1557650702452" data-src="http://img.mxranger.cn/docker/img/1557650702452.png" class="lazyload"></p>
<h3 id="2、pom-xml添加配置"><a href="#2、pom-xml添加配置" class="headerlink" title="2、pom.xml添加配置"></a>2、pom.xml添加配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>mxranger<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>docker-demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置讲解:</strong><br>        Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。<br><code>${project.build.finalName}</code> 产出物名称，缺省为<code>${project.artifactId}-${project.version}</code></p>
<h3 id="3、创建Dockerfile"><a href="#3、创建Dockerfile" class="headerlink" title="3、创建Dockerfile"></a>3、创建Dockerfile</h3><pre><code>创建Dockerfile在项目根目录（也可以修改为src/main/docker/Dockerfile,如果修则需要制定路径）
Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ARG JAR_FILE</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">ENTRYPOINT ["java","-jar","/app.jar"]</span><br></pre></td></tr></table></figure>

<p><img alt="1557647182362" data-src="http://img.mxranger.cn/docker/img/1557647182362.png" class="lazyload"></p>
<p><strong>参数讲解：</strong><br>【1】<code>FROM &lt;image&gt;:&lt;tag&gt;</code>需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令<br>【2】<code>VOLUME</code>  配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录<br>【3】<code>ARG</code>  设置编译镜像时加入的参数， ENV 是设置容器的环境变量<br>【4】<code>COPY</code> : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点<br>【5】<code>ENTRYPOINT</code> 容器启动时执行的命令<br>【6】<code>EXPOSE 8080</code> 暴露镜像端口</p>
<h3 id="4、构建镜像"><a href="#4、构建镜像" class="headerlink" title="4、构建镜像"></a>4、构建镜像</h3><p>构建前windows10必须安装docker [安装教程](# 2、win10安装)</p>
<p>在idea <code>Terminal</code>的当前项目根目录下执行命令<code>mvn install dockerfile:build</code></p>
<p><img alt="1557649939527" data-src="http://img.mxranger.cn/docker/img/1557649939527.png" class="lazyload"></p>
<p>构建完成后</p>
<p><img alt="1557649981791" data-src="http://img.mxranger.cn/docker/img/1557649981791.png" class="lazyload"></p>
<p>当前电脑中docker镜像</p>
<p><img alt="1557649998263" data-src="http://img.mxranger.cn/docker/img/1557649998263.png" class="lazyload"></p>
<h3 id="5、本地测试"><a href="#5、本地测试" class="headerlink" title="5、本地测试"></a>5、本地测试</h3><p>cmd执行命令<code>docker run -d --name demo -p 8080:8080 [IMAGES ID]</code></p>
<p>测试成功</p>
<p><img alt="1557650596662" data-src="http://img.mxranger.cn/docker/img/1557650596662.png" class="lazyload"></p>
<h3 id="6、推送到阿里云镜像服务器"><a href="#6、推送到阿里云镜像服务器" class="headerlink" title="6、推送到阿里云镜像服务器"></a>6、推送到阿里云镜像服务器</h3><p>步骤同[推送自己的镜像](# 7、推送自己的镜像)一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">登录阿里云</span></span><br><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com</span><br><span class="line"><span class="meta">#</span><span class="bash">打标签</span></span><br><span class="line">docker tag d5267a28accd registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</span><br><span class="line"><span class="meta">#</span><span class="bash">push 推送</span></span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</span><br></pre></td></tr></table></figure>
<p>推送成功<br><img alt="1557652237001" data-src="http://img.mxranger.cn/docker/img/1557652237001.png" class="lazyload"></p>
<p>已经推送阿里云镜像服务器<br><img alt="1557652190008" data-src="http://img.mxranger.cn/docker/img/1557652190008.png" class="lazyload"></p>
<h3 id="7、拉取镜像"><a href="#7、拉取镜像" class="headerlink" title="7、拉取镜像"></a>7、拉取镜像</h3><p>拉取镜像到购买的服务器，同[拉取镜像](# 8、拉取自己仓库的镜像)一样</p>
<p><code>docker pull registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</code></p>
<p><img alt="1557652303752" data-src="http://img.mxranger.cn/docker/img/1557652303752.png" class="lazyload"></p>
<h3 id="8、启动"><a href="#8、启动" class="headerlink" title="8、启动"></a>8、启动</h3><p><img alt="1557652477807" data-src="http://img.mxranger.cn/docker/img/1557652477807.png" class="lazyload"></p>
<p>启动命令<code>docker run -d --name docker_demo -p 8080:8080  d5267a28accd</code></p>
<p>如图启动成功</p>
<p><img alt="1557652443639" data-src="http://img.mxranger.cn/docker/img/1557652443639.png" class="lazyload"></p>
<h3 id="9、查看项目启动日志"><a href="#9、查看项目启动日志" class="headerlink" title="9、查看项目启动日志"></a>9、查看项目启动日志</h3><p><code>docker logs -f  [containerid]</code></p>
<p><img alt="1557652592105" data-src="http://img.mxranger.cn/docker/img/1557652592105.png" class="lazyload"></p>
<h3 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h3><p>1、localhost:2375 connection refused:connect</p>
<p><img alt="1557649151795" data-src="http://img.mxranger.cn/docker/img/1557649151795.png" class="lazyload"></p>
<p>解决办法：右击任务栏Docker图标 点击Settings 勾选红线部分 完美解决<br><img alt="img" data-src="http://img.mxranger.cn/docker/img/20180929181816965.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用七牛云搭建图床</title>
    <url>/2019/11/17/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="七牛云做图床"><a href="#七牛云做图床" class="headerlink" title="七牛云做图床"></a>七牛云做图床</h1><blockquote>
<p>由于微博图床有些已经不能用了，所有利用七牛云进行搭建自己的图床</p>
<p>本教程是需要绑定域名，所以没有域名的请去购买域名，否则七牛云的网址会时效</p>
</blockquote>
<h2 id="1、注册七牛云"><a href="#1、注册七牛云" class="headerlink" title="1、注册七牛云"></a>1、注册七牛云</h2><p>具体不多说，见<a href="https://www.qiniu.com/" target="_blank" rel="noopener">网站</a></p>
<h2 id="2、创建七牛云存储空间"><a href="#2、创建七牛云存储空间" class="headerlink" title="2、创建七牛云存储空间"></a>2、创建七牛云存储空间</h2><p>选择对象存储</p>
<p><img alt="1559206358837" data-src="http://img.mxranger.cn/qiniu/img/1559206358837.png" class="lazyload"></p>
<p>点击新建<br><img alt="1559206384676" data-src="http://img.mxranger.cn/qiniu/img/1559206384676.png" class="lazyload"></p>
<p>内容自行填写</p>
<h2 id="3、注册二级域名"><a href="#3、注册二级域名" class="headerlink" title="3、注册二级域名"></a>3、注册二级域名</h2><p>为你自己的域名注册二级域名(以阿里云域名管理为例，进行说明)</p>
<h3 id="1、点击解析"><a href="#1、点击解析" class="headerlink" title="1、点击解析"></a>1、点击解析</h3><p><img alt="1559206549792" data-src="http://img.mxranger.cn/qiniu/img/1559206549792.png" class="lazyload"></p>
<p>​     </p>
<h3 id="2、添加记录"><a href="#2、添加记录" class="headerlink" title="2、添加记录"></a>2、添加记录</h3><p><img alt="1559206701135" data-src="http://img.mxranger.cn/qiniu/img/1559206701135.png" class="lazyload">     </p>
<p>​     </p>
<h3 id="3、添加解析页面如下所示，页面中的值如下填写即可"><a href="#3、添加解析页面如下所示，页面中的值如下填写即可" class="headerlink" title="3、添加解析页面如下所示，页面中的值如下填写即可"></a>3、添加解析页面如下所示，页面中的值如下填写即可</h3><p><img alt="1559207616427" data-src="http://img.mxranger.cn/qiniu/img/1559207616427.png" class="lazyload"></p>
<h3 id="4、七牛云存储空间绑定二级域名"><a href="#4、七牛云存储空间绑定二级域名" class="headerlink" title="4、七牛云存储空间绑定二级域名"></a>4、七牛云存储空间绑定二级域名</h3><p>1、进入到七牛云存储空间创建完成后跳转的页面，绑定域名</p>
<p><img alt="1559207640036" data-src="http://img.mxranger.cn/qiniu/img/1559207640036.png" class="lazyload"></p>
<p>2、进入到七牛云存储空间创建完成后跳转的页面，绑定域名</p>
<p><img alt="1559207655749" data-src="http://img.mxranger.cn/qiniu/img/1559207655749.png" class="lazyload"></p>
<p>3、绑定成功后，跳转的页面上有CNAME值</p>
<p><img alt="1559207680812" data-src="http://img.mxranger.cn/qiniu/img/1559207680812.png" class="lazyload"></p>
<h3 id="5、为CNAME绑定二级域名"><a href="#5、为CNAME绑定二级域名" class="headerlink" title="5、为CNAME绑定二级域名"></a>5、为CNAME绑定二级域名</h3><p>1、回到阿里云域名解析的页面，修改绑定的值</p>
<p><img alt="1559207711657" data-src="http://img.mxranger.cn/qiniu/img/1559207711657.png" class="lazyload"></p>
<p>2、修改绑定的值为CNAM，替换<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p><img alt="1559207736061" data-src="http://img.mxranger.cn/qiniu/img/1559207736061.png" class="lazyload"></p>
<h2 id="4、审核结果"><a href="#4、审核结果" class="headerlink" title="4、审核结果"></a>4、审核结果</h2><p>至此七牛云绑定域名就行完成了，等待审核结果</p>
<p>收到邮件</p>
<p><img alt="1559207797499" data-src="http://img.mxranger.cn/qiniu/img/1559207797499.png" class="lazyload"></p>
<p><img alt="1559207849766" data-src="http://img.mxranger.cn/qiniu/img/1559207849766.png" class="lazyload"></p>
<h2 id="5、上传图片"><a href="#5、上传图片" class="headerlink" title="5、上传图片"></a>5、上传图片</h2><p>可以在内容管理里面上传图片了</p>
<p><img alt="1559208005620" data-src="http://img.mxranger.cn/qiniu/img/1559208005620.png" class="lazyload"></p>
<p>获取链接</p>
<p><img alt="1559208036593" data-src="http://img.mxranger.cn/qiniu/img/1559208036593.png" class="lazyload"></p>
<p>至此，搭建图床已完成</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题</title>
    <url>/2019/11/17/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1、重建二叉树"><a href="#1、重建二叉树" class="headerlink" title="1、重建二叉树"></a>1、重建二叉树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>树的结构采用用递归来实现。</p>
<p>递归的思想其实就是解决当前节点所需要做的事，然后将下一个节点扔进去做同一件事，所以我们可以当做就解决root应该做的事，赋值 + 对接左右子树</p>
<p>根据前序遍历的特点，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。</p>
<p>根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。</p>
<p>只需要将确定的左右子树安到root上即可。如果最后只有一个元素了，那么就要返回。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rebuildTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rebuildTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//[0]前序数组为空，直接结束</span></span><br><span class="line">        <span class="comment">//可能出现在子树中没有左/右子树的情况</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]判断下以防万一</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]只需要对当前父节点进行赋值即可</span></span><br><span class="line">        <span class="keyword">int</span> root_val = pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]当中序数组中只剩下一个，直接返回，已经是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(in.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[4]记录父节点的索引位置，用来为下面划分左子树和右子树</span></span><br><span class="line">        <span class="keyword">int</span> root_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root_val == in[i])&#123;<span class="comment">//找到根节点的位置，为了一分为二</span></span><br><span class="line">                root_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[5]将前序和中序分别拆分左子树区域和右子树区域</span></span><br><span class="line">        <span class="keyword">int</span>[] pre_left = Arrays.copyOfRange(pre, <span class="number">1</span>, root_index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] pre_right = Arrays.copyOfRange(pre, root_index+<span class="number">1</span>, pre.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] in_left = Arrays.copyOfRange(in, <span class="number">0</span>, root_index);</span><br><span class="line">        <span class="keyword">int</span>[] in_right = Arrays.copyOfRange(in, root_index+<span class="number">1</span>, in.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[6]接上去即可，递归</span></span><br><span class="line">        node.left = reConstructBinaryTree(pre_left, in_left);</span><br><span class="line">        node.right= reConstructBinaryTree(pre_right,in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历打印测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">        print(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">        print(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        print(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="构建二叉树" data-src="http://img.mxranger.cn/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="lazyload"></p>
<h2 id="2、包含min函数的栈"><a href="#2、包含min函数的栈" class="headerlink" title="2、包含min函数的栈"></a>2、包含min函数的栈</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>定义一个主栈A，一个辅助栈B，用来存放最小值<br>既然是最小值，肯定只有一个</p>
<p>主栈A入栈<br>[1]如果B中无值，便入栈其值<br>[2]如果B中有值，判断B栈顶的值和入栈A的值比较<br>        B栈顶的值 &gt; 入栈A的值,将其入辅助栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|  3  |     |     |</span><br><span class="line">|  2  |     |     |</span><br><span class="line">|  4  |     |  2  |</span><br><span class="line">|_ 3__|     |_ 3__|</span><br><span class="line"></span><br><span class="line">   A           B</span><br></pre></td></tr></table></figure>


<p>主栈A出栈<br>[1]判断A出栈值和B的栈顶值<br>        A出栈值 &gt; B的栈顶值,说明A中仍存在B栈顶值，A出栈即可<br>        A出栈值 = B的栈顶值,说明A中除了该值没有再小的值了（最小值只有一个，栈的特性），A和B都出栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|     |     |     |</span><br><span class="line">|  2  |╲   |     |</span><br><span class="line">|  4  |  ╲ |  2  |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B   </span><br><span class="line"></span><br><span class="line">2号出栈</span><br><span class="line"></span><br><span class="line">|     |     |     |</span><br><span class="line">|     |     |     |</span><br><span class="line">|  4  |     |     |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B </span><br><span class="line"></span><br><span class="line">4号出栈</span><br><span class="line">|     |     |     |</span><br><span class="line">|     |╲   |     |</span><br><span class="line">|     |  ╲ |     |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B </span><br><span class="line"></span><br><span class="line">0号入栈</span><br><span class="line">|     |     |     |</span><br><span class="line">|     |╲   |     |</span><br><span class="line">|  0  |  ╲ |  0  |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B</span><br></pre></td></tr></table></figure>

<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MinStack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//辅助栈，用来存放最小值、次小值、.....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.add(node);</span><br><span class="line">        push2(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(stack2.peek() == val)&#123;<span class="comment">//若主栈出栈了最小值 和辅助栈的栈顶一致，便一起出栈，辅助栈留下来前一次的次小值</span></span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = stack2.peek();</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push2</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123; <span class="comment">//栈顶为空放值</span></span><br><span class="line">            stack2.add(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack2.peek()&gt; node)&#123; <span class="comment">//栈顶的最小值若比入栈的还要小，便将其压栈</span></span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinStack stack = <span class="keyword">new</span> MinStack();</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img alt="min函数栈" data-src="http://img.mxranger.cn/min%E5%87%BD%E6%95%B0%E6%A0%88.png" class="lazyload"></p>
<h2 id="3、数的子结构"><a href="#3、数的子结构" class="headerlink" title="3、数的子结构"></a>3、数的子结构</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用递归的方式遍历子树和主数<br>[1] 当主树和子树都为空  返回false</p>
<p>[2]当 当前主树根节点和子树根节点值相同，匹配开始</p>
<pre><code>[2.1] 如果子树遍历完了，说明匹配完成，返回true
[2.2] 如果主数遍历完，说明匹配不成功，返回false (你说你把主数都遍历完了，子树还没结束，还匹配啥)
[2.3] 如果匹配的过程中，有节点不一样，返回false
[2.4] 分别将主树的左子树 + 子树的左子树 进入[2]递归
[2.5] 分别将主树的右子树 + 子树的右子树 进入[2]递归</code></pre><p>[3] 若[2]中为匹配到，则需要将主树的根节点的左子树和右子树分别进入[1]中递归</p>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChildTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123; <span class="comment">//若两个数都为空，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123; </span><br><span class="line">            <span class="comment">//当 当前主树根节点和子树根节点值相同，</span></span><br><span class="line">            <span class="comment">//考虑为匹配开始，进入HasSubtree2函数</span></span><br><span class="line">            result =  HasSubtree2( root1, root2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="comment">//如果没匹配到，遍历主树的左子树去进行匹配</span></span><br><span class="line">            result = HasSubtree(root1.left,root2); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="comment">//如果没匹配到，遍历主树的右子树去进行匹配</span></span><br><span class="line">            result = HasSubtree(root1.right,root2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree2</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;<span class="comment">//遍历子树结束了，说明都匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;<span class="comment">//若主树遍历完，说明没匹配完整，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root1.val != root2.val) &#123;  <span class="comment">//在匹配的时候中途不一样，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]当前节点匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1.1]匹配左子树是否一致</span></span><br><span class="line">        <span class="keyword">boolean</span> result_left = HasSubtree2(root1.left, root2.left); </span><br><span class="line">        <span class="comment">//[1.2]匹配右子树是否一致</span></span><br><span class="line">        <span class="keyword">boolean</span> result_right = HasSubtree2(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result_left &amp;&amp; result_right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode t1 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t1.left = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t1.left.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        t1.left.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        t1.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode t2 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t2.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        t2.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = HasSubtree(t1, t2);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="主树找子树" data-src="http://img.mxranger.cn/%E4%B8%BB%E6%A0%91%E6%89%BE%E5%AD%90%E6%A0%91.png" class="lazyload"></p>
<h2 id="4、栈的压入、弹出序列"><a href="#4、栈的压入、弹出序列" class="headerlink" title="4、栈的压入、弹出序列"></a>4、栈的压入、弹出序列</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>链接：</p>
<p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>举例：</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JudgeStack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JudgeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//辅助栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            <span class="comment">//压栈</span></span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j&lt;popA.length &amp;&amp; stack.peek() == popA[j])&#123; <span class="comment">//判断popA的第一个值是不是栈顶的值，若是，则出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123; <span class="comment">//若辅助栈出栈完毕，说明包含popA的出栈顺序</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pushA = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] popA = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> result = IsPopOrder(pushA,popA);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、从上往下打印二叉树"><a href="#4、从上往下打印二叉树" class="headerlink" title="4、从上往下打印二叉树"></a>4、从上往下打印二叉树</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">二叉树如下：</span><br><span class="line">        1</span><br><span class="line">      /   \</span><br><span class="line">    2       3</span><br><span class="line">  /  \     /  \</span><br><span class="line"> 4    5   6    7</span><br></pre></td></tr></table></figure>

<p>创建一个ArrayList<br>想象成一个队列</p>
<p>[1] 输入1入队</p>
<pre><code>----------------------
                    1
----------------------</code></pre><p>[2]将1出队，并将他的左子树和右子树入队  </p>
<pre><code>将1的值添加到ArrayList中

            ----------------------
        1                  2    3 
            ----------------------</code></pre><p>[3]将2出队，并将他的左子树4和右子树5入队</p>
<pre><code>将2的值添加到ArrayList中
            ----------------------
1       2             3    4    5 
            ----------------------</code></pre><p>[4]将3出队，并将他的左子树4和右子树5入队</p>
<pre><code>将3的值添加到ArrayList中
            ----------------------
1   2   3         4    5   6    7
            ----------------------</code></pre><p>[5] 重复上述动作，4、5、6、7没有左子树和右子树，便以此出队</p>
<p>[6] 当队列为空时，结束</p>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PrintTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; trees = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">        trees.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(trees.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode temp = trees.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                trees.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                trees.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(temp.val+ <span class="string">" "</span>);</span><br><span class="line">            nums.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        PrintFromTopToBottom(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="5、顺序打印矩阵"><a href="#5、顺序打印矩阵" class="headerlink" title="5、顺序打印矩阵"></a>5、顺序打印矩阵</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>一圈一圈打印<br>确定好每圈的左上角位置，按照[0,0] [1,1] [2,2],取一个值即可</p>
<p>每走一圈，行和列都要缩小</p>
<p>打印顺序为：顶行 -&gt; 右列-&gt; 底行 -&gt; 左列</p>
<p>可以设置上下左右的变量锁定行列的打印范围，我没做</p>
<p>单数列、单数行需要进行判断是否需要打印底行 左列</p>
<h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * printMatrix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">printMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">//每圈开始</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一圈圈打印</span></span><br><span class="line">        <span class="keyword">while</span>(row &gt; start * <span class="number">2</span> &amp;&amp; column &gt; start * <span class="number">2</span>)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;column - start;i++)&#123;<span class="comment">//打印顶行</span></span><br><span class="line">                <span class="comment">//    System.out.print(matrix[start][i] + " ");</span></span><br><span class="line">                   nums.add(matrix[start][i]);</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>;i&lt;row - start;i++)&#123;<span class="comment">//打印右列</span></span><br><span class="line">                <span class="comment">// System.out.print(matrix[i][column - start - 1] + " ");</span></span><br><span class="line">                nums.add(matrix[i][column - start - <span class="number">1</span>]);</span><br><span class="line">               &#125;</span><br><span class="line">            </span><br><span class="line">               <span class="keyword">if</span>(start != (row-start-<span class="number">1</span>))&#123; <span class="comment">//若为单行，则无需打印</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> i = column - start - <span class="number">2</span>;i&gt;=start;i--)&#123;<span class="comment">//打印底行</span></span><br><span class="line">                       <span class="comment">// System.out.print(matrix[row-start-1][i] + " ");</span></span><br><span class="line">                       nums.add(matrix[row-start-<span class="number">1</span>][i]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">                </span><br><span class="line">               <span class="keyword">if</span>(start != (column-start-<span class="number">1</span>))&#123;<span class="comment">//若为单列，则无需打印</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> i= row - start - <span class="number">2</span>;i&gt;=start+<span class="number">1</span> ;i--)&#123;<span class="comment">//打印左列</span></span><br><span class="line">                       <span class="comment">// System.out.print(matrix[i][start] + " ");</span></span><br><span class="line">                       nums.add(matrix[i][start]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">               start++;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix2 = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix3 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix4 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>&#125;&#125;;</span><br><span class="line">                        </span><br><span class="line">        ArrayList&lt;Integer&gt; nums = printMatrix(matrix);</span><br><span class="line">        </span><br><span class="line">        nums.forEach((e)-&gt;&#123;</span><br><span class="line">          System.out.print(e + <span class="string">" "</span>);  </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6、平衡二叉树"><a href="#6、平衡二叉树" class="headerlink" title="6、平衡二叉树"></a>6、平衡二叉树</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<h3 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h3><p>[1]求左子树和右子树的深度</p>
<p>[2]平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</p>
<h3 id="完整代码1"><a href="#完整代码1" class="headerlink" title="完整代码1"></a>完整代码1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; <span class="comment">//当前节点为空，情况：没有子节点或者空树    返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_depth = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth = treeDepth(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：</span></span><br><span class="line">        <span class="comment">//它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left_depth - right_depth) &lt;=<span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; <span class="comment">//当前节点为空，情况：没有子节点或者空树    返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_depth = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth = treeDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树 / 右子树 的深度 + 当前节点的深度1</span></span><br><span class="line">        <span class="keyword">return</span> left_depth &gt; right_depth ? left_depth+<span class="number">1</span> : right_depth+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h3><p>[1] 直接在求左右子树的深度时，进行深度之差判断，不平衡直接返回，剪枝效果</p>
<h3 id="完整代码2"><a href="#完整代码2" class="headerlink" title="完整代码2"></a>完整代码2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>'my-first-blog'</title>
    <url>/2019/11/16/my-first-blog/</url>
    <content><![CDATA[<p> # 前言 </p>
<p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快； </li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； </li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； </li>
</ol>
<a id="more"></a> 


<ol start="4">
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5. 博客内容可以轻松打包、转移、发布到其它平台； 6. 等等； </li>
</ol>
<p><img alt="123" data-src="/images/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94.png" class="lazyload"></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
