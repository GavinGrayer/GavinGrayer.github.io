<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL基础教程</title>
    <url>/2019/12/12/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h3 id="1、数据库的好处"><a href="#1、数据库的好处" class="headerlink" title="1、数据库的好处"></a>1、数据库的好处</h3><p>持久化数据到本地<br>可以实现结构化查询，方便管理</p>
<h3 id="2、数据库相关概念"><a href="#2、数据库相关概念" class="headerlink" title="2、数据库相关概念"></a>2、数据库相关概念</h3><p>DB:database：存储数据的“仓库”。它保存了一系列有组织的数据。</p>
<p>DBMS：数据库管理系统（Database Management System）。数据库是通过DBMS创建和操作的容器</p>
<ul>
<li>基于共享文件系统的DBMS（Access）</li>
<li>基于客户机-服务器（CS）的DBMS （MySQL、Oracle、SqlServer）</li>
</ul>
<p>SQL：结构化查询语言（Structure Query Language）：专门用来与数据库通信的语言。</p>
<p>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等</p>
<p><img alt="1560403616380" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560403616380.png" class="lazyload"></p>
<h3 id="3、数据库存储数据的特点"><a href="#3、数据库存储数据的特点" class="headerlink" title="3、数据库存储数据的特点"></a>3、数据库存储数据的特点</h3><p>​    1、将数据放到表中，表再放到库中<br>​    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>​    3、<strong>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</strong><br>​    4、<strong>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</strong><br>​    5、<strong>表中的数据是按行存储的，每一行类似于java中的“对象”。</strong></p>
<h2 id="2、mysql使用"><a href="#2、mysql使用" class="headerlink" title="2、mysql使用"></a>2、mysql使用</h2><h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a>1、登录</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>通过mysql自带的客户端，只限于root用户</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>将mysql文件夹下的bin目录添加到环境变量中，cmd中输入</p>
<p><code>-h:host  -P:port -u:user -p:password</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 3306 -u root -p</span><br></pre></td></tr></table></figure>

<p>输入密码</p>
<p><img alt="1560404879953" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560404879953.png" class="lazyload"></p>
<h3 id="2、SQL的常见命令"><a href="#2、SQL的常见命令" class="headerlink" title="2、SQL的常见命令"></a>2、SQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line"></span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line"></span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">	列名 列类型,</span><br><span class="line">	列名 列类型，</span><br><span class="line">	。。。</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br></pre></td></tr></table></figure>



<h3 id="3、mysql语法规范"><a href="#3、mysql语法规范" class="headerlink" title="3、mysql语法规范"></a>3、mysql语法规范</h3><p>1、不区分大小写,但建议关键字大写，表名、列名小写<br>2、每条命令最好用分号结尾<br>3、每条命令根据需要，可以进行缩进 或换行<br>4、注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字</span><br><span class="line">单行注释：-- 注释文字  必须加空格</span><br><span class="line">多行注释：/* 注释文字  */</span><br></pre></td></tr></table></figure>

<h3 id="4、SQL的语言分类"><a href="#4、SQL的语言分类" class="headerlink" title="4、SQL的语言分类"></a>4、SQL的语言分类</h3><p>DQL（Data Query Language）：数据查询语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select</span><br></pre></td></tr></table></figure>
<p>DML(Data Manipulate Language):数据操作语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 、update、delete</span><br></pre></td></tr></table></figure>
<p>DDL（Data Define Languge）：数据定义语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create、drop、alter</span><br></pre></td></tr></table></figure>
<p>TCL（Transaction Control Language）：事务控制语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit、rollback</span><br></pre></td></tr></table></figure>



<h2 id="3、DQL语言学习"><a href="#3、DQL语言学习" class="headerlink" title="3、DQL语言学习"></a>3、DQL语言学习</h2><blockquote>
<p>Data Query Language —— 数据查询语言</p>
</blockquote>
<p>准备数据，字段介绍</p>
<p><img alt="1560407441118" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560407441118.png" class="lazyload"></p>
<h3 id="1、基础查询"><a href="#1、基础查询" class="headerlink" title="1、基础查询"></a>1、基础查询</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>select 查询列表 from 表名;</p>
<p>类似java中的<code>System.out.println(...)</code>打印</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、查询列表可以是：表中的字段、常量值、表达式、函数<br>2、查询的结果是一个虚拟的表格</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#推荐指定某个数据库</span><br><span class="line">USE myemployees;</span><br></pre></td></tr></table></figure>
<p>1、查询表中的单个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name FROM employees;</span><br></pre></td></tr></table></figure>
<p>2、查询表中的多个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,salary,email FROM employees;</span><br></pre></td></tr></table></figure>
<p>3、查询表中的所有字段<br>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    `employee_id`,</span><br><span class="line">    `first_name`,</span><br><span class="line">    `last_name`,</span><br><span class="line">    `phone_number`,</span><br><span class="line">    `last_name`,</span><br><span class="line">    `job_id`,</span><br><span class="line">    `phone_number`,</span><br><span class="line">    `job_id`,</span><br><span class="line">    `salary`,</span><br><span class="line">    `commission_pct`,</span><br><span class="line">    `manager_id`,</span><br><span class="line">    `department_id`,</span><br><span class="line">    `hiredate` </span><br><span class="line">FROM</span><br><span class="line">    employees ;</span><br></pre></td></tr></table></figure>
<p>方式二： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure>


<p> 4、查询常量值</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100;</span><br><span class="line">SELECT &apos;john&apos;;</span><br></pre></td></tr></table></figure>


<p> 5、查询表达式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98;</span><br><span class="line">SELECT 100*98;</span><br></pre></td></tr></table></figure>



<p> 6、查询mysql版本函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>



<p> 7、起别名<br> ①便于理解<br> ②如果要查询的字段有重名的情况，使用别名可以区分开来</p>
<p>方式一：使用as</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line">SELECT last_name AS 姓,first_name AS 名 FROM employees;</span><br></pre></td></tr></table></figure>

<p>方式二：使用空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name 姓,first_name 名 FROM employees;</span><br></pre></td></tr></table></figure>

<p>案例：查询salary，显示结果为 out put</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary AS &quot;out put&quot; FROM employees;</span><br></pre></td></tr></table></figure>



<p>8、去重 使用DISTINCT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工表中涉及到的所有的部门编号</span><br><span class="line">SELECT DISTINCT department_id FROM employees;</span><br></pre></td></tr></table></figure>



<p>9、+号的作用</p>
<p>java中的+号：<br>①运算符，两个操作数都为数值型<br>②连接符，只要有一个操作数为字符串</p>
<p>mysql中的+号：<br>仅仅只有一个功能：运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 100+90; 两个操作数都为数值型，则做加法运算</span><br><span class="line">select &apos;123&apos;+90;只要其中一方为字符型，试图将字符型数值转换成数值型.如果转换成功，则继续做加法运算</span><br><span class="line">select &apos;john&apos;+90;	如果转换失败，则将字符型数值转换成0</span><br><span class="line">select null+10; 只要其中一方为null，则结果肯定为null</span><br></pre></td></tr></table></figure>



<p>10、concat作用<br>案例：查询员工名和姓连接成一个字段，并显示为 姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) AS 结果;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">	CONCAT(last_name,first_name) AS 姓名</span><br><span class="line">FROM</span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>显示表departments的结构，并查询其中的全部数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc departments;</span><br></pre></td></tr></table></figure>



<p>显示出表employees中的全部job_id（不能重复）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct job_id from employees;</span><br></pre></td></tr></table></figure>



<p>显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(`first_name`,&apos;,&apos;,`last_name`,&apos;,&apos;,`job_id`,&apos;,&apos;,IFNULL(commission_pct,0)) as out_put</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<p><img alt="1560409611290" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560409611290.png" class="lazyload"></p>
<h3 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	查询列表</span><br><span class="line">from</span><br><span class="line">	表名</span><br><span class="line">where</span><br><span class="line">	筛选条件;</span><br></pre></td></tr></table></figure>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1、按条件表达式筛选</p>
<p>简单条件运算符：<code>&gt;</code> <code>&lt;</code>  <code>=</code>  <code>!=</code>  <code>&lt;&gt; (等同于!=)</code>  <code>&gt;=</code>  <code>&lt;=</code></p>
<p>2、按逻辑表达式筛选<br>逻辑运算符：<br>作用：用于连接条件表达式<br><code>&amp;&amp;</code> <code>||</code> <code>!</code>    <code>and</code> <code>or</code> <code>not</code></p>
<p>3、模糊查询<br><code>like</code> <code>between and</code> <code>in</code> <code>is null</code></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>1、按条件表达式筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询工资&gt;12000的员工信息</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary&gt;12000;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#案例2：查询部门编号不等于90号的员工名和部门编号</span><br><span class="line">SELECT </span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	department_id&lt;&gt;90;</span><br></pre></td></tr></table></figure>

<p>2、按逻辑表达式筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary&gt;=10000 AND salary&lt;=20000;</span><br><span class="line">#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	#department_id&gt;90 or department_id&lt;110 OR salary&gt;15000;</span><br><span class="line">	NOT(department_id&gt;=90 AND  department_id&lt;=110) OR salary&gt;15000;</span><br></pre></td></tr></table></figure>



<p>3、模糊查询<br><code>like</code> <code>between and</code> <code>in</code> <code>is null</code> <code>is not null</code></p>
<p>【1】like</p>
<blockquote>
<p>一般和通配符搭配使用，%表示任意个数的任意字符(但是不包含null)<br>    通配符：<br>    % 任意多个字符,包含0个字符<br>    _ 任意单个字符</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询员工名中包含字符a的员工信息</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	last_name like &apos;%a%&apos;;#abc</span><br><span class="line">	</span><br><span class="line">#案例2：查询员工名中第三个字符为e，第五个字符为n的员工名和工资</span><br><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &apos;__e_n%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：查询员工名中第二个字符为_的员工名</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	last_name</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &apos;_$_%&apos; ESCAPE &apos;$&apos;;</span><br></pre></td></tr></table></figure>



<p>【2】between and</p>
<blockquote>
<p>①使用between and 可以提高语句的简洁度<br>②包含临界值<br>③两个临界值不要调换顺序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询员工编号在100到120之间的员工信息</span><br><span class="line"># --------------------方式一 -------------</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	employee_id &gt;= 100 AND employee_id&lt;=120;</span><br><span class="line">#----------------------方式二 -----------</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	employee_id BETWEEN 100 AND 120;</span><br></pre></td></tr></table></figure>



<p>【3】in</p>
<blockquote>
<p>含义：判断某字段的值是否属于in列表中的某一项<br>特点：<br>    ①使用in提高语句简洁度<br>    ②in列表的值类型必须一致或兼容（类似隐式转换）<br>    ③in列表中不支持通配符，必须强制指定某个值，原因在于in就是等号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</span><br><span class="line"># -----------方式一（繁琐）--------------</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	job_id = &apos;IT_PROT&apos; OR job_id = &apos;AD_VP&apos; OR JOB_ID =&apos;AD_PRES&apos;;</span><br><span class="line"></span><br><span class="line">#-----------方式二（简洁）-------</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	job_id IN( &apos;IT_PROT&apos; ,&apos;AD_VP&apos;,&apos;AD_PRES&apos;);</span><br></pre></td></tr></table></figure>

<p>【4】is null</p>
<blockquote>
<p>=或&lt;&gt;不能用于判断null值<br>is null或is not null 可以判断null值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>【5】安全等于 <code>&lt;=&gt;</code></p>
<blockquote>
<p>可以判断null值，也可以判断普通值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct &lt;=&gt;NULL;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#案例2：查询工资为12000的员工信息</span><br><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line"></span><br><span class="line">WHERE </span><br><span class="line">	salary &lt;=&gt; 12000;</span><br></pre></td></tr></table></figure>

<p>【总结】</p>
<p>IS NULL:仅仅可以判断NULL值，可读性较高，建议使用<br>&lt;=&gt;    :既可以判断NULL值，又可以判断普通的数值，可读性较低</p>
<p>【6】面试题</p>
<p>1、表内容如下</p>
<p><img alt="1560413964860" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560413964860.png" class="lazyload"></p>
<p><code>select * from test;</code>和<code>select * from where name like &#39;%%&#39;;</code>查询结果是否一样？</p>
<p>select * from test结果如下：</p>
<p><img alt="1560414017635" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560414017635.png" class="lazyload"></p>
<p>select * from where name like ‘%%’结果如下：</p>
<p><img alt="1560414039763" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560414039763.png" class="lazyload"></p>
<p><strong>%表示任意个数的任意字符(但是不包含null)</strong></p>
<h3 id="3、排序查询"><a href="#3、排序查询" class="headerlink" title="3、排序查询"></a>3、排序查询</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表名</span><br><span class="line">【where  筛选条件】</span><br><span class="line">order by 排序的字段或表达式;</span><br></pre></td></tr></table></figure>



<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1、asc代表的是升序，可以省略，desc代表的是降序</p>
<p>2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段</p>
<p>3、order by子句在查询语句的最后面，除了limit子句</p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1、按单个字段排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees ORDER BY salary DESC;</span><br></pre></td></tr></table></figure>
<p>2、添加筛选条件再排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询部门编号&gt;=90的员工信息，并按员工编号降序</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id&gt;=90</span><br><span class="line">ORDER BY employee_id DESC;</span><br></pre></td></tr></table></figure>

<p>3、按表达式排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息 按年薪降序</span><br><span class="line"></span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;</span><br></pre></td></tr></table></figure>

<p>4、按别名排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息 按年薪升序</span><br><span class="line"></span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY 年薪 ASC;</span><br></pre></td></tr></table></figure>
<p>5、按函数排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工名，并且按名字的长度降序</span><br><span class="line"></span><br><span class="line">SELECT LENGTH(last_name),last_name </span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY LENGTH(last_name) DESC;</span><br></pre></td></tr></table></figure>
<p>6、按多个字段排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工信息，要求先按工资降序，再按employee_id升序</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC,employee_id ASC;</span><br></pre></td></tr></table></figure>



<h3 id="4、常见函数"><a href="#4、常见函数" class="headerlink" title="4、常见函数"></a>4、常见函数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>1、隐藏了实现细节  2、提高代码的重用性</p>
<p>调用：select 函数名(实参列表) from 表;</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>叫什么（函数名）、干什么（函数功能）</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>1、单行函数<br>    如 concat、length、ifnull等<br>2、分组函数<br>    功能：做统计使用，又称为统计函数、聚合函数、组函数</p>
<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><h5 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h5><h6 id="1、length-获取参数值的字节个数"><a href="#1、length-获取参数值的字节个数" class="headerlink" title="1、length 获取参数值的字节个数"></a>1、length 获取参数值的字节个数</h6><p>获取字节个数(utf-8一个汉字代表3个字节，gbk为2个字节)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&apos;john&apos;);</span><br><span class="line">SELECT LENGTH(&apos;张三丰hahaha&apos;);</span><br><span class="line"># 查看当前字符集</span><br><span class="line">SHOW VARIABLES LIKE &apos;%char%&apos;</span><br></pre></td></tr></table></figure>
<h6 id="2、concat-拼接字符串"><a href="#2、concat-拼接字符串" class="headerlink" title="2、concat 拼接字符串"></a>2、concat 拼接字符串</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(last_name,&apos;_&apos;,first_name) 姓名 FROM employees;</span><br></pre></td></tr></table></figure>
<h6 id="3、upper、lower"><a href="#3、upper、lower" class="headerlink" title="3、upper、lower"></a>3、upper、lower</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&apos;john&apos;);</span><br><span class="line">SELECT LOWER(&apos;joHn&apos;);</span><br><span class="line">#示例：将姓变大写，名变小写，然后拼接</span><br><span class="line">SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;</span><br></pre></td></tr></table></figure>

<h6 id="4、substr、substring"><a href="#4、substr、substring" class="headerlink" title="4、substr、substring"></a>4、substr、substring</h6><p><span style="color:red"><strong>注意：索引从1开始</strong></span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#截取从指定索引处后面所有字符</span><br><span class="line">SELECT SUBSTR(&apos;李莫愁爱上了陆展元&apos;,7)  out_put;</span><br><span class="line"></span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">SELECT SUBSTR(&apos;李莫愁爱上了陆展元&apos;,1,3) out_put;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来</span><br><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&apos;_&apos;,LOWER(SUBSTR(last_name,2)))  out_put</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h6 id="5、instr"><a href="#5、instr" class="headerlink" title="5、instr"></a>5、instr</h6><p>返回子串第一次出现的索引，如果找不到返回0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&apos;杨不殷六侠悔爱上了殷六侠&apos;,&apos;殷六侠&apos;) AS out_put;</span><br></pre></td></tr></table></figure>
<h6 id="6、trim"><a href="#6、trim" class="headerlink" title="6、trim"></a>6、trim</h6><p>只去前后空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(TRIM(&apos;    张翠山    &apos;)) AS out_put;</span><br><span class="line"></span><br><span class="line">SELECT TRIM(&apos;aa&apos; FROM &apos;aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&apos;)  AS out_put;</span><br></pre></td></tr></table></figure>

<h6 id="7、lpad"><a href="#7、lpad" class="headerlink" title="7、lpad"></a>7、lpad</h6><p>用指定的字符实现左填充指定长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&apos;殷素素&apos;,、10,&apos;*&apos;) AS out_put;</span><br></pre></td></tr></table></figure>

<h6 id="8、rpad"><a href="#8、rpad" class="headerlink" title="8、rpad"></a>8、rpad</h6><p>用指定的字符实现右填充指定长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT RPAD(&apos;殷素素&apos;,12,&apos;ab&apos;) AS out_put;</span><br></pre></td></tr></table></figure>



<h6 id="9、replace-替换"><a href="#9、replace-替换" class="headerlink" title="9、replace 替换"></a>9、replace 替换</h6><p>有多个则都替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&apos;周芷若周芷若周芷若周芷若张无忌爱上了周芷若&apos;,&apos;周芷若&apos;,&apos;赵敏&apos;) AS out_put;</span><br></pre></td></tr></table></figure>





<h5 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h5><h6 id="1、round-四舍五入"><a href="#1、round-四舍五入" class="headerlink" title="1、round     四舍五入"></a>1、round     四舍五入</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">SELECT ROUND(1.567,2);</span><br></pre></td></tr></table></figure>
<h6 id="2、ceil-向上取整-返回-gt-该参数的最小整数"><a href="#2、ceil-向上取整-返回-gt-该参数的最小整数" class="headerlink" title="2、ceil         向上取整,返回&gt;=该参数的最小整数"></a>2、ceil         向上取整,返回&gt;=该参数的最小整数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CEIL(-1.02);</span><br></pre></td></tr></table></figure>
<h6 id="3、floor-向下取整，返回-lt-该参数的最大整数"><a href="#3、floor-向下取整，返回-lt-该参数的最大整数" class="headerlink" title="3、floor     向下取整，返回&lt;=该参数的最大整数"></a>3、floor     向下取整，返回&lt;=该参数的最大整数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FLOOR(-9.99);</span><br></pre></td></tr></table></figure>
<h6 id="4、truncate-截断"><a href="#4、truncate-截断" class="headerlink" title="4、truncate 截断"></a>4、truncate 截断</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRUNCATE(1.69999,1);</span><br></pre></td></tr></table></figure>
<h6 id="5、mod取余"><a href="#5、mod取余" class="headerlink" title="5、mod取余"></a>5、mod取余</h6><p>mod(a,b) ： <code>a-a/b*b</code><br>mod(-10,-3):-10- (-10)/(-3)*（-3）=-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MOD(10,-3);</span><br><span class="line">SELECT 10%3;</span><br></pre></td></tr></table></figure>



<h5 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h5><p><img alt="1560432443390" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560432443390.png" class="lazyload"></p>
<h6 id="1、now-返回当前系统日期-时间"><a href="#1、now-返回当前系统日期-时间" class="headerlink" title="1、now 返回当前系统日期+时间"></a>1、now 返回当前系统日期+时间</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW(); #2019-06-13 21:18:30</span><br></pre></td></tr></table></figure>
<h6 id="2、curdate-返回当前系统日期，不包含时间"><a href="#2、curdate-返回当前系统日期，不包含时间" class="headerlink" title="2、curdate 返回当前系统日期，不包含时间"></a>2、curdate 返回当前系统日期，不包含时间</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE(); #2019-06-13</span><br></pre></td></tr></table></figure>
<h6 id="3、curtime-返回当前时间，不包含日期"><a href="#3、curtime-返回当前时间，不包含日期" class="headerlink" title="3、curtime 返回当前时间，不包含日期"></a>3、curtime 返回当前时间，不包含日期</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURTIME(); #21:18:30</span><br></pre></td></tr></table></figure>
<h6 id="4、可以获取指定的部分，年、月、日、小时、分钟、秒"><a href="#4、可以获取指定的部分，年、月、日、小时、分钟、秒" class="headerlink" title="4、可以获取指定的部分，年、月、日、小时、分钟、秒"></a>4、可以获取指定的部分，年、月、日、小时、分钟、秒</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">SELECT YEAR(&apos;1998-1-1&apos;) 年;</span><br><span class="line"></span><br><span class="line">SELECT  YEAR(hiredate) 年 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br></pre></td></tr></table></figure>
<h6 id="5、str-to-date-将字符通过指定的格式转换成日期"><a href="#5、str-to-date-将字符通过指定的格式转换成日期" class="headerlink" title="5、str_to_date 将字符通过指定的格式转换成日期"></a>5、str_to_date 将字符通过指定的格式转换成日期</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&apos;1998-3-2&apos;,&apos;%Y-%m-%d&apos;) AS out_put;</span><br><span class="line"></span><br><span class="line">#案例：查询入职日期为1992--4-3的员工信息</span><br><span class="line">SELECT * FROM employees WHERE hiredate = &apos;1992-4-3&apos;;</span><br><span class="line">#自定义格式化</span><br><span class="line">SELECT * FROM employees WHERE hiredate = STR_TO_DATE(&apos;4-3 1992&apos;,&apos;%c-%d %Y&apos;);</span><br></pre></td></tr></table></figure>
<h6 id="7、date-format-将日期转换成字符"><a href="#7、date-format-将日期转换成字符" class="headerlink" title="7、date_format 将日期转换成字符"></a>7、date_format 将日期转换成字符</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;) AS out_put;</span><br><span class="line"></span><br><span class="line">#案例：查询有奖金的员工名和入职日期(xx月/xx日 xx年)</span><br><span class="line">SELECT last_name,DATE_FORMAT(hiredate,&apos;%m月/%d日 %y年&apos;) 入职日期</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<h5 id="四、其他函数"><a href="#四、其他函数" class="headerlink" title="四、其他函数"></a>四、其他函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br><span class="line">SELECT DATABASE();</span><br><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure>



<h5 id="五、流程控制函数"><a href="#五、流程控制函数" class="headerlink" title="五、流程控制函数"></a>五、流程控制函数</h5><h6 id="1、if函数：-if-else-的效果"><a href="#1、if函数：-if-else-的效果" class="headerlink" title="1、if函数： if else 的效果"></a>1、if函数： if else 的效果</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(10&lt;5,&apos;大&apos;,&apos;小&apos;);</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct,IF(commission_pct IS NULL,&apos;没奖金，呵呵&apos;,&apos;有奖金，嘻嘻&apos;) 备注</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h6 id="2、case函数"><a href="#2、case函数" class="headerlink" title="2、case函数"></a>2、case函数</h6><p>【使用一】 switch case 的效果(适合等值判断)</p>
<p>java中写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量或表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>：语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:语句n;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>mysql中写法：（存储过程使用语句）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case [要判断的字段或表达式]</span><br><span class="line">when 常量1 then 要显示的值1或语句1;</span><br><span class="line">when 常量2 then 要显示的值2或语句2;</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>查询员工的工资，要求</p>
<p>部门号=30，显示的工资为1.1倍<br>部门号=40，显示的工资为1.2倍<br>部门号=50，显示的工资为1.3倍<br>其他部门，显示的工资为原工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">（CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END） AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<p>【使用二】类似于 多重if（适合区间判断）</p>
<p>mysql中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">。。。</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>案例：查询员工的工资的情况<br>如果工资&gt;20000,显示A级别<br>如果工资&gt;15000,显示B级别<br>如果工资&gt;10000，显示C级别<br>否则，显示D级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">WHEN salary&gt;20000 THEN &apos;A&apos;</span><br><span class="line">WHEN salary&gt;15000 THEN &apos;B&apos;</span><br><span class="line">WHEN salary&gt;10000 THEN &apos;C&apos;</span><br><span class="line">ELSE &apos;D&apos;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560435493790" data-src="/images/MySQL%E5%9F%BA%E7%A1%80&%E9%AB%98%E7%BA%A7/1560435493790.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示系统时间(注：日期+时间)</span><br><span class="line">#SELECT NOW();</span><br><span class="line"></span><br><span class="line"># 查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</span><br><span class="line">select employee_id,last_name,salary,salary*12 as &apos;new salary&apos;</span><br><span class="line">from employees;</span><br><span class="line"></span><br><span class="line">#将员工的姓名按首字母排序，并写出姓名的长度（length）</span><br><span class="line">select last_name,LENGTH(last_name)</span><br><span class="line">from employees</span><br><span class="line">ORDER BY UPPER(SUBSTR(last_name,1,1));</span><br><span class="line"></span><br><span class="line"># 4、</span><br><span class="line">SELECT CONCAT(last_name , &apos; earns &apos; , salary , &apos; monthly but wants &apos;,salary*3)</span><br><span class="line">AS &apos;Dream Salary&apos;</span><br><span class="line">from employees</span><br><span class="line">WHERE salary=24000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5、</span><br><span class="line">SELECT last_name,job_id as job,</span><br><span class="line">CASE job_id</span><br><span class="line">when &apos;AD_PRES&apos; then &apos;A&apos;</span><br><span class="line">when &apos;ST_MAN&apos; then &apos;B&apos;</span><br><span class="line">when &apos;IT_PROG&apos; then &apos;C&apos;</span><br><span class="line">when &apos;SA_REP&apos; then &apos;D&apos;</span><br><span class="line">when &apos;ST_CLERK&apos; then &apos;E&apos;</span><br><span class="line">END</span><br><span class="line">AS grade</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<h3 id="5、分组函数"><a href="#5、分组函数" class="headerlink" title="5、分组函数"></a>5、分组函数</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>用作统计使用，又称为聚合函数或统计函数或组函数</p>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><p>sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>1、sum、avg一般用于处理数值型<br>   max、min、count可以处理任何类型<br>2、以上分组函数都忽略null值</p>
<p>3、可以和distinct搭配实现去重的运算</p>
<p>4、count函数的单独介绍<br>一般使用count(*)用作统计行数</p>
<p>5、和分组函数一同查询的字段要求是group by后的字段</p>
<h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><p>1、简单使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br><span class="line">SELECT AVG(salary) FROM employees;</span><br><span class="line">SELECT MIN(salary) FROM employees;</span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>2、支持的类型</p>
<p>sum、avg一般用于处理数值型，max、min、count可以处理任何类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(last_name) ,AVG(last_name) FROM employees;</span><br><span class="line">SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(last_name),MIN(last_name) FROM employees;</span><br><span class="line">SELECT MAX(hiredate),MIN(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line"># count()只计算不为null的个数</span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT COUNT(last_name) FROM employees;</span><br></pre></td></tr></table></figure>

<p>3、忽略null值</p>
<p>以下分组函数都忽略null值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT commission_pct FROM employees;</span><br></pre></td></tr></table></figure>

<p>4、和distinct搭配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure>



<p>5、count函数详细介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">#一般统计行数，针对所有字段，比如某一行有一个列为空，但是其他列不为空，也算</span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line"></span><br><span class="line">#count参数为常量值，相当于加了一列常量，依然统计行数</span><br><span class="line">SELECT COUNT(1) FROM employees;</span><br></pre></td></tr></table></figure>

<p><strong><em>效率：</em></strong><br><strong>MYISAM存储引擎下  ，<code>COUNT(*)</code>的效率高</strong><br><strong>INNODB存储引擎下，<code>COUNT(*)</code>和COUNT(1)的效率差不多，比COUNT(字段)要高一些</strong></p>
<p>6、和分组函数一同查询的字段有限制</p>
<p>和分组函数一同查询的字段要求是group by后的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#写法不对，AVG为一个值，employee_id为一个列</span><br><span class="line">SELECT AVG(salary),employee_id  FROM employees;</span><br></pre></td></tr></table></figure>



<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560478111853" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560478111853.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.查询公司员工工资的最大值，最小值，平均值，总和</span><br><span class="line"></span><br><span class="line">SELECT MAX(salary) 最大值,MIN(salary) 最小值,AVG(salary) 平均值,SUM(salary) 和</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）</span><br><span class="line"></span><br><span class="line">SELECT MAX(hiredate) 最大,MIN(hiredate) 最小,(MAX(hiredate)-MIN(hiredate))/1000/3600/24 DIFFRENCE</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) DIFFRENCE</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(&apos;1995-2-7&apos;,&apos;1995-2-6&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.查询部门编号为90的员工个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM employees WHERE department_id = 90;</span><br></pre></td></tr></table></figure>







<h3 id="6、分组查询"><a href="#6、分组查询" class="headerlink" title="6、分组查询"></a>6、分组查询</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【where 筛选条件】</span><br><span class="line">group by 分组的字段</span><br><span class="line">【order by 排序的字段】;</span><br></pre></td></tr></table></figure>



<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>1、和分组函数一同查询的字段必须是group by后出现的字段<br>2、筛选分为两类：分组前筛选和分组后筛选</p>
<table>
<thead>
<tr>
<th></th>
<th>数据源</th>
<th>位置</th>
<th>连接的关键字</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>group by前</td>
<td>where</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>group by后</td>
<td>having</td>
</tr>
</tbody></table>
<p>问题1：分组函数做筛选能不能放在where后面<br>答：不能</p>
<p>问题2：where——group by——having<br>一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率</p>
<p>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用</p>
<h4 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h4><h5 id="1、简单分组"><a href="#1、简单分组" class="headerlink" title="1、简单分组"></a>1、简单分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询每个工种的员工平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line">#案例2：查询每个位置的部门个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br></pre></td></tr></table></figure>

<h5 id="2、分组前的筛选"><a href="#2、分组前的筛选" class="headerlink" title="2、分组前的筛选"></a>2、分组前的筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询邮箱中包含a字符的 每个部门的最高工资</span><br><span class="line"></span><br><span class="line">SELECT MAX(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &apos;%a%&apos;</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的每个领导手下员工的平均工资</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure>



<h5 id="3、分组后筛选"><a href="#3、分组后筛选" class="headerlink" title="3、分组后筛选"></a>3、分组后筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询哪个部门的员工个数&gt;5</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING COUNT(*)&gt;5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line"></span><br><span class="line">SELECT job_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</span><br><span class="line"></span><br><span class="line">SELECT manager_id,MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id&gt;102</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary)&gt;5000;</span><br></pre></td></tr></table></figure>



<h5 id="4、添加排序"><a href="#4、添加排序" class="headerlink" title="4、添加排序"></a>4、添加排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</span><br><span class="line"></span><br><span class="line">SELECT job_id,MAX(salary) m</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING m&gt;6000</span><br><span class="line">ORDER BY m ;</span><br></pre></td></tr></table></figure>

<h5 id="5、按多个字段分组"><a href="#5、按多个字段分组" class="headerlink" title="5、按多个字段分组"></a>5、按多个字段分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个工种每个部门的最低工资,并按最低工资降序</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),job_id,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br><span class="line">ORDER BY MIN(salary) DESC;</span><br></pre></td></tr></table></figure>



<h3 id="7、连接查询"><a href="#7、连接查询" class="headerlink" title="7、连接查询"></a>7、连接查询</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p>
<p>笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行</p>
<p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p>
<h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><p>按年代分类</p>
<ul>
<li>sql92标准:仅仅支持内连接</li>
<li>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</li>
</ul>
<p><span style="color:red">mysql没有全外连接</span></p>
<p>按功能分类<br>内连接：<br>等值连接、非等值连接、自连接</p>
<p>外连接：<br>左外连接、右外连接、全外连接</p>
<p>交叉连接</p>
<h4 id="sql92标准使用"><a href="#sql92标准使用" class="headerlink" title="sql92标准使用"></a>sql92标准使用</h4><h5 id="1、等值连接"><a href="#1、等值连接" class="headerlink" title="1、等值连接"></a>1、等值连接</h5><blockquote>
<p>① 多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③ 多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询女神名和对应的男神名</span><br><span class="line">SELECT NAME,boyName </span><br><span class="line">FROM boys,beauty</span><br><span class="line">WHERE beauty.boyfriend_id= boys.id;</span><br><span class="line"></span><br><span class="line">#案例2：查询员工名和对应的部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees,departments</span><br><span class="line">WHERE employees.`department_id`=departments.`department_id`;</span><br></pre></td></tr></table></figure>



<h5 id="2、为表起别名"><a href="#2、为表起别名" class="headerlink" title="2、为表起别名"></a>2、为表起别名</h5><p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</p>
<p>两个表的顺序可以调换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工名、工种号、工种名</span><br><span class="line"></span><br><span class="line">SELECT e.last_name,e.job_id,j.job_title</span><br><span class="line">FROM employees  e,jobs j</span><br><span class="line">WHERE e.`job_id`=j.`job_id`;</span><br></pre></td></tr></table></figure>



<h5 id="3、加筛选"><a href="#3、加筛选" class="headerlink" title="3、加筛选"></a>3、加筛选</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询有奖金的员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,commission_pct</span><br><span class="line"></span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`commission_pct` IS NOT NULL;</span><br><span class="line"></span><br><span class="line">#案例2：查询城市名中第二个字符为o的部门名和城市名</span><br><span class="line"></span><br><span class="line">SELECT department_name,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id` = l.`location_id`</span><br><span class="line">AND city LIKE &apos;_o%&apos;;</span><br></pre></td></tr></table></figure>



<h5 id="4、加分组"><a href="#4、加分组" class="headerlink" title="4、加分组"></a>4、加分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：查询每个城市的部门个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY city;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span><br><span class="line">SELECT department_name,d.`manager_id`,MIN(salary)</span><br><span class="line">FROM departments d,employees e</span><br><span class="line">WHERE d.`department_id`=e.`department_id`</span><br><span class="line">AND commission_pct IS NOT NULL</span><br><span class="line">GROUP BY department_name,d.`manager_id`</span><br></pre></td></tr></table></figure>

<h5 id="5、加排序"><a href="#5、加排序" class="headerlink" title="5、加排序"></a>5、加排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class="line"></span><br><span class="line">SELECT job_title,COUNT(*)</span><br><span class="line">FROM employees e,jobs j</span><br><span class="line">WHERE e.`job_id`=j.`job_id`</span><br><span class="line">GROUP BY job_title</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br></pre></td></tr></table></figure>

<h5 id="6、实现三表连接"><a href="#6、实现三表连接" class="headerlink" title="6、实现三表连接"></a>6、实现三表连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,departmen t_name,city</span><br><span class="line">FROM employees e,departments d,locations l</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND d.`location_id`=l.`location_id`</span><br><span class="line">AND city LIKE &apos;s%&apos;</span><br><span class="line"></span><br><span class="line">ORDER BY department_name DESC;</span><br></pre></td></tr></table></figure>



<h5 id="7、非等值连接"><a href="#7、非等值连接" class="headerlink" title="7、非等值连接"></a>7、非等值连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询员工的工资和工资级别</span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e,job_grades g</span><br><span class="line">WHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br></pre></td></tr></table></figure>



<h5 id="8、自连接"><a href="#8、自连接" class="headerlink" title="8、自连接"></a>8、自连接</h5><p>自己连接自己</p>
<p><img alt="1560498906057" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560498906057.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">案例：查询 员工名和上级的名称</span><br><span class="line"></span><br><span class="line">SELECT e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure>

<h4 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560499245000" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560499245000.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.显示所有员工的姓名，部门号和部门名称。</span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">SELECT last_name,d.department_id,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id` = d.`department_id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.查询90号部门员工的job_id和90号部门的location_id</span><br><span class="line"></span><br><span class="line">SELECT job_id,location_id</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`department_id`=90;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.	选择所有有奖金的员工的</span><br><span class="line">last_name , department_name , location_id , city</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT last_name , department_name , l.location_id , city</span><br><span class="line">FROM employees e,departments d,locations l</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">AND d.location_id=l.location_id</span><br><span class="line">AND e.commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.选择city在Toronto工作的员工的</span><br><span class="line">last_name , job_id , department_id , department_name </span><br><span class="line"></span><br><span class="line">SELECT last_name , job_id , d.department_id , department_name </span><br><span class="line">FROM employees e,departments d ,locations l</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">AND d.location_id=l.location_id</span><br><span class="line">AND city = &apos;Toronto&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.查询每个工种、每个部门的部门名、工种名和最低工资</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT department_name,job_title,MIN(salary) 最低工资</span><br><span class="line">FROM employees e,departments d,jobs j</span><br><span class="line">WHERE e.`department_id`=d.`department_id`</span><br><span class="line">AND e.`job_id`=j.`job_id`</span><br><span class="line">GROUP BY department_name,job_title;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.查询每个国家下的部门个数大于2的国家编号</span><br><span class="line"></span><br><span class="line">SELECT country_id,COUNT(*) 部门个数</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY country_id</span><br><span class="line">HAVING 部门个数&gt;2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#7、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式</span><br><span class="line">employees	Emp#	manager	Mgr#</span><br><span class="line">kochhar		101	king	100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT e.last_name employees,e.employee_id &quot;Emp#&quot;,m.last_name manager,m.employee_id &quot;Mgr#&quot;</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.manager_id = m.employee_id</span><br><span class="line">AND e.last_name=&apos;kochhar&apos;;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="sql99标准使用"><a href="#sql99标准使用" class="headerlink" title="sql99标准使用"></a>sql99标准使用</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名 【连接类型】</span><br><span class="line">join 表2 别名 </span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组】</span><br><span class="line">【having 筛选条件】</span><br><span class="line">【order by 排序列表】</span><br></pre></td></tr></table></figure>
<h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><p>内连接：inner<br>外连接：左外:left 【outer】、右外：right 【outer】、全外：full【outer】<br>交叉连接：cross </p>
<h5 id="1、内连接使用"><a href="#1、内连接使用" class="headerlink" title="1、内连接使用"></a>1、内连接使用</h5><h6 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">inner join 表2 别名</span><br><span class="line">on 连接条件;</span><br></pre></td></tr></table></figure>

<h6 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h6><p>等值、非等值、自连接</p>
<h6 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h6><p>①添加排序、分组、筛选<br>②inner可以省略<br>③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p>
<h6 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1.查询员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM departments d</span><br><span class="line"> JOIN  employees e</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2.查询名字中包含e的员工名和工种名（添加筛选）</span><br><span class="line">SELECT last_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN jobs j</span><br><span class="line">ON e.`job_id`=  j.`job_id`</span><br><span class="line">WHERE e.`last_name` LIKE &apos;%e%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3. 查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</span><br><span class="line"></span><br><span class="line">#①查询每个城市的部门个数</span><br><span class="line">#②在①结果上筛选满足条件的</span><br><span class="line">SELECT city,COUNT(*) 部门个数</span><br><span class="line">FROM departments d</span><br><span class="line">INNER JOIN locations l</span><br><span class="line">ON d.`location_id`=l.`location_id`</span><br><span class="line">GROUP BY city</span><br><span class="line">HAVING COUNT(*)&gt;3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</span><br><span class="line"></span><br><span class="line">#①查询每个部门的员工个数</span><br><span class="line">SELECT COUNT(*),department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.`department_id`=d.`department_id`</span><br><span class="line">GROUP BY department_name</span><br><span class="line"></span><br><span class="line">#② 在①结果上筛选员工个数&gt;3的记录，并排序</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.`department_id`=d.`department_id`</span><br><span class="line">GROUP BY department_name</span><br><span class="line">HAVING COUNT(*)&gt;3</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br><span class="line"></span><br><span class="line">#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d ON e.`department_id`=d.`department_id`</span><br><span class="line">INNER JOIN jobs j ON e.`job_id` = j.`job_id`</span><br><span class="line"></span><br><span class="line">ORDER BY department_name DESC;</span><br></pre></td></tr></table></figure>





<h6 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的工资级别</span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e</span><br><span class="line"> JOIN job_grades g</span><br><span class="line"> ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #查询工资级别的个数&gt;20的个数，并且按工资级别降序</span><br><span class="line"> SELECT COUNT(*),grade_level</span><br><span class="line">FROM employees e</span><br><span class="line"> JOIN job_grades g</span><br><span class="line"> ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`</span><br><span class="line"> GROUP BY grade_level</span><br><span class="line"> HAVING COUNT(*)&gt;20</span><br><span class="line"> ORDER BY grade_level DESC;</span><br></pre></td></tr></table></figure>

<h6 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.`manager_id`= m.`employee_id`;</span><br><span class="line"></span><br><span class="line"> #查询姓名中包含字符k的员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.`manager_id`= m.`employee_id`</span><br><span class="line">WHERE e.`last_name` LIKE &apos;%k%&apos;;</span><br></pre></td></tr></table></figure>



<h5 id="2、外连接使用"><a href="#2、外连接使用" class="headerlink" title="2、外连接使用"></a>2、外连接使用</h5><p> 应用场景：用于查询一个表中有，另一个表没有的记录</p>
<p> 特点：<br> 1、外连接的查询结果为主表中的所有记录。如果从表中有和它匹配的，则显示匹配的值。如果从表中没有和它匹配的，则显示null</p>
<p>外连接查询结果=内连接结果+主表中有而从表没有的记录</p>
<p> 2、左外连接，left join左边的是主表<br>    右外连接，right join右边的是主表</p>
<p> 3、左外和右外交换两个表的顺序，可以实现同样的效果 </p>
<p> 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入：查询男朋友 不在男神表的的女神名</span><br><span class="line"> #左外连接</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM boys bo</span><br><span class="line"> LEFT OUTER JOIN beauty b</span><br><span class="line"> ON b.`boyfriend_id` = bo.`id`</span><br><span class="line"> WHERE b.`id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #案例1：查询哪个部门没有员工</span><br><span class="line"> #左外</span><br><span class="line"> SELECT d.*,e.employee_id</span><br><span class="line"> FROM departments d</span><br><span class="line"> LEFT OUTER JOIN employees e</span><br><span class="line"> ON d.`department_id` = e.`department_id`</span><br><span class="line"> WHERE e.`employee_id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #右外</span><br><span class="line">SELECT d.*,e.employee_id</span><br><span class="line"> FROM employees e</span><br><span class="line"> RIGHT OUTER JOIN departments d</span><br><span class="line"> ON d.`department_id` = e.`department_id`</span><br><span class="line"> WHERE e.`employee_id` IS NULL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #全外	mysql没有全外连接</span><br><span class="line"> USE girls;</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> FULL OUTER JOIN boys bo</span><br><span class="line"> ON b.`boyfriend_id` = bo.id;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> #交叉连接	笛卡尔乘积</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> CROSS JOIN boys bo;</span><br></pre></td></tr></table></figure>



<h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><p>图示内外连接</p>
<p><img alt="1560566711450" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566711450.png" class="lazyload"></p>
<p><img alt="1560566734011" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566734011.png" class="lazyload"></p>
<p><strong><em>sql92和sql99：</em></strong></p>
<p> 功能：sql99支持的较多<br> 可读性：sql99实现连接条件和筛选条件的分离，可读性较高</p>
<h4 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560577215475" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560577215475.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT b.id,b.name,bo.*</span><br><span class="line">FROM beauty b</span><br><span class="line">LEFT OUTER JOIN boys bo</span><br><span class="line">ON b.`boyfriend_id` = bo.`id`</span><br><span class="line">WHERE b.`id`&gt;3;</span><br><span class="line">#二、查询哪个城市没有部门</span><br><span class="line"></span><br><span class="line">SELECT city</span><br><span class="line">FROM departments d</span><br><span class="line">RIGHT OUTER JOIN locations l </span><br><span class="line">ON d.`location_id`=l.`location_id`</span><br><span class="line">WHERE  d.`department_id` IS NULL;</span><br><span class="line"></span><br><span class="line">#三、查询部门名为SAL或IT的员工信息</span><br><span class="line"></span><br><span class="line">SELECT e.*,d.department_name,d.`department_id`</span><br><span class="line">FROM departments  d</span><br><span class="line">LEFT JOIN employees e</span><br><span class="line">ON d.`department_id` = e.`department_id`</span><br><span class="line">WHERE d.`department_name` IN(&apos;SAL&apos;,&apos;IT&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM departments</span><br><span class="line">WHERE `department_name` IN(&apos;SAL&apos;,&apos;IT&apos;);</span><br></pre></td></tr></table></figure>



<h3 id="8、子查询"><a href="#8、子查询" class="headerlink" title="8、子查询"></a>8、子查询</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询</p>
<h4 id="分类-6"><a href="#分类-6" class="headerlink" title="分类"></a>分类</h4><p>按子查询出现的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select后面：</span><br><span class="line">		仅仅支持标量子查询</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">from后面：</span><br><span class="line">		支持表子查询</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">where或having后面：★</span><br><span class="line">		标量子查询（单行） √</span><br><span class="line">		列子查询  （多行） √</span><br><span class="line">		行子查询</span><br><span class="line"></span><br><span class="line">exists后面（相关子查询）</span><br><span class="line">		表子查询</span><br></pre></td></tr></table></figure>



<p>按结果集的行列数不同：<br>    标量子查询（结果集只有一行一列）<br>    列子查询（结果集只有一列多行）<br>    行子查询（结果集有一行多列）<br>    表子查询（结果集一般为多行多列）</p>
<h4 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h4><h5 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、标量子查询（单行子查询）</span><br><span class="line">2、列子查询（多行子查询）</span><br><span class="line"></span><br><span class="line">3、行子查询（多列多行）</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">①子查询放在小括号内</span><br><span class="line">②子查询一般放在条件的右侧</span><br><span class="line">③标量子查询，一般搭配着单行操作符使用</span><br><span class="line">&gt; &lt; &gt;= &lt;= = &lt;&gt;</span><br><span class="line"></span><br><span class="line">列子查询，一般搭配着多行操作符使用</span><br><span class="line">in、any/some、all</span><br><span class="line"></span><br><span class="line">④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</span><br></pre></td></tr></table></figure>



<p>1、标量子查询（一行一列一个值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#案例1：谁的工资比 Abel 高?</span><br><span class="line"></span><br><span class="line">#①查询Abel的工资</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &apos;Abel&apos;</span><br><span class="line"></span><br><span class="line">#②查询员工的信息，满足 salary&gt;①结果</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line"></span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = &apos;Abel&apos;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</span><br><span class="line"></span><br><span class="line">#①查询141号员工的job_id</span><br><span class="line">SELECT job_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id = 141</span><br><span class="line"></span><br><span class="line">#②查询143号员工的salary</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id = 143</span><br><span class="line"></span><br><span class="line">#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = (</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id = 141</span><br><span class="line">) AND salary&gt;(</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id = 143</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class="line"></span><br><span class="line">#①查询公司的 最低工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询last_name,job_id和salary，要求salary=①</span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例4：查询 最低工资大于50号部门 的 最低工资的部门id和其最低工资</span><br><span class="line"></span><br><span class="line">#①查询50号部门的最低工资</span><br><span class="line">SELECT  MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 50</span><br><span class="line"></span><br><span class="line">#②查询每个部门的最低工资</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#③ 在②基础上筛选，满足min(salary)&gt;①</span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary)&gt;(</span><br><span class="line">	SELECT  MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE department_id = 50</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>2、列子查询（多行子查询）★</p>
<p><img alt="1560585303384" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560585303384.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：返回location_id是1400或1700的部门中的所有员工姓名</span><br><span class="line"></span><br><span class="line">#①查询location_id是1400或1700的部门编号</span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments</span><br><span class="line">WHERE location_id IN(1400,1700)</span><br><span class="line"></span><br><span class="line">#②查询员工姓名，要求部门号是①列表中的某一个</span><br><span class="line"></span><br><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id  IN(</span><br><span class="line">#WHERE department_id = ANY(</span><br><span class="line">#WHERE department_id &lt;&gt; ALL(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">	FROM departments</span><br><span class="line">	WHERE location_id IN(1400,1700)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">#①查询job_id为‘IT_PROG’部门任一工资</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ANY(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ALL(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MIN( salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &apos;IT_PROG&apos;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&apos;IT_PROG&apos;;</span><br></pre></td></tr></table></figure>

<p>3、行子查询（结果集一行多列或多行多列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询员工编号最小并且工资最高的员工信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM employees</span><br><span class="line">WHERE (employee_id,salary)=(</span><br><span class="line">	SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#①查询最小的员工编号</span><br><span class="line">SELECT MIN(employee_id)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询最高工资</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#③查询员工信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id=(</span><br><span class="line">	SELECT MIN(employee_id)</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">)AND salary=(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h5 id="select后面"><a href="#select后面" class="headerlink" title="select后面"></a>select后面</h5><p>仅仅支持标量子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的员工个数</span><br><span class="line"></span><br><span class="line">#相当于主查询每查一行都会获取d.`department_id`的常量值，然后利用这个常量值去子查询里面统计人数</span><br><span class="line">SELECT d.*,(</span><br><span class="line"></span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.department_id = d.`department_id`</span><br><span class="line"> ) 个数</span><br><span class="line"> FROM departments d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #案例2：查询员工号=102的部门名</span><br><span class="line"></span><br><span class="line">SELECT (</span><br><span class="line">	SELECT department_name,e.department_id</span><br><span class="line">	FROM departments d</span><br><span class="line">	INNER JOIN employees e</span><br><span class="line">	ON d.department_id=e.department_id</span><br><span class="line">	WHERE e.employee_id=102</span><br><span class="line">	</span><br><span class="line">) 部门名;</span><br></pre></td></tr></table></figure>





<h5 id="from后面"><a href="#from后面" class="headerlink" title="from后面"></a>from后面</h5><p>将子查询结果充当一张表，要求必须起别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的平均工资的工资等级</span><br><span class="line">#①查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">SELECT * FROM job_grades;</span><br><span class="line"></span><br><span class="line">#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line"></span><br><span class="line">SELECT  ag_dep.*,g.`grade_level`</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line">INNER JOIN job_grades g</span><br><span class="line">ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</span><br></pre></td></tr></table></figure>

<h5 id="exists后面（相关子查询）"><a href="#exists后面（相关子查询）" class="headerlink" title="exists后面（相关子查询）"></a>exists后面（相关子查询）</h5><p>语法：<br>exists(完整的查询语句)<br>结果：1或0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);</span><br><span class="line"></span><br><span class="line">#案例1：查询有员工的部门名</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.`department_id` IN(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line"></span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE d.`department_id`=e.`department_id`</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：查询没有女朋友的男神信息</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line"></span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE bo.id NOT IN(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty b</span><br><span class="line">	WHERE bo.`id`=b.`boyfriend_id`</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h4><p><img alt="1560608516119" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560608516119.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	查询和Zlotkey相同部门的员工姓名和工资</span><br><span class="line"></span><br><span class="line">#①查询Zlotkey的部门</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &apos;Zlotkey&apos;</span><br><span class="line"></span><br><span class="line">#②查询部门号=①的姓名和工资</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = (</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = &apos;Zlotkey&apos;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#2.查询工资比公司平均工资高的员工的员工号，姓名和工资。</span><br><span class="line"></span><br><span class="line">#①查询平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询工资&gt;①的员工号，姓名和工资。</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line"></span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资</span><br><span class="line">#①查询各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#②连接①结果集和employees表，进行筛选</span><br><span class="line">SELECT employee_id,last_name,salary,e.department_id</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">) ag_dep</span><br><span class="line">ON e.department_id = ag_dep.department_id</span><br><span class="line">WHERE salary&gt;ag_dep.ag ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.	查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</span><br><span class="line">#①查询姓名中包含字母u的员工的部门</span><br><span class="line"></span><br><span class="line">SELECT  DISTINCT department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &apos;%u%&apos;</span><br><span class="line"></span><br><span class="line">#②查询部门号=①中的任意一个的员工号和姓名</span><br><span class="line">SELECT last_name,employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN(</span><br><span class="line">	SELECT  DISTINCT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name LIKE &apos;%u%&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5. 查询在部门的location_id为1700的部门工作的员工的员工号</span><br><span class="line"></span><br><span class="line">#①查询location_id为1700的部门</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments </span><br><span class="line">WHERE location_id  = 1700</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②查询部门号=①中的任意一个的员工号</span><br><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id =ANY(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">	FROM departments </span><br><span class="line">	WHERE location_id  = 1700</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#6.查询管理者是King的员工姓名和工资</span><br><span class="line"></span><br><span class="line">#①查询姓名为king的员工编号</span><br><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name  = &apos;K_ing&apos;</span><br><span class="line"></span><br><span class="line">#②查询哪个员工的manager_id = ①</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id IN(</span><br><span class="line">	SELECT employee_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name  = &apos;K_ing&apos;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#7.查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#①查询最高工资</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询工资=①的姓.名</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(first_name,last_name) &quot;姓.名&quot;</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>经典案例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 查询工资最低的员工信息: last_name, salary</span><br><span class="line"></span><br><span class="line">#①查询最低的工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询last_name,salary，要求salary=①</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary=(</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 2. 查询平均工资最低的部门信息</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">#②查询①结果上的最低平均工资</span><br><span class="line">SELECT MIN(ag)</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line"></span><br><span class="line">#③查询哪个部门的平均工资=②</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)=(</span><br><span class="line">	SELECT MIN(ag)</span><br><span class="line">	FROM (</span><br><span class="line">		SELECT AVG(salary) ag,department_id</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">	) ag_dep</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#④查询部门信息</span><br><span class="line"></span><br><span class="line">SELECT d.*</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.`department_id`=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING AVG(salary)=(</span><br><span class="line">		SELECT MIN(ag)</span><br><span class="line">		FROM (</span><br><span class="line">			SELECT AVG(salary) ag,department_id</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">		) ag_dep</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#②求出最低平均工资的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line"></span><br><span class="line">#③查询部门信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments</span><br><span class="line">WHERE department_id=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY AVG(salary) </span><br><span class="line">	LIMIT 1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3. 查询平均工资最低的部门信息和该部门的平均工资</span><br><span class="line">#①各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">#②求出最低平均工资的部门编号</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line">#③查询部门信息</span><br><span class="line">SELECT d.*,ag</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY AVG(salary) </span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line">) ag_dep</span><br><span class="line">ON d.`department_id`=ag_dep.department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4. 查询平均工资最高的 job 信息</span><br><span class="line">#①查询最高的job的平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id</span><br><span class="line">ORDER BY AVG(salary) DESC</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line">#②查询job信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM jobs</span><br><span class="line">WHERE job_id=(</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY job_id</span><br><span class="line">	ORDER BY AVG(salary) DESC</span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"># 5. 查询平均工资高于公司平均工资的部门有哪些?</span><br><span class="line"></span><br><span class="line">#①查询平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">#③筛选②结果集，满足平均工资&gt;①</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)&gt;(</span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 6. 查询出公司中所有 manager 的详细信息.</span><br><span class="line">#①查询所有manager的员工编号</span><br><span class="line">SELECT DISTINCT manager_id</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询详细信息，满足employee_id=①</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id =ANY(</span><br><span class="line">	SELECT DISTINCT manager_id</span><br><span class="line">	FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少</span><br><span class="line"></span><br><span class="line">#①查询各部门的最高工资中最低的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY MAX(salary)</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②查询①结果的那个部门的最低工资</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary) ,department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id=(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY MAX(salary)</span><br><span class="line">	LIMIT 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"># 8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</span><br><span class="line">#①查询平均工资最高的部门编号</span><br><span class="line">SELECT </span><br><span class="line">    department_id </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">ORDER BY AVG(salary) DESC </span><br><span class="line">LIMIT 1 </span><br><span class="line"></span><br><span class="line">#②将employees和departments连接查询，筛选条件是①</span><br><span class="line">    SELECT </span><br><span class="line">        last_name, d.department_id, email, salary </span><br><span class="line">    FROM</span><br><span class="line">        employees e </span><br><span class="line">        INNER JOIN departments d </span><br><span class="line">            ON d.manager_id = e.employee_id </span><br><span class="line">    WHERE d.department_id = </span><br><span class="line">        (SELECT </span><br><span class="line">            department_id </span><br><span class="line">        FROM</span><br><span class="line">            employees </span><br><span class="line">        GROUP BY department_id </span><br><span class="line">        ORDER BY AVG(salary) DESC </span><br><span class="line">        LIMIT 1) ;</span><br></pre></td></tr></table></figure>





<h3 id="9、分页查询"><a href="#9、分页查询" class="headerlink" title="9、分页查询"></a>9、分页查询</h3><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
<h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【join type join 表2】</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by 排序的字段】</span><br><span class="line">limit 【offset,】size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset要显示条目的起始索引（起始索引从0开始）</span><br><span class="line">size 要显示的条目个数</span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>①limit语句放在查询语句的最后<br>②公式<br>要显示的页数 page，每页的条目数size</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">limit (page-1)*size,size;</span><br></pre></td></tr></table></figure>



<h4 id="使用-7"><a href="#使用-7" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询前五条员工信息</span><br><span class="line">SELECT * FROM  employees LIMIT 0,5;</span><br><span class="line">SELECT * FROM  employees LIMIT 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：查询第11条——第25条</span><br><span class="line">SELECT * FROM  employees LIMIT 10,15;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：有奖金的员工信息，并且工资较高的前10名显示出来</span><br><span class="line">SELECT </span><br><span class="line">    * </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 ;</span><br></pre></td></tr></table></figure>



<h3 id="10、查询大练习"><a href="#10、查询大练习" class="headerlink" title="10、查询大练习"></a>10、查询大练习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、查询每个专业的学生人数</span><br><span class="line">SELECT majorid,COUNT(*)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY majorid;</span><br><span class="line"></span><br><span class="line">#二、查询参加考试的学生中，每个学生的平均分、最高分</span><br><span class="line">SELECT AVG(score),MAX(score),studentno</span><br><span class="line">FROM result</span><br><span class="line">GROUP BY studentno;</span><br><span class="line"></span><br><span class="line">#三、查询姓张的每个学生的最低分大于60的学号、姓名</span><br><span class="line">SELECT s.studentno,s.`studentname`,MIN(score)</span><br><span class="line">FROM student s</span><br><span class="line">JOIN result r</span><br><span class="line">ON s.`studentno`=r.`studentno`</span><br><span class="line">WHERE s.`studentname` LIKE &apos;张%&apos;</span><br><span class="line">GROUP BY s.`studentno`</span><br><span class="line">HAVING MIN(score)&gt;60;</span><br><span class="line">#四、查询每个专业生日在“1988-1-1”后的学生姓名、专业名称</span><br><span class="line"></span><br><span class="line">SELECT m.`majorname`,s.`studentname`</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m</span><br><span class="line">ON m.`majorid`=s.`majorid`</span><br><span class="line">WHERE DATEDIFF(borndate,&apos;1988-1-1&apos;)&gt;0</span><br><span class="line">GROUP BY m.`majorid`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#五、查询每个专业的男生人数和女生人数分别是多少</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),sex,majorid</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY sex,majorid;</span><br><span class="line">#六、查询专业和张翠山一样的学生的最低分</span><br><span class="line">#①查询张翠山的专业编号</span><br><span class="line">SELECT majorid</span><br><span class="line">FROM student</span><br><span class="line">WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">#②查询编号=①的所有学生编号</span><br><span class="line">SELECT studentno</span><br><span class="line">FROM student</span><br><span class="line">WHERE majorid=(</span><br><span class="line">	SELECT majorid</span><br><span class="line">	FROM student</span><br><span class="line">	WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">#②查询最低分</span><br><span class="line">SELECT MIN(score)</span><br><span class="line">FROM result</span><br><span class="line">WHERE studentno IN(</span><br><span class="line"></span><br><span class="line">	SELECT studentno</span><br><span class="line">	FROM student</span><br><span class="line">	WHERE majorid=(</span><br><span class="line">		SELECT majorid</span><br><span class="line">		FROM student</span><br><span class="line">		WHERE studentname = &apos;张翠山&apos;</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#七、查询大于60分的学生的姓名、密码、专业名</span><br><span class="line"></span><br><span class="line">SELECT studentname,loginpwd,majorname</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m ON s.majorid=  m.majorid</span><br><span class="line">JOIN result r ON s.studentno=r.studentno</span><br><span class="line">WHERE r.score&gt;60;</span><br><span class="line">#八、按邮箱位数分组，查询每组的学生个数</span><br><span class="line">SELECT COUNT(*),LENGTH(email)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY LENGTH(email);</span><br><span class="line">#九、查询学生名、专业名、分数</span><br><span class="line"></span><br><span class="line">SELECT studentname,score,majorname</span><br><span class="line">FROM student s</span><br><span class="line">JOIN major m ON s.majorid=  m.majorid</span><br><span class="line">LEFT JOIN result r ON s.studentno=r.studentno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#十、查询哪个专业没有学生，分别用左连接和右连接实现</span><br><span class="line">#左</span><br><span class="line">SELECT m.`majorid`,m.`majorname`,s.`studentno`</span><br><span class="line">FROM major m</span><br><span class="line">LEFT JOIN student s ON m.`majorid` = s.`majorid`</span><br><span class="line">WHERE s.`studentno` IS NULL;</span><br><span class="line"></span><br><span class="line">#右</span><br><span class="line">SELECT m.`majorid`,m.`majorname`,s.`studentno`</span><br><span class="line">FROM student s</span><br><span class="line">RIGHT JOIN  major m ON m.`majorid` = s.`majorid`</span><br><span class="line">WHERE s.`studentno` IS NULL;</span><br><span class="line">#十一、查询没有成绩的学生人数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM student s</span><br><span class="line">LEFT JOIN result r ON s.`studentno` = r.`studentno`</span><br><span class="line">WHERE r.`id` IS NULL</span><br></pre></td></tr></table></figure>

<h3 id="11、union联合查询"><a href="#11、union联合查询" class="headerlink" title="11、union联合查询"></a>11、union联合查询</h3><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>
<h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p>
<h4 id="特点：★"><a href="#特点：★" class="headerlink" title="特点：★"></a>特点：★</h4><p>1、要求多条查询语句的查询列数是一致的！<br>2、<strong>要求多条查询语句的查询的每一列的类型和顺序最好一致</strong><br>3、union关键字默认去重，如果使用union all 可以包含重复项</p>
<h4 id="使用-8"><a href="#使用-8" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees WHERE email LIKE &apos;%a%&apos; OR department_id&gt;90;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees  WHERE email LIKE &apos;%a%&apos;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees  WHERE department_id&gt;90;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息</span><br><span class="line">SELECT id,cname FROM t_ca WHERE csex=&apos;男&apos;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT t_id,tname FROM t_ua WHERE tGender=&apos;male&apos;;</span><br></pre></td></tr></table></figure>







<h2 id="4、DML语言学习"><a href="#4、DML语言学习" class="headerlink" title="4、DML语言学习"></a>4、DML语言学习</h2><blockquote>
<p>Data Manipulate Language —— 数据操作语言</p>
<p>insert 、update、delete</p>
</blockquote>
<h3 id="1、插入语句"><a href="#1、插入语句" class="headerlink" title="1、插入语句"></a>1、插入语句</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名(列名,...) </span><br><span class="line">values(值1,...);</span><br></pre></td></tr></table></figure>

<h5 id="使用-9"><a href="#使用-9" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM beauty;</span><br><span class="line">#1.插入的值的类型要与列的类型一致或兼容</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&apos;唐艺昕&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br><span class="line"></span><br><span class="line">#2.为空的列可以赋值null，也可以不对其列赋值</span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&apos;唐艺昕&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,sex,phone)</span><br><span class="line">VALUES(15,&apos;娜扎&apos;,&apos;女&apos;,&apos;1388888888&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.列的顺序可以调换</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&apos;蒋欣&apos;,&apos;女&apos;,16,&apos;110&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.列数和值的个数必须一致</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&apos;关晓彤&apos;,&apos;女&apos;,17,&apos;110&apos;);</span><br><span class="line"></span><br><span class="line">#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致   </span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(18,&apos;张飞&apos;,&apos;男&apos;,NULL,&apos;119&apos;,NULL,NULL);</span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">set 列名=值,列名=值,...</span><br></pre></td></tr></table></figure>

<h5 id="使用-10"><a href="#使用-10" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">SET id=19,NAME=&apos;刘涛&apos;,phone=&apos;999&apos;;</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1、方式一支持插入多行,方式二不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(23,&apos;唐艺昕1&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2)</span><br><span class="line">,(24,&apos;唐艺昕2&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2)</span><br><span class="line">,(25,&apos;唐艺昕3&apos;,&apos;女&apos;,&apos;1990-4-23&apos;,&apos;1898888888&apos;,NULL,2);</span><br></pre></td></tr></table></figure>



<p>2、方式一支持子查询，方式二不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT 26,&apos;宋茜&apos;,&apos;11809866&apos;;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">(</span><br><span class="line">    SELECT id,boyname,&apos;1234567&apos;</span><br><span class="line">	FROM boys WHERE id&lt;3;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>方式一使用较多</p>
<h3 id="2、修改语句"><a href="#2、修改语句" class="headerlink" title="2、修改语句"></a>2、修改语句</h3><h4 id="1、修改单表的记录★"><a href="#1、修改单表的记录★" class="headerlink" title="1、修改单表的记录★"></a>1、修改单表的记录★</h4><h5 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 列 = 新值,列 = 新值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="使用-11"><a href="#使用-11" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.修改单表的记录</span><br><span class="line">#案例1：修改beauty表中姓唐的女神的电话为13899888899</span><br><span class="line"></span><br><span class="line">UPDATE beauty SET phone = &apos;13899888899&apos;</span><br><span class="line">WHERE NAME LIKE &apos;唐%&apos;;</span><br><span class="line"></span><br><span class="line">#案例2：修改boys表中id好为2的名称为张飞，魅力值 10</span><br><span class="line">UPDATE boys SET boyname=&apos;张飞&apos;,usercp=10</span><br><span class="line">WHERE id=2;</span><br></pre></td></tr></table></figure>



<h4 id="2、修改多表的记录【补充】"><a href="#2、修改多表的记录【补充】" class="headerlink" title="2、修改多表的记录【补充】"></a>2、修改多表的记录【补充】</h4><h5 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql92语法：</span><br><span class="line">update 表1 别名,表2 别名</span><br><span class="line">set 列=值,...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 列=值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="使用-12"><a href="#使用-12" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例 1：修改张无忌的女朋友的手机号为114</span><br><span class="line"></span><br><span class="line">UPDATE boys bo</span><br><span class="line">INNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`</span><br><span class="line">SET b.`phone`=&apos;114&apos;,bo.`userCP`=1000</span><br><span class="line">WHERE bo.`boyName`=&apos;张无忌&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：修改没有男朋友的女神的男朋友编号都为2号</span><br><span class="line"></span><br><span class="line">UPDATE boys bo</span><br><span class="line">RIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`</span><br><span class="line">SET b.`boyfriend_id`=2</span><br><span class="line">WHERE bo.`id` IS NULL;</span><br><span class="line"></span><br><span class="line">SELECT * FROM boys;</span><br></pre></td></tr></table></figure>



<h3 id="3、删除语句"><a href="#3、删除语句" class="headerlink" title="3、删除语句"></a>3、删除语句</h3><h4 id="方式一：delete"><a href="#方式一：delete" class="headerlink" title="方式一：delete"></a>方式一：delete</h4><h5 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h5><p>1、单表的删除【★】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 筛选条件;</span><br></pre></td></tr></table></figure>

<p>2、多表的删除【补充】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql92语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line"></span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>
<h5 id="使用-13"><a href="#使用-13" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">======================单表删除==================</span><br><span class="line">#案例：删除手机号以9结尾的女神信息</span><br><span class="line"></span><br><span class="line">DELETE FROM beauty WHERE phone LIKE &apos;%9&apos;;</span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：删除张无忌的女朋友的信息</span><br><span class="line"></span><br><span class="line">DELETE b</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`</span><br><span class="line">WHERE bo.`boyName`=&apos;张无忌&apos;;</span><br><span class="line"></span><br><span class="line">======================多表删除==================</span><br><span class="line">#案例：删除黄晓明的信息以及他女朋友的信息</span><br><span class="line">DELETE b,bo</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`</span><br><span class="line">WHERE bo.`boyName`=&apos;黄晓明&apos;;</span><br></pre></td></tr></table></figure>



<h4 id="方式二：truncate"><a href="#方式二：truncate" class="headerlink" title="方式二：truncate"></a>方式二：truncate</h4><p>清除表所有数据</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><p>1、delete 可以加where 条件，truncate不能加</p>
<p>2、truncate删除，效率高一丢丢</p>
<p><strong>3、假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</strong></p>
<p>4、truncate删除没有返回值，delete删除有返回值</p>
<p>5、truncate删除不能回滚，delete删除可以回滚.</p>
<h3 id="4、练习"><a href="#4、练习" class="headerlink" title="4、练习"></a>4、练习</h3><p><img alt="1560740250627" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560740250627.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	运行以下脚本创建表my_employees</span><br><span class="line"></span><br><span class="line">USE myemployees;</span><br><span class="line">CREATE TABLE my_employees(</span><br><span class="line">	Id INT(10),</span><br><span class="line">	First_name VARCHAR(10),</span><br><span class="line">	Last_name VARCHAR(10),</span><br><span class="line">	Userid VARCHAR(10),</span><br><span class="line">	Salary DOUBLE(10,2)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE users(</span><br><span class="line">	id INT,</span><br><span class="line">	userid VARCHAR(10),</span><br><span class="line">	department_id INT</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#2.	显示表my_employees的结构</span><br><span class="line">DESC my_employees;</span><br><span class="line"></span><br><span class="line">#3.	向my_employees表中插入下列数据</span><br><span class="line">ID	FIRST_NAME	LAST_NAME	USERID	SALARY</span><br><span class="line">1	patel		Ralph		Rpatel	895</span><br><span class="line">2	Dancs		Betty		Bdancs	860</span><br><span class="line">3	Biri		Ben		Bbiri	1100</span><br><span class="line">4	Newman		Chad		Cnewman	750</span><br><span class="line">5	Ropeburn	Audrey		Aropebur	1550</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">VALUES(1,&apos;patel&apos;,&apos;Ralph&apos;,&apos;Rpatel&apos;,895),</span><br><span class="line">(2,&apos;Dancs&apos;,&apos;Betty&apos;,&apos;Bdancs&apos;,860),</span><br><span class="line">(3,&apos;Biri&apos;,&apos;Ben&apos;,&apos;Bbiri&apos;,1100),</span><br><span class="line">(4,&apos;Newman&apos;,&apos;Chad&apos;,&apos;Cnewman&apos;,750),</span><br><span class="line">(5,&apos;Ropeburn&apos;,&apos;Audrey&apos;,&apos;Aropebur&apos;,1550);</span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">SELECT 1,&apos;patel&apos;,&apos;Ralph&apos;,&apos;Rpatel&apos;,895 UNION</span><br><span class="line">SELECT 2,&apos;Dancs&apos;,&apos;Betty&apos;,&apos;Bdancs&apos;,860 UNION</span><br><span class="line">SELECT 3,&apos;Biri&apos;,&apos;Ben&apos;,&apos;Bbiri&apos;,1100 UNION</span><br><span class="line">SELECT 4,&apos;Newman&apos;,&apos;Chad&apos;,&apos;Cnewman&apos;,750 UNION</span><br><span class="line">SELECT 5,&apos;Ropeburn&apos;,&apos;Audrey&apos;,&apos;Aropebur&apos;,1550;</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line">#4.	 向users表中插入数据</span><br><span class="line">1	Rpatel	10</span><br><span class="line">2	Bdancs	10</span><br><span class="line">3	Bbiri	20</span><br><span class="line">4	Cnewman	30</span><br><span class="line">5	Aropebur	40</span><br><span class="line"></span><br><span class="line">INSERT INTO users</span><br><span class="line">VALUES(1,&apos;Rpatel&apos;,10),</span><br><span class="line">(2,&apos;Bdancs&apos;,10),</span><br><span class="line">(3,&apos;Bbiri&apos;,20);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.将3号员工的last_name修改为“drelxer”</span><br><span class="line">UPDATE my_employees SET last_name=&apos;drelxer&apos; WHERE id = 3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.将所有工资少于900的员工的工资修改为1000</span><br><span class="line">UPDATE my_employees SET salary=1000 WHERE salary&lt;900;</span><br><span class="line"></span><br><span class="line">#7.将userid 为Bbiri的user表和my_employees表的记录全部删除</span><br><span class="line"></span><br><span class="line">DELETE u,e</span><br><span class="line">FROM users u</span><br><span class="line">JOIN my_employees e ON u.`userid`=e.`Userid`</span><br><span class="line">WHERE u.`userid`=&apos;Bbiri&apos;;</span><br><span class="line"></span><br><span class="line">#8.删除所有数据</span><br><span class="line"></span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line">DELETE FROM users;</span><br><span class="line">#9.检查所作的修正</span><br><span class="line"></span><br><span class="line">SELECT * FROM my_employees;</span><br><span class="line">SELECT * FROM users;</span><br><span class="line"></span><br><span class="line">#10.清空表my_employees</span><br><span class="line">TRUNCATE TABLE my_employees;</span><br></pre></td></tr></table></figure>











<h2 id="5、DDL语言学习"><a href="#5、DDL语言学习" class="headerlink" title="5、DDL语言学习"></a>5、DDL语言学习</h2><blockquote>
<p>Data Define Languge —— 数据定义语言</p>
</blockquote>
<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>一、库的管理<br>创建、修改、删除<br>二、表的管理<br>创建、修改、删除</p>
<p>创建： create<br>修改： alter<br>删除： drop</p>
<p>数据库的位置</p>
<p><img alt="1560924243469" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560924243469.png" class="lazyload"></p>
<h3 id="2、库的管理"><a href="#2、库的管理" class="headerlink" title="2、库的管理"></a>2、库的管理</h3><h4 id="1、库的创建"><a href="#1、库的创建" class="headerlink" title="1、库的创建"></a>1、库的创建</h4><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database  [if not exists]库名;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<p>创建库Books</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS books ;</span><br></pre></td></tr></table></figure>



<h4 id="2、库的修改"><a href="#2、库的修改" class="headerlink" title="2、库的修改"></a>2、库的修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME DATABASE books TO 新库名;	#废弃</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<p>更改库的字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE books CHARACTER SET gbk;</span><br></pre></td></tr></table></figure>



<h4 id="3、库的删除"><a href="#3、库的删除" class="headerlink" title="3、库的删除"></a>3、库的删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS books;</span><br></pre></td></tr></table></figure>



<h3 id="3、表的管理"><a href="#3、表的管理" class="headerlink" title="3、表的管理"></a>3、表的管理</h3><h4 id="1、表的创建"><a href="#1、表的创建" class="headerlink" title="1、表的创建"></a>1、表的创建</h4><h5 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">create [if not exist] table 表名(</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	...</span><br><span class="line">	列名 列的类型【(长度) 约束】</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="使用-14"><a href="#使用-14" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：创建表Book</span><br><span class="line"></span><br><span class="line">CREATE TABLE book(</span><br><span class="line">	id INT,#编号</span><br><span class="line">	bName VARCHAR(20),#图书名</span><br><span class="line">	price DOUBLE,#价格</span><br><span class="line">	authorId  INT,#作者编号</span><br><span class="line">	publishDate DATETIME#出版日期</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看表结构</span><br><span class="line">DESC book;</span><br><span class="line"></span><br><span class="line">#案例：创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author(</span><br><span class="line">	id INT,</span><br><span class="line">	au_name VARCHAR(20),</span><br><span class="line">	nation VARCHAR(10)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">#查看表结构</span><br><span class="line">DESC author;</span><br></pre></td></tr></table></figure>





<h4 id="2、表的修改"><a href="#2、表的修改" class="headerlink" title="2、表的修改"></a>2、表的修改</h4><h5 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</span><br></pre></td></tr></table></figure>

<h5 id="使用-15"><a href="#使用-15" class="headerlink" title="使用"></a>使用</h5><p>1、修改列名<code>CHANGE</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE [表名] CHANGE COLUMN [原列名] [新列名] [列名类型];</span><br><span class="line"></span><br><span class="line">ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</span><br></pre></td></tr></table></figure>

<p>2、修改列的类型或约束<code>MODIFY</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</span><br></pre></td></tr></table></figure>
<p>3、添加新列<code>ADD</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE author ADD COLUMN annual DOUBLE;</span><br></pre></td></tr></table></figure>
<p>4、删除列<code>DROP</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book_author DROP COLUMN  annual;</span><br></pre></td></tr></table></figure>

<p>5、修改表名<code>RENAME</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE author RENAME TO book_author;</span><br><span class="line"></span><br><span class="line">DESC book;</span><br></pre></td></tr></table></figure>



<h4 id="3、表的删除"><a href="#3、表的删除" class="headerlink" title="3、表的删除"></a>3、表的删除</h4><h5 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS 表明;</span><br></pre></td></tr></table></figure>



<h5 id="使用-16"><a href="#使用-16" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS book_author;</span><br><span class="line"></span><br><span class="line">#查看所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">#通用的写法：</span><br><span class="line"># 删库名 + 创建库名 </span><br><span class="line">DROP DATABASE IF EXISTS 旧库名;</span><br><span class="line">CREATE DATABASE 新库名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS 旧表名;</span><br><span class="line">CREATE TABLE  表名();</span><br></pre></td></tr></table></figure>



<h4 id="4、表的复制"><a href="#4、表的复制" class="headerlink" title="4、表的复制"></a>4、表的复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO author VALUES</span><br><span class="line">(1,&apos;村上春树&apos;,&apos;日本&apos;),</span><br><span class="line">(2,&apos;莫言&apos;,&apos;中国&apos;),</span><br><span class="line">(3,&apos;冯唐&apos;,&apos;中国&apos;),</span><br><span class="line">(4,&apos;金庸&apos;,&apos;中国&apos;);</span><br></pre></td></tr></table></figure>

<p>1、仅仅复制表的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy LIKE author;</span><br></pre></td></tr></table></figure>
<p>2、复制表的结构+数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT * FROM author;</span><br></pre></td></tr></table></figure>
<p>3、只复制部分数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy3</span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author </span><br><span class="line">WHERE nation=&apos;中国&apos;;</span><br></pre></td></tr></table></figure>

<p>4、仅仅复制某些字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy4 </span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author</span><br><span class="line">WHERE 0;	#让where的条件置为0</span><br></pre></td></tr></table></figure>

<h3 id="4、练习-1"><a href="#4、练习-1" class="headerlink" title="4、练习"></a>4、练习</h3><p><img alt="1560995258950" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560995258950.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.	创建表dept1</span><br><span class="line">NAME	NULL?	TYPE</span><br><span class="line">id		INT(7)</span><br><span class="line">NAME		VARCHAR(25)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USE test;</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept1(</span><br><span class="line">	id INT(7),</span><br><span class="line">	NAME VARCHAR(25)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">#2.	将表departments中的数据插入新表dept2中</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept2</span><br><span class="line">SELECT department_id,department_name</span><br><span class="line">FROM myemployees.departments;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.	创建表emp5</span><br><span class="line">NAME	NULL?	TYPE</span><br><span class="line">id		INT(7)</span><br><span class="line">First_name	VARCHAR (25)</span><br><span class="line">Last_name	VARCHAR(25)</span><br><span class="line">Dept_id		INT(7)</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp5(</span><br><span class="line">id INT(7),</span><br><span class="line">first_name VARCHAR(25),</span><br><span class="line">last_name VARCHAR(25),</span><br><span class="line">dept_id INT(7)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.	将列Last_name的长度增加到50</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);</span><br><span class="line">#5.	根据表employees创建employees2</span><br><span class="line"></span><br><span class="line">CREATE TABLE employees2 LIKE myemployees.employees;</span><br><span class="line"></span><br><span class="line">#6.	删除表emp5</span><br><span class="line">DROP TABLE IF EXISTS emp5;</span><br><span class="line"></span><br><span class="line">#7.	将表employees2重命名为emp5</span><br><span class="line"></span><br><span class="line">ALTER TABLE employees2 RENAME TO emp5;</span><br><span class="line"></span><br><span class="line">#8.在表dept和emp5中添加新列test_column，并检查所作的操作</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp5 ADD COLUMN test_column INT;</span><br><span class="line">#9.直接删除表emp5中的列 dept_id</span><br><span class="line">DESC emp5;</span><br><span class="line">ALTER TABLE emp5 DROP COLUMN test_column;</span><br></pre></td></tr></table></figure>

<h3 id="5、常见数据类型"><a href="#5、常见数据类型" class="headerlink" title="5、常见数据类型"></a>5、常见数据类型</h3><h4 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>1、数值型<br>    整型<br>    小数：定点数、浮点数<br>2、字符型<br>    较短的文本：char、varchar<br>    较长的文本：text、blob（较长的二进制数据）</p>
<p>日期型：</p>
<h4 id="2、整型"><a href="#2、整型" class="headerlink" title="2、整型"></a>2、整型</h4><h5 id="分类-7"><a href="#分类-7" class="headerlink" title="分类"></a>分类</h5><table>
<thead>
<tr>
<th></th>
<th>tinyint</th>
<th>smallint</th>
<th>mediumint</th>
<th>int/integer</th>
<th>bigint</th>
</tr>
</thead>
<tbody><tr>
<td>字节</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<h5 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h5><p>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值（5.7不插入，亲测）<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p>
<h5 id="使用-17"><a href="#使用-17" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#1.如何设置无符号和有符号</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS tab_int;</span><br><span class="line">CREATE TABLE tab_int(</span><br><span class="line">	t1 INT(7) ZEROFILL,</span><br><span class="line">	t2 INT(7) ZEROFILL </span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC tab_int;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES(-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(-123456,-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(2147483648,4294967296);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES(123,123);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_int;</span><br></pre></td></tr></table></figure>



<h4 id="3、小数"><a href="#3、小数" class="headerlink" title="3、小数"></a>3、小数</h4><h5 id="分类-8"><a href="#分类-8" class="headerlink" title="分类"></a>分类</h5><p>1.浮点型<br>float(M,D)、double(M,D)<br>2.定点型<br>dec(M，D)、decimal(M,D)</p>
<h5 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h5><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p>
<p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p>
<p>③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p>
<h5 id="使用-18"><a href="#使用-18" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE if EXISTS tab_float;</span><br><span class="line">#M：整数部位+小数部位	D：小数部位</span><br><span class="line">CREATE TABLE tab_float(</span><br><span class="line">	f1 FLOAT(5,2),</span><br><span class="line">	f2 DOUBLE(5,2),</span><br><span class="line">	f3 DECIMAL(5,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_float;</span><br><span class="line">INSERT INTO tab_float VALUES(123.4,123.4,123.4);</span><br><span class="line">SELECT * FROM tab_float;</span><br></pre></td></tr></table></figure>

<p><img alt="1560999089824" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560999089824.png" class="lazyload"></p>
<h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
<h4 id="4、字符型"><a href="#4、字符型" class="headerlink" title="4、字符型"></a>4、字符型</h4><p>较短的文本：char、varchar</p>
<p>其他：</p>
<p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p>
<p>较长的文本：text、blob(较大的二进制)</p>
<p>特点：</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char    char(M)</td>
<td>最大的字符数，可以省略，默认为1</td>
<td>固定长度的字符</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td>varchar varchar(M)</td>
<td>最大的字符数，不可以省略</td>
<td>可变长度的字符</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody></table>
<p>若设置char为2时，插入的数据必须&lt;=2个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_float(</span><br><span class="line">	id INT,</span><br><span class="line">	name CHAR(2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into test_float</span><br><span class="line">-- VALUES(1,&apos;123&apos;); 	#插入123会报错</span><br><span class="line">VALUES(1,&apos;12&apos;);	-- 正确</span><br><span class="line"></span><br><span class="line">SELECT * from test_float;</span><br></pre></td></tr></table></figure>

<h4 id="5、Enum枚举类型"><a href="#5、Enum枚举类型" class="headerlink" title="5、Enum枚举类型"></a>5、Enum枚举类型</h4><p>要求插入的值必须属于列表中指定的值之一<br>如果列表成员为1-255，则需要1个字节存储。如果列表成员为255-65535，则需要2个字节存储。最多需要65535个成员！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_char(</span><br><span class="line">	c1 ENUM(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_char VALUES(&apos;a&apos;);</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;b&apos;);</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;c&apos;);</span><br><span class="line">-- INSERT INTO tab_char VALUES(&apos;m&apos;);	-- 插入错误</span><br><span class="line">INSERT INTO tab_char VALUES(&apos;A&apos;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_char;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>结果会将大写变成小写</p>
<p><img alt="1561014495446" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014495446.png" class="lazyload"></p>
<h4 id="6、set类型"><a href="#6、set类型" class="headerlink" title="6、set类型"></a>6、set类型</h4><p>和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_set(</span><br><span class="line">	s1 SET(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_set VALUES(&apos;a&apos;);</span><br><span class="line">INSERT INTO tab_set VALUES(&apos;A,B&apos;);</span><br><span class="line">INSERT INTO tab_set VALUES(&apos;a,c,d&apos;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>结果会将大写变成小写，存储多个数据<br><img alt="1561014348114" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014348114.png" class="lazyload"></p>
<h4 id="7、日期型"><a href="#7、日期型" class="headerlink" title="7、日期型"></a>7、日期型</h4><p><img alt="1561014587100" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014587100.png" class="lazyload"></p>
<p><img alt="1561014664165" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561014664165.png" class="lazyload"></p>
<h5 id="分类-9"><a href="#分类-9" class="headerlink" title="分类"></a>分类</h5><p>date只保存日期<br>time 只保存时间<br>year只保存年</p>
<p>datetime保存日期+时间<br>timestamp保存日期+时间</p>
<h5 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h5><table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th>时区等的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000——9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<h5 id="使用-19"><a href="#使用-19" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 TIMESTAMP</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_date VALUES(NOW(),NOW());</span><br><span class="line">SET time_zone=&apos;+9:00&apos;;	-- 修改时区</span><br><span class="line">SELECT * FROM tab_date;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><code>TIMESTAMP</code>收拾去影响</p>
<p><img alt="1561015012652" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561015012652.png" class="lazyload"></p>
<h3 id="6、常见约束"><a href="#6、常见约束" class="headerlink" title="6、常见约束"></a>6、常见约束</h3><h4 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h4><p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p>
<h4 id="分类-10"><a href="#分类-10" class="headerlink" title="分类"></a>分类</h4><p>六大约束</p>
<ul>
<li><p>NOT NULL：非空，用于保证该字段的值不能为空</p>
<p>  比如姓名、学号等</p>
</li>
<li><p>DEFAULT:默认，用于保证该字段有默认值</p>
<p>  比如性别</p>
</li>
<li><p>PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空</p>
<p>  比如学号、员工编号等</p>
</li>
<li><p>UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空</p>
<p>  比如座位号</p>
</li>
<li><p>CHECK:检查约束【mysql中不支持】</p>
<p>  比如年龄、性别</p>
</li>
<li><p>FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p>
<pre><code>在从表添加外键约束，用于引用主表中某列的值</code></pre><p>  比如学生表的专业编号，员工表的部门编号，员工表的工种编号</p>
</li>
</ul>
<p>添加约束的时机：</p>
<ul>
<li>创建表时</li>
<li>修改表时</li>
</ul>
<p>约束的添加分类：</p>
<ul>
<li><p>列级约束：六大约束语法上都支持，但外键约束没有效果</p>
</li>
<li><p>表级约束：除了非空、默认，其他的都支持</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型 列级约束,</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	表级约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>主键和唯一的大对比：</p>
<p>| |保证唯一性|  是否允许为空 |   一个表中可以有多少个  | 是否允许组合|<br>| —- | —- | —- | —- |<br>|主键|    √    |    ×    |    至多有1个      |     √，但不推荐|<br>|唯一|    √    |    √    |    可以有多个     |     √，但不推荐|<br>外键：<br>    1、要求在从表设置外键关系<br>    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>    3、主表的关联列必须是一个key（一般是主键或唯一）<br>    4、插入数据时，先插入主表，再插入从表。删除数据时，先删除从表，再删除主表</p>
<p>可以通过以下两种方式来删除主表的记录<br><strong>方式一：级联删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>
<p><strong>方式二：级联置空</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</span><br></pre></td></tr></table></figure>



<h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><p>修改表时添加或删除约束</p>
<p>1、非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加非空</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 not null;</span><br><span class="line">删除非空</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
<p>2、默认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加默认</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 default 值;</span><br><span class="line">删除默认</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
<p>3、主键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加主键</span><br><span class="line">alter table 表名 add【 constraint 约束名】 primary key(字段名);</span><br><span class="line">删除主键</span><br><span class="line">alter table 表名 drop primary key;</span><br></pre></td></tr></table></figure>
<p>4、唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加唯一</span><br><span class="line">alter table 表名 add【 constraint 约束名】 unique(字段名);</span><br><span class="line">删除唯一</span><br><span class="line">alter table 表名 drop index 索引名;</span><br></pre></td></tr></table></figure>
<p>5、外键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加外键</span><br><span class="line">alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;</span><br><span class="line">删除外键</span><br><span class="line">alter table 表名 drop foreign key 约束名;</span><br></pre></td></tr></table></figure>





<h4 id="使用-20"><a href="#使用-20" class="headerlink" title="使用"></a>使用</h4><h5 id="1、创建表时添加约束"><a href="#1、创建表时添加约束" class="headerlink" title="1、创建表时添加约束"></a>1、创建表时添加约束</h5><h6 id="1、添加列级约束"><a href="#1、添加列级约束" class="headerlink" title="1、添加列级约束"></a>1、添加列级约束</h6><p>直接在字段名和类型后面追加 约束类型即可。</p>
<p>只支持：默认、非空、主键、唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE students;</span><br><span class="line">DROP TABLE stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,#主键</span><br><span class="line">	stuName VARCHAR(20) NOT NULL UNIQUE,#非空</span><br><span class="line">    -- 检查	也可以用in,CHECK(gender in(&apos;男&apos;&apos;女&apos;))</span><br><span class="line">	gender CHAR(1) CHECK(gender=&apos;男&apos; OR gender =&apos;女&apos;),</span><br><span class="line">	seat INT UNIQUE,#唯一</span><br><span class="line">	age INT DEFAULT  18,#默认约束</span><br><span class="line">	majorId INT REFERENCES major(id)#外键</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE major(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	majorName VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<h6 id="2、添加表级约束"><a href="#2、添加表级约束" class="headerlink" title="2、添加表级约束"></a>2、添加表级约束</h6><p>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名) </p>
<p>约束名自己起，不支持非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT,</span><br><span class="line">	</span><br><span class="line">	CONSTRAINT pk PRIMARY KEY(id),#主键</span><br><span class="line">	CONSTRAINT uq UNIQUE(seat),#唯一键</span><br><span class="line">	CONSTRAINT ck CHECK(gender =&apos;男&apos; OR gender  = &apos;女&apos;),#检查</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<p>通用写法：</p>
<p>一般外键用表级约束写，其余的用列级约束写。外键的约束名<code>fk_表名1_表名2</code>，表示foreign key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	sex CHAR(1),</span><br><span class="line">	age INT DEFAULT 18,</span><br><span class="line">	seat INT UNIQUE,</span><br><span class="line">	majorid INT,</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>组合主键：</p>
<p>约束名(列名1，列名2，….)</p>
<h5 id="2、修改表时添加约束"><a href="#2、修改表时添加约束" class="headerlink" title="2、修改表时添加约束"></a>2、修改表时添加约束</h5><p><strong>1、添加列级约束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br></pre></td></tr></table></figure>
<p><strong>2、添加表级约束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br></pre></td></tr></table></figure>

<h6 id="使用-21"><a href="#使用-21" class="headerlink" title="使用"></a>使用</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT</span><br><span class="line">)</span><br><span class="line">DESC stuinfo;</span><br><span class="line">#1.添加非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;</span><br><span class="line">#2.添加默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;</span><br><span class="line">#3.添加主键</span><br><span class="line">#①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line">#②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD PRIMARY KEY(id);</span><br><span class="line"></span><br><span class="line">#4.添加唯一</span><br><span class="line"></span><br><span class="line">#①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</span><br><span class="line">#②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD UNIQUE(seat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.添加外键</span><br><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorId) REFERENCES major(majorid);</span><br></pre></td></tr></table></figure>



<h5 id="3、修改表时删除约束"><a href="#3、修改表时删除约束" class="headerlink" title="3、修改表时删除约束"></a>3、修改表时删除约束</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.删除非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</span><br><span class="line"></span><br><span class="line">#2.删除默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT ;</span><br><span class="line"></span><br><span class="line">#3.删除主键</span><br><span class="line">ALTER TABLE stuinfo DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">#4.删除唯一</span><br><span class="line">ALTER TABLE stuinfo DROP INDEX seat;</span><br><span class="line"></span><br><span class="line">#5.删除外键</span><br><span class="line">ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>



<h5 id="4、练习-2"><a href="#4、练习-2" class="headerlink" title="4、练习"></a>4、练习</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.向表emp2的id列中添加PRIMARY KEY约束（my_emp_id_pk）</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line">ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);</span><br><span class="line"></span><br><span class="line">#2.	向表dept2的id列中添加PRIMARY KEY约束（my_dept_id_pk）</span><br><span class="line"></span><br><span class="line">#3.	向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。</span><br><span class="line">ALTER TABLE emp2 ADD COLUMN dept_id INT;</span><br><span class="line">ALTER TABLE emp2 ADD CONSTRAINT fk_emp2_dept2 FOREIGN KEY(dept_id) REFERENCES dept2(id);</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th></th>
<th>位置</th>
<th>支持的约束类型</th>
<th>是否可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>所有列的下面</td>
<td>默认和非空不支持，其他支持</td>
<td>可以（主键没有效果）</td>
</tr>
</tbody></table>
<h3 id="7、标识列"><a href="#7、标识列" class="headerlink" title="7、标识列"></a>7、标识列</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>又称为自增长列，可以不用手动的插入值，系统提供默认的序列值</p>
<p><strong>mysql不能设置起始值，可以设置步长</strong></p>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型（INT、float、double）<br>4、标识列可以通过 <code>SET auto_increment_increment=3;</code>设置步长<br>可以通过 手动插入值，设置起始值</p>
<h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><h5 id="1、创建表时设置自增长列"><a href="#1、创建表时设置自增长列" class="headerlink" title="1、创建表时设置自增长列"></a>1、创建表时设置自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表(</span><br><span class="line">	字段名 字段类型 约束 auto_increment</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="2、修改表时设置自增长列"><a href="#2、修改表时设置自增长列" class="headerlink" title="2、修改表时设置自增长列"></a>2、修改表时设置自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束 auto_increment</span><br></pre></td></tr></table></figure>
<h5 id="3、删除自增长列"><a href="#3、删除自增长列" class="headerlink" title="3、删除自增长列"></a>3、删除自增长列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束</span><br></pre></td></tr></table></figure>

<h4 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS tab_identity;</span><br><span class="line">CREATE TABLE tab_identity(</span><br><span class="line">	id INT  ,</span><br><span class="line">	NAME FLOAT UNIQUE AUTO_INCREMENT,</span><br><span class="line">	seat INT </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">TRUNCATE TABLE tab_identity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_identity(id,NAME) VALUES(NULL,&apos;john&apos;);</span><br><span class="line">INSERT INTO tab_identity(NAME) VALUES(&apos;lucy&apos;);</span><br><span class="line">SELECT * FROM tab_identity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &apos;%auto_increment%&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET auto_increment_increment=3;	#设置步长</span><br></pre></td></tr></table></figure>













<h2 id="6、TCL语言学习"><a href="#6、TCL语言学习" class="headerlink" title="6、TCL语言学习"></a>6、TCL语言学习</h2><blockquote>
<p>Transaction Control Language —— 事务控制语言</p>
</blockquote>
<h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>​        在mysql中的数据用各种不同的技术存储在文件（或内存）中。通过<code>show engines；</code>来查看mysql支持的存储引擎。</p>
<p>​        在mysql中用的最多的存储引擎有：innodb，myisam,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>
<h4 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h4><p>1、原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>2、一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
<p>3、隔离性（Isolation）<br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>4、持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
<h3 id="2、事务的创建"><a href="#2、事务的创建" class="headerlink" title="2、事务的创建"></a>2、事务的创建</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</li>
</ul>
<p>delete from 表 where id =1;</p>
<ul>
<li>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用</li>
</ul>
<p>手动设置关闭事务<code>set autocommit=0;</code></p>
<p>使用<code>SHOW VARIABLES LIKE &#39;autocommit&#39;;</code>查看语句是否开启事务</p>
<h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤1：开启事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">start transaction;可选的</span><br><span class="line">步骤2：编写事务中的sql语句(select insert update delete)</span><br><span class="line">语句1;</span><br><span class="line">语句2;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">步骤3：结束事务</span><br><span class="line">commit;提交事务</span><br><span class="line">rollback;回滚事务</span><br></pre></td></tr></table></figure>



<h4 id="使用-22"><a href="#使用-22" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;#可以省略</span><br><span class="line">#编写一组事务的语句</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;张无忌&apos;;</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;赵敏&apos;;</span><br><span class="line"></span><br><span class="line">#结束事务	二选一</span><br><span class="line">ROLLBACK;</span><br><span class="line">#commit;</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

<h3 id="3、事务隔离级别"><a href="#3、事务隔离级别" class="headerlink" title="3、事务隔离级别"></a>3、事务隔离级别</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>​        对于同时运行的多个事务, 当这些事务访问<strong>数据库中相同的数据</strong>时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务T1, T2, <strong>T1 读取了已经被T2 更新但还没有被提交的字段</strong>. 之后, 若T2 回滚, T1读取的内容就是临时且无效的.</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后T2 在该表中插入了一些新的行. 之后, 如果T1 再次读取同一个表, 就会多出几行.</li>
</ul>
<p>​        <strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p>
<p>​        <strong>一个事务与其他事务隔离的程度称为隔离级别.</strong> 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.</p>
<h4 id="4-种事务隔离级别"><a href="#4-种事务隔离级别" class="headerlink" title="4 种事务隔离级别"></a>4 种事务隔离级别</h4><p>数据库提供的4 种事务隔离级别</p>
<p><img alt="1561098719029" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561098719029.png" class="lazyload"></p>
<p>​        Oracle 支持的2 种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED<br>​        Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>讲得很好<a href="https://www.bilibili.com/video/av49181542/?p=137" target="_blank" rel="noopener">https://www.bilibili.com/video/av49181542/?p=137</a></p>
<p>每启动一个mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量<code>@@tx_isolation</code>, 表示当前的事务隔离级别.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看当前隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line">设置当前mySQL 连接的隔离级别:</span><br><span class="line">set transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">设置数据库系统的全局的隔离级别:</span><br><span class="line"># set session|global transaction isolation level 隔离级别;</span><br><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>隔离级别，由上往下级别越来越高</p>
<p>x：不能避免    √：避免</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted:读未提交</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>read committed：读已提交</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>repeatable read：可重复读</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>serializable：串行化</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>mysql中默认 第三个隔离级别 repeatable read<br>oracle中默认第二个隔离级别 read committed</p>
<h3 id="4、savepoint"><a href="#4、savepoint" class="headerlink" title="4、savepoint"></a>4、savepoint</h3><p>用来回滚到某个保存点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id=25;</span><br><span class="line">SAVEPOINT a;#设置保存点</span><br><span class="line">DELETE FROM account WHERE id=28;</span><br><span class="line">ROLLBACK TO a;#回滚到保存点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

<h3 id="5、truncate和delete的区别"><a href="#5、truncate和delete的区别" class="headerlink" title="5、truncate和delete的区别"></a>5、truncate和delete的区别</h3><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>回滚之后数据还在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">DELETE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>



<h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>回滚之后数据不在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">TRUNCATE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>







<h2 id="7、视图"><a href="#7、视图" class="headerlink" title="7、视图"></a>7、视图</h2><h3 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h3><p>虚拟表，和普通表一样使用。mysql5.1版本出现的新特性，是通过表动态生成的数据。</p>
<p>比如：舞蹈班和普通班级的对比</p>
<p><strong>案例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：查询姓张的学生名和专业名</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.`majorid`= m.`id`</span><br><span class="line">WHERE s.`stuname` LIKE &apos;张%&apos;;</span><br><span class="line"></span><br><span class="line">-- ========================================================</span><br><span class="line">CREATE VIEW v1</span><br><span class="line">AS</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.`majorid`= m.`id`;</span><br><span class="line"></span><br><span class="line">-- 方便使用</span><br><span class="line">SELECT * FROM v1 WHERE stuname LIKE &apos;张%&apos;;</span><br></pre></td></tr></table></figure>


<p><strong>应用场景：</strong></p>
<ul>
<li><p>多个地方用到同样的查询结果</p>
</li>
<li><p>该查询结果使用的sql语句较复杂</p>
</li>
</ul>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><h4 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h4 id="使用-23"><a href="#使用-23" class="headerlink" title="使用"></a>使用</h4><p>1、查询姓名中包含a字符的员工名、部门名和工种信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#①创建</span><br><span class="line">CREATE VIEW myv1</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d ON e.department_id  = d.department_id</span><br><span class="line">JOIN jobs j ON j.job_id  = e.job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②使用</span><br><span class="line">SELECT * FROM myv1 WHERE last_name LIKE &apos;%a%&apos;;</span><br></pre></td></tr></table></figure>


<p>2、查询各部门的平均工资级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①创建视图查看每个部门的平均工资</span><br><span class="line">CREATE VIEW myv2</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#②使用</span><br><span class="line">SELECT myv2.`ag`,g.grade_level</span><br><span class="line">FROM myv2</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON myv2.`ag` BETWEEN g.`lowest_sal` AND g.`highest_sal`;</span><br></pre></td></tr></table></figure>


<p>3、询平均工资最低的部门信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br></pre></td></tr></table></figure>
<p>4、查询平均工资最低的部门名和工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT d.*,m.ag</span><br><span class="line">FROM myv3 m</span><br><span class="line">JOIN departments d</span><br><span class="line">ON m.`department_id`=d.`department_id`;</span><br></pre></td></tr></table></figure>

<h4 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW emp_v1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,salary,email</span><br><span class="line">FROM employees</span><br><span class="line">WHERE phone_number LIKE &apos;011%&apos;;</span><br><span class="line"></span><br><span class="line">#二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW emp_v2</span><br><span class="line">AS</span><br><span class="line">SELECT MAX(salary) mx_dep,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT d.*,m.mx_dep</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN emp_v2 m</span><br><span class="line">ON m.department_id = d.`department_id`;</span><br></pre></td></tr></table></figure>







<h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><h4 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h4><h5 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view  视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h5 id="使用-24"><a href="#使用-24" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM myv3 </span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure>

<h4 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h4><h5 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h5><p>类似表的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as </span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h5 id="使用-25"><a href="#使用-25" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure>



<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图名,视图名,...;</span><br><span class="line">DROP VIEW emp_v1,emp_v2,myv3;</span><br></pre></td></tr></table></figure>

<h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 方式一</span><br><span class="line">DESC myv3;</span><br><span class="line">-- 方式二</span><br><span class="line">SHOW CREATE VIEW myv3;</span><br></pre></td></tr></table></figure>



<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图中数据的增删改，和DML类似</p>
<p>对视图进行增删改，对应的原始表也会进行增删改，数据同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) &quot;annual salary&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">#1.插入</span><br><span class="line">INSERT INTO myv1 VALUES(&apos;张飞&apos;,&apos;zf@qq.com&apos;);</span><br><span class="line"></span><br><span class="line">#2.修改</span><br><span class="line">UPDATE myv1 SET last_name = &apos;张无忌&apos; WHERE last_name=&apos;张飞&apos;;</span><br><span class="line"></span><br><span class="line">#3.删除</span><br><span class="line">DELETE FROM myv1 WHERE last_name = &apos;张无忌&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>具备以下特点的视图不允许更新（基本上全部了）</strong><br>①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT MAX(salary) m,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">UPDATE myv1 SET m=9000 WHERE department_id=10;</span><br></pre></td></tr></table></figure>

<p>②常量视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv2</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT &apos;john&apos; NAME;</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv2;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">UPDATE myv2 SET NAME=&apos;lucy&apos;;</span><br></pre></td></tr></table></figure>




<p>③Select中包含子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资</span><br><span class="line">FROM departments;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line">UPDATE myv3 SET 最高工资=100000;</span><br></pre></td></tr></table></figure>

<p>④join</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv4</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d</span><br><span class="line">ON e.department_id  = d.department_id;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv4;</span><br><span class="line">UPDATE myv4 SET last_name  = &apos;张飞&apos; WHERE last_name=&apos;Whalen&apos;;</span><br><span class="line">INSERT INTO myv4 VALUES(&apos;陈真&apos;,&apos;xxxx&apos;);</span><br></pre></td></tr></table></figure>


<p>⑤from一个不能更新的视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv5</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line"></span><br><span class="line">SELECT * FROM myv5;</span><br><span class="line"></span><br><span class="line">UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;</span><br></pre></td></tr></table></figure>

<p>⑥where子句的子查询引用了from子句中的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv6</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,email,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN(</span><br><span class="line">	SELECT  manager_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE manager_id IS NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv6;</span><br><span class="line">UPDATE myv6 SET salary=10000 WHERE last_name = &apos;k_ing&apos;;</span><br></pre></td></tr></table></figure>





<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><h4 id="视图的好处"><a href="#视图的好处" class="headerlink" title="视图的好处"></a>视图的好处</h4><p>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>
<table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>是否实际占用物理空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>增删改查，只是一般不能增删改</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
<h2 id="8、变量"><a href="#8、变量" class="headerlink" title="8、变量"></a>8、变量</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>系统变量：全局变量、会话变量</p>
<p>自定义变量：用户变量、局部变量</p>
<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>说明：变量由系统定义，不是用户定义，属于服务器层面<br><span style="color:red"><strong>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别</strong></span><br>使用步骤：<br>1、查看所有系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show [global|session] variables;</span><br></pre></td></tr></table></figure>
<p>2、查看满足条件的部分系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show [global|session] variables like &apos;%char%&apos;;</span><br></pre></td></tr></table></figure>
<p>3、查看指定的系统变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@[global|session].系统变量名;</span><br></pre></td></tr></table></figure>
<p>4、为某个系统变量赋值<br>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set [global|session] 系统变量名=值;</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@[global|session].系统变量名=值;</span><br></pre></td></tr></table></figure>

<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">#②查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">#③查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line"></span><br><span class="line">#④为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit=0;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure>



<h4 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h4><p>作用域：针对于当前会话（连接）有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line"></span><br><span class="line">#②查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">#③查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line"></span><br><span class="line">#④为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation=&apos;read-uncommitted&apos;;</span><br><span class="line">SET SESSION tx_isolation=&apos;read-committed&apos;;</span><br></pre></td></tr></table></figure>



<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p>
<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>作用域：针对于当前会话（连接）有效，作用域同于会话变量</p>
<p><strong>应用在任何地方，也就是<code>begin</code> <code>end</code>里面/外面</strong></p>
<p>赋值操作符：<code>=</code>或<code>:=</code></p>
<p>①声明并初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set可以用两种方式</span><br><span class="line">SET @变量名=值;</span><br><span class="line">SET @变量名:=值;</span><br><span class="line"></span><br><span class="line">#select只能用:=</span><br><span class="line">SELECT @变量名:=值;</span><br></pre></td></tr></table></figure>

<p>②赋值（更新变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">	SET @变量名=值;</span><br><span class="line">	SET @变量名:=值;</span><br><span class="line">	SELECT @变量名:=值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO @变量名</span><br><span class="line">	FROM 表;</span><br></pre></td></tr></table></figure>

<p>③使用（查看变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @变量名;</span><br></pre></td></tr></table></figure>

<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、创建name变量赋值并打印</span><br><span class="line">set @name=&apos;john&apos;;</span><br><span class="line">set @name=100;</span><br><span class="line">select @name;</span><br><span class="line"></span><br><span class="line"># 2、创建count变量并将employees的总个数赋给ocunt后打印</span><br><span class="line">set @count=1;</span><br><span class="line">select COUNT(*) into @count</span><br><span class="line">from employees;</span><br><span class="line">SELECT @count;</span><br></pre></td></tr></table></figure>







<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>作用域：仅仅在定义它的begin end块中有效</p>
<p>应用在 begin end中的第一句话</p>
<p>使用步骤：<br>1、声明<br>2、赋值</p>
<p>①声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 类型;</span><br><span class="line">DECLARE 变量名 类型 【DEFAULT 值】;</span><br></pre></td></tr></table></figure>

<p>②赋值（更新变量的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">	SET 局部变量名=值;</span><br><span class="line">	SET 局部变量名:=值;</span><br><span class="line">	SELECT 局部变量名:=值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO 具备变量名</span><br><span class="line">	FROM 表;</span><br><span class="line">#③使用（查看变量的值）</span><br><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>用户变量和局部变量的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：声明两个变量，求和并打印</span><br><span class="line"></span><br><span class="line">#用户变量</span><br><span class="line">SET @m=1;</span><br><span class="line">SET @n=1;</span><br><span class="line">SET @sum=@m+@n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"></span><br><span class="line">#局部变量	会报错，没有放在begin end中</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 1;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line">SET SUM=m+n;</span><br><span class="line">SELECT SUM;</span><br></pre></td></tr></table></figure>







<h2 id="9、存储过程和函数"><a href="#9、存储过程和函数" class="headerlink" title="9、存储过程和函数"></a>9、存储过程和函数</h2><p>存储过程和函数：类似于java中的方法</p>
<p>好处：<br>1、提高代码的重用性<br>2、简化操作</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<h4 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(参数列表)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	存储过程体（一组合法的SQL语句）</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong><br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)</p>
<p>参数模式：<br>in：该参数可以作为输入，也就是该<strong>参数需要调用方传入值</strong><br>out：该参数可以作为输出，也就是该参数可以作为<strong>返回值</strong><br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p>
<p>2、如果存储过程体仅仅只有一句话，begin end可以省略(类似循环语句一句话省略括号)<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br><code>delimiter 结束标记</code><br>案例：<br><code>delimiter $</code></p>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(实参列表);</span><br></pre></td></tr></table></figure>



<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：drop procedure 存储过程名</span><br></pre></td></tr></table></figure>



<h5 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>





<h4 id="使用-26"><a href="#使用-26" class="headerlink" title="使用"></a>使用</h4><h5 id="1、空参列表"><a href="#1、空参列表" class="headerlink" title="1、空参列表"></a>1、空参列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：插入到admin表中五条记录</span><br><span class="line"></span><br><span class="line">SELECT * FROM admin;</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp1()</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO admin(username,`password`) </span><br><span class="line">	VALUES(&apos;john1&apos;,&apos;0000&apos;),(&apos;lily&apos;,&apos;0000&apos;),(&apos;rose&apos;,&apos;0000&apos;),(&apos;jack&apos;,&apos;0000&apos;),(&apos;tom&apos;,&apos;0000&apos;);</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#调用 navicat不加$</span><br><span class="line">CALL myp1()</span><br></pre></td></tr></table></figure>



<h5 id="2、带in模式参数"><a href="#2、带in模式参数" class="headerlink" title="2、带in模式参数"></a>2、带in模式参数</h5><p><strong>案例1：创建存储过程实现 根据女神名，查询对应的男神信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create PROCEDURE search(in girl_name VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	select b1.* ,b2.boyName</span><br><span class="line">	from beauty b1</span><br><span class="line">	join boys b2</span><br><span class="line">	on b1.boyfriend_id = b2.id</span><br><span class="line">	WHERE b1.`name` = girl_name;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call search(&apos;赵敏&apos;)</span><br></pre></td></tr></table></figure>



<p><strong>案例2 ：创建存储过程实现，用户是否登录成功</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE result INT DEFAULT 0;#声明并初始化</span><br><span class="line">	</span><br><span class="line">	SELECT COUNT(*) INTO result#赋值</span><br><span class="line">	FROM admin</span><br><span class="line">	WHERE admin.username = username</span><br><span class="line">	AND admin.password = PASSWORD;</span><br><span class="line">	</span><br><span class="line">	SELECT IF(result&gt;0,&apos;成功&apos;,&apos;失败&apos;);#使用</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp3(&apos;张飞&apos;,&apos;8888&apos;)</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img alt="1561429038620" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429038620.png" class="lazyload"><br><img alt="1561429053798" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429053798.png" class="lazyload"></p>
<h5 id="3、in-amp-out-模式参数"><a href="#3、in-amp-out-模式参数" class="headerlink" title="3、in &amp; out 模式参数"></a>3、in &amp; out 模式参数</h5><p><strong>案例1：根据输入的女神名，返回对应的男神名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create PROCEDURE search1(in girl_name VARCHAR(20) , out boy_name VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	select b2.boyName into boy_name</span><br><span class="line">	from beauty b1</span><br><span class="line">	join boys b2</span><br><span class="line">	on b1.boyfriend_id = b2.id</span><br><span class="line">	WHERE b1.`name` = girl_name;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call search1(&apos;赵敏&apos;,@boy_name)</span><br><span class="line">select @boy_name</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img alt="1561429397840" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561429397840.png" class="lazyload"></p>
<p><strong>案例2：根据输入的女神名，返回对应的男神名和魅力值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT boys.boyname ,boys.usercp INTO boyname,usercp</span><br><span class="line">	FROM boys </span><br><span class="line">	RIGHT JOIN</span><br><span class="line">	beauty b ON b.boyfriend_id = boys.id</span><br><span class="line">	WHERE b.name=beautyName ;</span><br><span class="line">	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp7(&apos;小昭&apos;,@name,@cp)$</span><br></pre></td></tr></table></figure>

<h5 id="4、inout模式参数"><a href="#4、inout模式参数" class="headerlink" title="4、inout模式参数"></a>4、inout模式参数</h5><p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SET a=a*2;</span><br><span class="line">	SET b=b*2;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">SET @m=10$</span><br><span class="line">SET @n=20$</span><br><span class="line">CALL myp8(@m,@n)$</span><br><span class="line">SELECT @m,@n$</span><br></pre></td></tr></table></figure>



<h4 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h4><p>1、创建存储过程实现传入用户名和密码，插入到admin表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO admin(admin.username,PASSWORD)</span><br><span class="line">	VALUES(username,loginpwd);</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>2、创建存储过程实现传入女神编号，返回女神名称和女神电话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">	SELECT b.name ,b.phone INTO NAME,phone</span><br><span class="line">	FROM beauty b</span><br><span class="line">	WHERE b.id = id;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>3、创建存储存储过程或函数实现传入两个女神生日，返回大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT DATEDIFF(birth1,birth2) INTO result;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>4、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT DATE_FORMAT(mydate,&apos;%y年%m月%d日&apos;) INTO strDate;</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro4(NOW(),@str)</span><br><span class="line">SELECT @str</span><br></pre></td></tr></table></figure>


<p>5、创建存储过程或函数实现传入女神名称，返回：女神 and 男神  格式的字符串<br>如 传入 ：小昭<br>返回： 小昭 AND 张无忌</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE test_pro5</span><br><span class="line">CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT CONCAT(beautyName,&apos; and &apos;,IFNULL(boyName,&apos;null&apos;)) INTO str</span><br><span class="line">	FROM boys bo</span><br><span class="line">	RIGHT JOIN beauty b ON b.boyfriend_id = bo.id</span><br><span class="line">	WHERE b.name=beautyName;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	SET str=</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro5(&apos;赵敏&apos;,@str)</span><br><span class="line">SELECT @str</span><br></pre></td></tr></table></figure>

<p><img alt="1561446772615" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561446772615.png" class="lazyload"></p>
<p>6、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE test_pro6</span><br><span class="line">CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT * FROM beauty LIMIT startIndex,size;</span><br><span class="line">END </span><br><span class="line"></span><br><span class="line">CALL test_pro6(3,5)</span><br></pre></td></tr></table></figure>



<p>7、删除存储过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE p1;</span><br><span class="line">DROP PROCEDURE p2,p3;#× 不支持多个删除</span><br></pre></td></tr></table></figure>


<p>8、查看存储过程的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>





<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<p>区别：</p>
<p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p>
<h4 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">	函数体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型</p>
<p>2.函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议</p>
<p>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记</p>
<h5 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(参数列表)</span><br></pre></td></tr></table></figure>



<h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION myf3;</span><br></pre></td></tr></table></figure>
<p>在mysql的proc表中会有创建的存储过程和函数<br><img alt="1561448603681" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561448603681.png" class="lazyload"></p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION myf3;</span><br></pre></td></tr></table></figure>



<h4 id="使用-27"><a href="#使用-27" class="headerlink" title="使用"></a>使用</h4><p>1、无参返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 案例1：返回公司的员工个数</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf1() <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">DECLARE</span> c <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;<span class="comment">#定义局部变量</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> c<span class="comment">#赋值</span></span><br><span class="line">	<span class="keyword">FROM</span> employees;</span><br><span class="line">	RETURN c;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf1()$</span><br></pre></td></tr></table></figure>



<p>2、有参返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例1：根据部门名，返回该部门的平均工资</span><br><span class="line">delimiter $</span><br><span class="line">CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	SET @sal=0;#定义用户变量 </span><br><span class="line">	SELECT salary INTO @sal   #赋值</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = empName;</span><br><span class="line">	</span><br><span class="line">	RETURN @sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf2(&apos;Kochhar&apos;) $</span><br><span class="line"></span><br><span class="line"># =============================================</span><br><span class="line"></span><br><span class="line">#案例2：根据部门名，返回该部门的平均工资</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE sal DOUBLE ;</span><br><span class="line">	SELECT AVG(salary) INTO sal</span><br><span class="line">	FROM employees e</span><br><span class="line">	JOIN departments d ON e.department_id = d.department_id</span><br><span class="line">	WHERE d.department_name=deptName;</span><br><span class="line">	RETURN sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf3(&apos;IT&apos;)$</span><br></pre></td></tr></table></figure>



<p>3、求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、创建函数，实现传入两个float，返回二者之和</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE SUM FLOAT DEFAULT 0;</span><br><span class="line">	SET SUM=num1+num2;</span><br><span class="line">	RETURN SUM;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT test_fun1(1,2)$</span><br></pre></td></tr></table></figure>









<h2 id="10、流程控制结构"><a href="#10、流程控制结构" class="headerlink" title="10、流程控制结构"></a>10、流程控制结构</h2><h3 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h3><h4 id="1、if结构"><a href="#1、if结构" class="headerlink" title="1、if结构"></a>1、if结构</h4><h5 id="if函数语法"><a href="#if函数语法" class="headerlink" title="if函数语法"></a>if函数语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件,值1，值2)</span><br></pre></td></tr></table></figure>

<p>如果条件成立，则if返回值1，否则返回值2</p>
<p>功能：实现简单的双分支，应用在任何地方</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @num = 0;</span><br><span class="line">SELECT if(@num,&apos;true&apos;,&apos;false&apos;);</span><br></pre></td></tr></table></figure>

<p><img alt="1561519881501" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519881501.png" class="lazyload"></p>
<h5 id="if结构语法"><a href="#if结构语法" class="headerlink" title="if结构语法"></a>if结构语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">....</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br><span class="line">功能：类似于多重if</span><br></pre></td></tr></table></figure>

<p>只能应用在begin end 中</p>
<h5 id="使用-28"><a href="#使用-28" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ch CHAR DEFAULT &apos;A&apos;;</span><br><span class="line">	IF score&gt;90 THEN SET ch=&apos;A&apos;;</span><br><span class="line">	ELSEIF score&gt;80 THEN SET ch=&apos;B&apos;;</span><br><span class="line">	ELSEIF score&gt;60 THEN SET ch=&apos;C&apos;;</span><br><span class="line">	ELSE SET ch=&apos;D&apos;;</span><br><span class="line">	END IF;</span><br><span class="line">	RETURN ch;</span><br><span class="line">END</span><br><span class="line">SELECT test_if(87)</span><br></pre></td></tr></table></figure>

<p><img alt="1561519907951" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519907951.png" class="lazyload"></p>
<h4 id="2、case结构"><a href="#2、case结构" class="headerlink" title="2、case结构"></a>2、case结构</h4><h5 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h5><p>情况1：类似于java中的switch，一般用于实现等值判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 变量|表达式</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end case</span><br></pre></td></tr></table></figure>



<p>情况2：类似于java中的多重if语句，一般用于实现区间判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end case</span><br></pre></td></tr></table></figure>



<h5 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h5><p>1、可以作为表达式，[嵌套在其他语句中使用](# 2、case函数)，可以放在任何地方，<code>BEGIN END</code>中或者<code>BEGIN END</code>的外面</p>
<p>2、可以作为独立的语句去使用，只能放在<code>BEGIN END</code>中</p>
<p>3、<code>ELSE</code>可以省略，如果<code>ELSE</code>省略了，并且所有<code>WHEN</code>条件都不满足，则返回NULL</p>
<h5 id="使用-29"><a href="#使用-29" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：创建函数，实现传入成绩，</span><br><span class="line">#如果成绩&gt;90,返回A，</span><br><span class="line">#如果成绩&gt;80,返回B，</span><br><span class="line">#如果成绩&gt;60,返回C，</span><br><span class="line">#否则返回D</span><br><span class="line"></span><br><span class="line">create PROCEDURE test_case(IN score INT)</span><br><span class="line">BEGIN</span><br><span class="line">	case </span><br><span class="line">	WHEN score&gt;=90 AND score &lt;= 100 THEN SELECT &apos;A&apos;;</span><br><span class="line">	WHEN score &gt;= 80 THEN SELECT &apos;B&apos;;</span><br><span class="line">	WHEN score &gt;= 60 THEN SELECT &apos;C&apos;; </span><br><span class="line">	ELSE SELECT &apos;D&apos;;</span><br><span class="line">	END CASE;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">call test_case(59)</span><br></pre></td></tr></table></figure>

<p><img alt="1561519331629" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1561519331629.png" class="lazyload"></p>
<h3 id="2、循环"><a href="#2、循环" class="headerlink" title="2、循环"></a>2、循环</h3><p>分类：<br>while、loop、repeat</p>
<p>循环控制：</p>
<p>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环</p>
<h4 id="1、while-使用较多"><a href="#1、while-使用较多" class="headerlink" title="1、while(使用较多)"></a>1、while(使用较多)</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[标签:] while 循环条件 do</span><br><span class="line">	循环体;</span><br><span class="line">end while [标签];</span><br></pre></td></tr></table></figure>



<h4 id="2、loop"><a href="#2、loop" class="headerlink" title="2、loop"></a>2、loop</h4><p>无条件死循环</p>
<h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【标签:】loop</span><br><span class="line">	循环体;</span><br><span class="line">end loop 【标签】;</span><br></pre></td></tr></table></figure>

<p>可以用来模拟简单的死循环</p>
<h4 id="3、repeat"><a href="#3、repeat" class="headerlink" title="3、repeat"></a>3、repeat</h4><p>类似java中的do…while…    先执行后判断</p>
<h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【标签：】repeat</span><br><span class="line">	循环体;</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat 【标签】;</span><br></pre></td></tr></table></figure>



<h4 id="使用-30"><a href="#使用-30" class="headerlink" title="使用"></a>使用</h4><p>1、没有添加循环控制语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录</span><br><span class="line"># 分开执行</span><br><span class="line">DROP PROCEDURE pro_while1</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	WHILE i&lt;=insertCount DO</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;Rose&apos;,i),&apos;666&apos;);</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">CALL pro_while1(100)</span><br></pre></td></tr></table></figure>



<p>2、添加leave语句</p>
<p>使用leave必须要对循环起一个别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止</span><br><span class="line">TRUNCATE TABLE admin</span><br><span class="line">DROP PROCEDURE test_while1</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line">		IF i&gt;=20 THEN LEAVE a;</span><br><span class="line">		END IF;</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE a;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure>

<p><img alt="1562207994395" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562207994395.png" class="lazyload"></p>
<p>3、添加iterate语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</span><br><span class="line">TRUNCATE TABLE admin</span><br><span class="line">DROP PROCEDURE test_while1</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		SET i=i+1;</span><br><span class="line">		IF MOD(i,2)!=0 THEN ITERATE a;</span><br><span class="line">		END IF;</span><br><span class="line">		</span><br><span class="line">		INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line">		</span><br><span class="line">	END WHILE a;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure>



<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>已知表stringcontent，向该表插入指定个数的，随机的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stringcontent;</span><br><span class="line">CREATE TABLE stringcontent(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	content VARCHAR(20)</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line">DELIMITER</span><br><span class="line">CREATE PROCEDURE test_randstr_insert(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	DECLARE str VARCHAR(26) DEFAULT &apos;abcdefghijklmnopqrstuvwxyz&apos;;</span><br><span class="line">	DECLARE startIndex INT;#代表初始索引</span><br><span class="line">	DECLARE len INT;#代表截取的字符长度</span><br><span class="line">	WHILE i&lt;=insertcount DO</span><br><span class="line">		SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26</span><br><span class="line">		SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）</span><br><span class="line">		INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));</span><br><span class="line">		SET i=i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">CALL test_randstr_insert(10)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高级教程</title>
    <url>/2019/12/12/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1、mysql架构介绍"><a href="#1、mysql架构介绍" class="headerlink" title="1、mysql架构介绍"></a>1、mysql架构介绍</h1><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><p><img alt="1562313619304" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562313619304.png" class="lazyload"></p>
<p>windows默认安装下</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>C:\ProgramData\MySQL\MySQL Server 5.7\Data</td>
<td>mysql数据库文件存放路径</td>
</tr>
<tr>
<td>C:\Program Files\MySQL\MySQL Server 5.7\bin</td>
<td>相关命令目录</td>
</tr>
</tbody></table>
<h2 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h2><table>
<thead>
<tr>
<th>系统</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>windows</td>
<td>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</td>
</tr>
<tr>
<td>linux</td>
<td>/etc/my.cnf</td>
</tr>
</tbody></table>
<p>主要配置文件</p>
<table>
<thead>
<tr>
<th>配置文件信息</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>二进制日志log-bin</td>
<td>主从复制</td>
</tr>
<tr>
<td>错误日志log-error</td>
<td>默认关闭，记录严重的警告和错误信息，每次启动和关闭的详细信息等</td>
</tr>
<tr>
<td>查询日志log</td>
<td>默认关闭，记录查询的sql语句，如果开启会降低mysql整体性能，消耗资源</td>
</tr>
<tr>
<td>数据文件</td>
<td>[数据文件](# 3、数据文件)</td>
</tr>
</tbody></table>
<h2 id="3、数据文件"><a href="#3、数据文件" class="headerlink" title="3、数据文件"></a>3、数据文件</h2><h3 id="采用MyISAM"><a href="#采用MyISAM" class="headerlink" title="采用MyISAM"></a>采用MyISAM</h3><p>创建表后会有相应的文件</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>frm</td>
<td>存放表结构</td>
</tr>
<tr>
<td>myd</td>
<td>存放表数据</td>
</tr>
<tr>
<td>myi</td>
<td>存放表索引</td>
</tr>
</tbody></table>
<h3 id="采用InnoDB"><a href="#采用InnoDB" class="headerlink" title="采用InnoDB"></a>采用InnoDB</h3><table>
<thead>
<tr>
<th>文件类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>frm</td>
<td>存放表结构</td>
</tr>
<tr>
<td>ibd</td>
<td>存放表数据和索引信息</td>
</tr>
<tr>
<td>myi</td>
<td>分区存储</td>
</tr>
</tbody></table>
<h2 id="4、逻辑架构"><a href="#4、逻辑架构" class="headerlink" title="4、逻辑架构"></a>4、逻辑架构</h2><p>连接层、 服务层、引擎层、存储层</p>
<p><img alt="1562465089529" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562465089529.png" class="lazyload"></p>
<p><img alt="1562547594658" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562547594658.png" class="lazyload"></p>
<h2 id="5、存储引擎"><a href="#5、存储引擎" class="headerlink" title="5、存储引擎"></a>5、存储引擎</h2><h3 id="1、查看命令"><a href="#1、查看命令" class="headerlink" title="1、查看命令"></a>1、查看命令</h3><p><img alt="1562468067667" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468067667.png" class="lazyload"></p>
<h3 id="2、两种存储引擎的对比"><a href="#2、两种存储引擎的对比" class="headerlink" title="2、两种存储引擎的对比"></a>2、两种存储引擎的对比</h3><p><img alt="1562468301820" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468301820.png" class="lazyload"></p>
<h3 id="3、阿里巴巴、淘宝用哪个"><a href="#3、阿里巴巴、淘宝用哪个" class="headerlink" title="3、阿里巴巴、淘宝用哪个"></a>3、阿里巴巴、淘宝用哪个</h3><p><img alt="1562468462939" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468462939.png" class="lazyload"></p>
<p><img alt="1562468505117" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562468505117.png" class="lazyload"></p>
<h1 id="2、索引优化分析"><a href="#2、索引优化分析" class="headerlink" title="2、索引优化分析"></a>2、索引优化分析</h1><h2 id="1、性能下降"><a href="#1、性能下降" class="headerlink" title="1、性能下降"></a>1、性能下降</h2><p>[1] 查询语句写的烂</p>
<p>[2] 索引失效（单值、复合）</p>
<p>单值索引：</p>
<p><img alt="1562482326220" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482326220.png" class="lazyload"></p>
<p>复合索引：</p>
<p><img alt="1562482346108" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482346108.png" class="lazyload"></p>
<p>[3] 关联查询太多join</p>
<p>[4] 服务器调优及各个参数设置（缓冲、线程数）</p>
<h2 id="2、常见通用的join查询"><a href="#2、常见通用的join查询" class="headerlink" title="2、常见通用的join查询"></a>2、常见通用的join查询</h2><h3 id="1、sql执行顺序"><a href="#1、sql执行顺序" class="headerlink" title="1、sql执行顺序"></a>1、sql执行顺序</h3><p>手写顺序</p>
<p><img alt="1562482436989" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482436989.png" class="lazyload"></p>
<p>机读顺序</p>
<p><img alt="1562482264884" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482264884.png" class="lazyload"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img alt="1562482505700" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562482505700.png" class="lazyload"></p>
<h3 id="2、7种join"><a href="#2、7种join" class="headerlink" title="2、7种join"></a>2、7种join</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img alt="1560566711450" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566711450.png" class="lazyload"></p>
<p><img alt="1560566734011" data-src="/images/MySQL%E5%9F%BA%E7%A1%80%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1560566734011.png" class="lazyload"></p>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create datebase db0629;</span><br><span class="line"></span><br><span class="line">create table tbl_dept(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	deptName VARCHAR(30) DEFAULT null,</span><br><span class="line">	locAdd VARCHAR(40) DEFAULT null,</span><br><span class="line">	PRIMARY KEY(id)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">create table tbl_emp(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(20) DEFAULT null,</span><br><span class="line">	deptId INT(41) DEFAULT null,</span><br><span class="line">	PRIMARY KEY(id),</span><br><span class="line">	KEY fk_dept_id(deptId)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;RD&apos;,11);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;HR&apos;,12);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;MK&apos;,13);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;MIS&apos;,14);</span><br><span class="line">insert into tbl_dept(deptName,locAdd) VALUES(&apos;FD&apos;,15);</span><br><span class="line"></span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;z3&apos;,1);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;z4&apos;,1);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;z5&apos;,1);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;w5&apos;,2);</span><br><span class="line">insert into tbl_emp(name,deptId) VALUES(&apos;w6&apos;,2);</span><br></pre></td></tr></table></figure>



<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p><img alt="1562551995856" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562551995856.png" class="lazyload"></p>
<h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><p><img alt="1562552028273" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552028273.png" class="lazyload"></p>
<h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><p><img alt="1562552050783" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552050783.png" class="lazyload"></p>
<h5 id="左连接——A独有"><a href="#左连接——A独有" class="headerlink" title="左连接——A独有"></a>左连接——A独有</h5><p><img alt="1562552241017" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552241017.png" class="lazyload"></p>
<h5 id="右连接——B独有"><a href="#右连接——B独有" class="headerlink" title="右连接——B独有"></a>右连接——B独有</h5><p><img alt="1562552415831" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552415831.png" class="lazyload"></p>
<p><img alt="1562552394162" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562552394162.png" class="lazyload"></p>
<h5 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h5><p>oracle支持、mysql不支持</p>
<p>那如何查询量表独有的数据，且能查询量表共有数据不重复，等同于全连接？</p>
<p>使用union联合查询<strong><em>（两表记录拼接）</em></strong>可以达到全连接的效果</p>
<p><strong>a,b表的共有 + a表独有 + b表独有</strong></p>
<p><img alt="1562553332405" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562553332405.png" class="lazyload"></p>
<p><strong>a，b表的独有</strong></p>
<p><img alt="1562553564573" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562553564573.png" class="lazyload"></p>
<h2 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>索引是帮助MySQL高效获取数据的数据结构</p>
<p><strong>本质：索引是一种数据结构</strong>     <strong>目的：提高查找效率</strong></p>
<p><span style="color:red">简单理解：排好序的快速查找数据结构</span></p>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><p><img alt="1562655186449" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562655186449.png" class="lazyload"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img alt="1562675915837" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562675915837.png" class="lazyload"></p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p>
<p><span style="color:red">我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构阻止的索引。</span>其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引，唯一索引默认都是使用B+数索引，统称索引。当然，除了B+数这种类型的索引之外，还有哈希索引（hash index）等</p>
<h3 id="2、优点"><a href="#2、优点" class="headerlink" title="2、优点"></a>2、优点</h3><p>【1】类似大学图书馆建数目索引，提高数据检索的效率，降低数据库的IO成本</p>
<p>【2】通过索引列队数据进行排序，降低数据排序的成本，降低CPU消耗</p>
<h3 id="3、缺点"><a href="#3、缺点" class="headerlink" title="3、缺点"></a>3、缺点</h3><p>【1】实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，索引索引列也是要占用空间的</p>
<p>【2】虽然索引大大提高查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete，因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后索引信息</p>
<p>【3】索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</p>
<h3 id="5、分类"><a href="#5、分类" class="headerlink" title="5、分类"></a>5、分类</h3><h4 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h4><p>即一个索引只包含单个列，一个表可以有多个单例索引</p>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列的值必须唯一，但允许有空值</p>
<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>即一个索引包含多个列</p>
<p>基本语法</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [unique] index indexName on mytable(columname(length))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter mytable add [unique] index [indexName] on (columnname(length))</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index [indexName] on mytable</span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from table_name</span><br></pre></td></tr></table></figure>

<h4 id="使用alter命令"><a href="#使用alter命令" class="headerlink" title="使用alter命令"></a>使用alter命令</h4><p><img alt="1562725302031" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725302031.png" class="lazyload"></p>
<h3 id="6、索引结构"><a href="#6、索引结构" class="headerlink" title="6、索引结构"></a>6、索引结构</h3><p><img alt="1562725375115" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725375115.png" class="lazyload"></p>
<p>常用的就是b树索引</p>
<p><img alt="1562726908900" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562726908900.png" class="lazyload"></p>
<h4 id="BTree索引（★★★）"><a href="#BTree索引（★★★）" class="headerlink" title="BTree索引（★★★）"></a>BTree索引（★★★）</h4><p><img alt="1562725618351" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725618351.png" class="lazyload"></p>
<p><img alt="1562725764061" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562725764061.png" class="lazyload"></p>
<p><img alt="1562726567948" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562726567948.png" class="lazyload"></p>
<h3 id="7、使用情况"><a href="#7、使用情况" class="headerlink" title="7、使用情况"></a>7、使用情况</h3><h4 id="需要创建索引情况"><a href="#需要创建索引情况" class="headerlink" title="需要创建索引情况"></a>需要创建索引情况</h4><p>[1] 主键自动建立唯一索引</p>
<p>[2] 频繁作为查询条件的字段应该创建索引</p>
<p>[3] 查询中与其他表关联的字段，外键关系建立索引</p>
<p>[4] 频繁更新的字段不适合创建索引</p>
<p><strong><em>原因：因为每次更新不单单是更新了记录还会更新索引</em></strong></p>
<p>[5] where条件里用不到的字段不创建索引</p>
<p>[6] 单键/组合索引的选择问题  （高并发下倾向创建组合索引）</p>
<p>[7] 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</p>
<p>[8] 查询中统计或分组字段</p>
<h4 id="不需要创建索引情况"><a href="#不需要创建索引情况" class="headerlink" title="不需要创建索引情况"></a>不需要创建索引情况</h4><p>[1]表记录太少（三百万以上）</p>
<p>[2]经常增删改的表</p>
<p><strong><em>原因：提高查询速度，同时却会降低更新表的速度，如对表进行insert、update、delete。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</em></strong></p>
<p>[3] 数据重复且分布均匀的表字段，因此应该只为经常查询和最经常排序的数据列建立索引。注意：如果每个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p>
<p><img alt="1562727970377" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562727970377.png" class="lazyload"></p>
<h2 id="4、性能分析"><a href="#4、性能分析" class="headerlink" title="4、性能分析"></a>4、性能分析</h2><h3 id="1、MySQL-Query-Optimizer"><a href="#1、MySQL-Query-Optimizer" class="headerlink" title="1、MySQL Query Optimizer"></a>1、MySQL Query Optimizer</h3><p><img alt="1562828303386" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562828303386.png" class="lazyload"></p>
<h3 id="2、MySQL常见瓶颈"><a href="#2、MySQL常见瓶颈" class="headerlink" title="2、MySQL常见瓶颈"></a>2、MySQL常见瓶颈</h3><p>CPU：CPU在饱和的时候一般发生在数据装入内存或磁盘上读取数据时候</p>
<p>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</p>
<p>服务器应届的性能瓶颈：top、free、iostat和vmstat来查看系统的性能状态</p>
<h3 id="3、EXPLAIN关键字"><a href="#3、EXPLAIN关键字" class="headerlink" title="3、EXPLAIN关键字"></a>3、EXPLAIN关键字</h3><h4 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>使用explain 关键字可以模拟优化器质性SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>两种方式查看信息</p>
<p>explain + sql语句      （横版）       或者        explain + sql语句 + \G   （竖版）</p>
<p><img alt="1563067896613" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563067896613.png" class="lazyload"></p>
<h4 id="2、用途"><a href="#2、用途" class="headerlink" title="2、用途"></a>2、用途</h4><p>[1] 表的读取顺序 (id)</p>
<p>[2] 数据读取操作的操作类型 (select_type)</p>
<p>[3] 哪些索引可以使用（possible_keys）</p>
<p>[4] 哪些索引被实际使用 (key)</p>
<p>[5] 表之间的引用 (ref)</p>
<p>[6] 每张表有多少行被优化器查询 (rows)</p>
<h4 id="3、各字段解释"><a href="#3、各字段解释" class="headerlink" title="3、各字段解释"></a>3、各字段解释</h4><p><img alt="1562832868456" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562832868456.png" class="lazyload"></p>
<h5 id="1、id-star-star-star"><a href="#1、id-star-star-star" class="headerlink" title="1、id(:star::star::star:)"></a>1、id(:star::star::star:)</h5><h6 id="1、id相同"><a href="#1、id相同" class="headerlink" title="1、id相同"></a>1、id相同</h6><p><strong><em>结论：id相同，执行顺序由上至下</em></strong></p>
<p><img alt="1562833260375" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562833260375.png" class="lazyload"></p>
<h6 id="2、id不同"><a href="#2、id不同" class="headerlink" title="2、id不同"></a>2、id不同</h6><p>id值越大，优先级越高，越先被执行</p>
<p><strong><em>结论：最里面先执行，执行完再执行外面</em></strong></p>
<p><img alt="1562834820380" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562834820380.png" class="lazyload"></p>
<h6 id="3、id相同-不同"><a href="#3、id相同-不同" class="headerlink" title="3、id相同+不同"></a>3、id相同+不同</h6><p><strong><em>结论：id不同，先执行id值高的；id相同，再按顺序执行</em></strong></p>
<p><img alt="1562835041054" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562835041054.png" class="lazyload"></p>
<h5 id="2、select-type"><a href="#2、select-type" class="headerlink" title="2、select_type"></a>2、select_type</h5><p>主要区别于普通查询、联合查询、子查询等的复杂查询</p>
<p><img alt="1562895858960" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562895858960.png" class="lazyload"></p>
<p><img alt="1562895997142" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562895997142.png" class="lazyload"></p>
<h5 id="3、table"><a href="#3、table" class="headerlink" title="3、table"></a>3、table</h5><p>显示着一行的数据是关于哪张表</p>
<h5 id="4、type-star-star-star"><a href="#4、type-star-star-star" class="headerlink" title="4、type(:star::star::star:)"></a>4、type(:star::star::star:)</h5><p><img alt="1562896400411" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562896400411.png" class="lazyload"></p>
<p><span style="color:red"><strong>从最好到最差依次为：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong></span></p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref</p>
<p><img alt="1562897176702" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562897176702.png" class="lazyload"></p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><p><strong><em>【 system、const 】</em></strong></p>
<p>单行单表查询速度最快</p>
<p><img alt="1562897990578" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562897990578.png" class="lazyload"></p>
<p><strong><em>【 eq_ref 】</em></strong></p>
<p><img alt="1562899162056" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562899162056.png" class="lazyload"></p>
<p><strong><em>【ref】</em></strong></p>
<p>非唯一索引扫描</p>
<p><img alt="1562899509488" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562899509488.png" class="lazyload"></p>
<p><strong><em>【range】</em></strong></p>
<p>范围查询比全表查询好一些</p>
<p><img alt="1562900172447" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562900172447.png" class="lazyload"></p>
<p><strong><em>【index】</em></strong></p>
<p>id主键索引，前提是id建了索引</p>
<p><img alt="1562900373895" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562900373895.png" class="lazyload"></p>
<p><strong><em>【ALL】</em></strong></p>
<p><img alt="1562900487021" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562900487021.png" class="lazyload"></p>
<h5 id="5、possible-keys、key-star-star-star"><a href="#5、possible-keys、key-star-star-star" class="headerlink" title="5、possible_keys、key(:star::star::star:)"></a>5、possible_keys、key(:star::star::star:)</h5><p><img alt="1562981774596" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562981774596.png" class="lazyload"></p>
<p><img alt="1562982024121" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982024121.png" class="lazyload"></p>
<p><span style="color:red"><strong>总结：possible_keys 理论上用了几个索引，key实际上用了几个索引</strong></span></p>
<h6 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h6><p><img alt="1562982431561" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982431561.png" class="lazyload"></p>
<p>理论上用primary和idx_t1两个索引，实际只用到idx_t1一个索引</p>
<h6 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h6><p><img alt="1562982549442" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982549442.png" class="lazyload"></p>
<p>如果查询的字段刚好和你创建的索引一致的话，理论上没有索引，单实际上用了创建的索引，如上图<code>idx_col1_col2</code>索引，比<code>select *.....</code>来得快，因为type是index，而不是all</p>
<h5 id="6、key-len"><a href="#6、key-len" class="headerlink" title="6、key_len"></a>6、key_len</h5><p><img alt="1562982931136" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562982931136.png" class="lazyload"></p>
<p><img alt="1562983569857" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562983569857.png" class="lazyload"></p>
<hr>
<p>【结论】：相同条件下查询，key_len越小越好，精度越小越好。精度高消耗大</p>
<h5 id="7、ref"><a href="#7、ref" class="headerlink" title="7、ref"></a>7、ref</h5><p><img alt="1562983818094" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562983818094.png" class="lazyload"></p>
<h6 id="举例1-1"><a href="#举例1-1" class="headerlink" title="举例1"></a>举例1</h6><p><img alt="1562984512712" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562984512712.png" class="lazyload"></p>
<p>t1先根据条件常量进行查询后，t1作为驱动表进行关联查询，ref中会显示test库中t1表里的id字段被使用</p>
<h6 id="举例2-1"><a href="#举例2-1" class="headerlink" title="举例2"></a>举例2</h6><p><img alt="1562984567264" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562984567264.png" class="lazyload"></p>
<p>t2作为驱动表进行全表扫描，然后根据连接条件，ref中显示t2表中使用的col1字段，以及<code>t1.col2=‘ac’</code>常量条件</p>
<hr>
<p>【总结】：如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p>
<h5 id="8、rows-star-star-star"><a href="#8、rows-star-star-star" class="headerlink" title="8、rows(:star::star::star:)"></a>8、rows(:star::star::star:)</h5><p><img alt="1562985248900" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562985248900.png" class="lazyload"></p>
<p><img alt="1562985581967" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1562985581967.png" class="lazyload"></p>
<h5 id="9、extra-star-star-star"><a href="#9、extra-star-star-star" class="headerlink" title="9、extra(:star::star::star:)"></a>9、extra(:star::star::star:)</h5><p>包含不合适在其他列中显示但十分重要的额外信息</p>
<p><img alt="2019-07-14_092733" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/2019-07-14_092733.png" class="lazyload"></p>
<h6 id="1、Using-filesort-star-star-star"><a href="#1、Using-filesort-star-star-star" class="headerlink" title="1、Using filesort(:star::star::star:)"></a>1、Using filesort(:star::star::star:)</h6><p><span style="color:red"><strong><em>评价：性能很差</em></strong></span></p>
<p><img alt="1563067624976" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563067624976.png" class="lazyload"></p>
<p><img alt="TIM截图20190714094047" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714094047.jpg" class="lazyload"></p>
<hr>
<p>【结论】：后者效率高，性能更加，前者另起炉灶，虽有索引，但没用到，用的文件排序</p>
<h6 id="2、Using-temporary-star-star-star"><a href="#2、Using-temporary-star-star-star" class="headerlink" title="2、Using temporary(:star::star::star:)"></a>2、Using temporary(:star::star::star:)</h6><p><span style="color:red"><strong><em>评价：比Using filesort更差</em></strong></span></p>
<p><img alt="TIM截图20190714095559" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714095559.jpg" class="lazyload"></p>
<p><img alt="TIM截图20190714144421" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714144421.jpg" class="lazyload"></p>
<h6 id="3、Using-index-star-star-star"><a href="#3、Using-index-star-star-star" class="headerlink" title="3、Using index(:star::star::star:)"></a>3、Using index(:star::star::star:)</h6><p><span style="color:red"><strong><em>评价：效率不错</em></strong></span></p>
<p><img alt="TIM截图20190714144950" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714144950.jpg" class="lazyload"></p>
<p><img alt="1563087112897" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563087112897.png" class="lazyload"></p>
<p><img alt="TIM截图20190714145552" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/TIM%E6%88%AA%E5%9B%BE20190714145552.jpg" class="lazyload"></p>
<p><img alt="1563087694241" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563087694241.png" class="lazyload"></p>
<h6 id="4、using-where"><a href="#4、using-where" class="headerlink" title="4、using where"></a>4、using where</h6><p>表明使用了where过滤</p>
<h6 id="5、using-join-buffer"><a href="#5、using-join-buffer" class="headerlink" title="5、using join buffer"></a>5、using join buffer</h6><p>使用连接缓存</p>
<h6 id="6、impossible-where"><a href="#6、impossible-where" class="headerlink" title="6、impossible where"></a>6、impossible where</h6><p>where子句的值总是false，不能用来获取任何元组</p>
<p><img alt="1563088478530" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563088478530.png" class="lazyload"></p>
<h6 id="7、select-tables-optimized-away"><a href="#7、select-tables-optimized-away" class="headerlink" title="7、select tables optimized away"></a>7、select tables optimized away</h6><p><img alt="1563088501273" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563088501273.png" class="lazyload"></p>
<h6 id="8、distinct"><a href="#8、distinct" class="headerlink" title="8、distinct"></a>8、distinct</h6><p><img alt="1563088527305" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563088527305.png" class="lazyload"></p>
<h3 id="4、热身案例"><a href="#4、热身案例" class="headerlink" title="4、热身案例"></a>4、热身案例</h3><p><img alt="1563089145085" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563089145085.png" class="lazyload"></p>
<p><img alt="1563089331442" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563089331442.png" class="lazyload"></p>
<h2 id="5、索引优化"><a href="#5、索引优化" class="headerlink" title="5、索引优化"></a>5、索引优化</h2><h3 id="1、索引分析"><a href="#1、索引分析" class="headerlink" title="1、索引分析"></a>1、索引分析</h3><h4 id="1、单表"><a href="#1、单表" class="headerlink" title="1、单表"></a>1、单表</h4><h5 id="建立SQL"><a href="#建立SQL" class="headerlink" title="建立SQL"></a>建立SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">author_id INT(10) UNSIGNED NOT NULL,</span><br><span class="line">category_id INT(10) UNSIGNED NOT NULL,</span><br><span class="line">views INT(10) UNSIGNED NOT NULL,</span><br><span class="line">comments INT(10) UNSIGNED NOT NULL, </span><br><span class="line">title VARBINARY(255) NOT NULL, </span><br><span class="line">content TEXT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO article(author_id, category_id, views, comments, title, content) VALUES </span><br><span class="line">(1, 1,1,1, &apos;1&apos;,&apos;1&apos;),</span><br><span class="line">(2, 2, 2, 2,&apos;2&apos;,&apos;2&apos;),</span><br><span class="line">(1, 1,3, 3,&apos;3&apos;,&apos;3&apos;);</span><br></pre></td></tr></table></figure>



<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><blockquote>
<p>查询category_id为1且comments大于1的情况下，views最多的article_id</p>
</blockquote>
<p><strong>步骤：</strong></p>
<p><strong>[1]首先 编写sql语句</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">SELECT id,author_id</span><br><span class="line">FROM article</span><br><span class="line">WHERE category_id = 1 AND comments &gt; 1</span><br><span class="line">ORDER BY views</span><br><span class="line">DESC LIMIT 1;</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<p><img alt="1563091204680" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091204680.png" class="lazyload"></p>
<hr>
<p>结论，很显然，type是ALL，即最坏的情况，Extra里还出现了using filesort，也是最坏的情况，必须优化</p>
<p><strong>[2] 建立索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_article_ccv on article(category_id,comments,views);</span><br><span class="line">#查看</span><br><span class="line">show index from article;</span><br></pre></td></tr></table></figure>

<p><img alt="1563091372030" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091372030.png" class="lazyload"></p>
<p><strong>[3] explain分析</strong></p>
<p><img alt="1563091420110" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091420110.png" class="lazyload"></p>
<hr>
<p>结果发现，type变成了range，可以忍受，但是Extra里还出现了using filesort是无法接受的</p>
<p><strong>继续优化！！！</strong></p>
<p><strong>【4】置换条件分析</strong></p>
<p>与 <code>comment = 1</code>条件进行比对</p>
<p><img alt="1563091537358" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091537358.png" class="lazyload"></p>
<p>发现性能变好了，type变成ref，extra也没有using filesort</p>
<hr>
<p>得出结论：范围条件可能会导致索引失效，用不上后面的索引，就好比建了个三层楼，告诉你101、202、3楼挨个搜，用不上后面的索引了</p>
<p><img alt="1563091821021" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563091821021.png" class="lazyload"></p>
<p><strong>【5】重新建立索引</strong></p>
<p>鉴于上面的范围问题，采取绕过范围字段，将category_id和views建立索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除索引</span><br><span class="line">DROP INDEX idx_article_ccv on article;</span><br><span class="line">#重建索引</span><br><span class="line">CREATE INDEX idx_article_ccv on article(category_id,views);</span><br></pre></td></tr></table></figure>



<p><strong>【6】explain继续查看结果</strong></p>
<p><img alt="1563103971539" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563103971539.png" class="lazyload"></p>
<hr>
<p>可以看到，type变成ref，ectra中的using filesort也消失了，结果非常理想</p>
<h4 id="2、两表"><a href="#2、两表" class="headerlink" title="2、两表"></a>2、两表</h4><h5 id="建立SQL-1"><a href="#建立SQL-1" class="headerlink" title="建立SQL"></a>建立SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS class(</span><br><span class="line">	id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS book(</span><br><span class="line">	bookid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY(bookid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br></pre></td></tr></table></figure>







<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><blockquote>
<p>左连接两表查询所有记录</p>
</blockquote>
<p><strong>步骤：</strong></p>
<p>【1】首先explain分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#分析</span><br><span class="line">explain </span><br><span class="line">#左：class  右：book</span><br><span class="line">select * from class left join book on class.card = book.card;</span><br></pre></td></tr></table></figure>

<p><img alt="1563173355156" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173355156.png" class="lazyload"></p>
<hr>
<p>结果很糟糕</p>
<p>【2】右表加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1] 试试右表索引  </span><br><span class="line">ALTER TABLE book add INDEX Y(card);</span><br></pre></td></tr></table></figure>

<p>继续explain分析，结果如下</p>
<p><img alt="1563173439652" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173439652.png" class="lazyload"></p>
<hr>
<p>结果发现一个all一个ref，总共rows 21行，不错</p>
<p>【3】试试左表加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除</span><br><span class="line">drop index Y on book;</span><br><span class="line">#[2] 试试左表索引  </span><br><span class="line">ALTER TABLE class add INDEX Y(card);</span><br></pre></td></tr></table></figure>

<p>继续explain分析，结果如下</p>
<p><img alt="1563173520464" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173520464.png" class="lazyload"></p>
<hr>
<p>结果发现，一个是index一个all，index的性能没有ref好，而且rows总共40行，还有extra出现连接缓存</p>
<p>【结论】：这是由左连接的特性决定的。</p>
<p><img alt="1563173986234" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563173986234.png" class="lazyload"></p>
<p><code>LEFT JOIN</code>条件用于确定如何从右表搜索行，左边一定都有，所以右边是我们的关键点，一定要建立索引。左边是需要全部扫描的，而右边部分扫描，用索引更好。</p>
<p><strong>:star::star::star:右连接同理，索引加载左表上！！！:star::star::star:</strong></p>
<h4 id="3、三表"><a href="#3、三表" class="headerlink" title="3、三表"></a>3、三表</h4><h5 id="建立SQL-2"><a href="#建立SQL-2" class="headerlink" title="建立SQL"></a>建立SQL</h5><p>在两表的基础上加一个phone表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS phone(</span><br><span class="line">	phoneid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY(phoneid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br></pre></td></tr></table></figure>





<h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><blockquote>
<p>三表查询</p>
</blockquote>
<p><strong>步骤：</strong></p>
<p>【1】explain分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#三表查询</span><br><span class="line">explain</span><br><span class="line">select * </span><br><span class="line">from class</span><br><span class="line">LEFT JOIN book</span><br><span class="line">on class.card = book.card</span><br><span class="line">LEFT JOIN phone</span><br><span class="line">on book.card = phone.card</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1563175244554" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175244554.png" class="lazyload"></p>
<hr>
<p>继续优化</p>
<p>【2】添加索引</p>
<p>在book和phone上添加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y(card);</span><br><span class="line">ALTER TABLE phone ADD INDEX Y(card);</span><br></pre></td></tr></table></figure>

<p>继续explain分析</p>
<p><img alt="1563175355033" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175355033.png" class="lazyload"></p>
<hr>
<p>效果很好</p>
<p><img alt="1563175407152" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175407152.png" class="lazyload"></p>
<p>【结论】</p>
<p><img alt="1563175553954" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563175553954.png" class="lazyload"></p>
<h3 id="2、索引失效（应该避免）"><a href="#2、索引失效（应该避免）" class="headerlink" title="2、索引失效（应该避免）"></a>2、索引失效（应该避免）</h3><h4 id="索引失效10种原因"><a href="#索引失效10种原因" class="headerlink" title="索引失效10种原因"></a>索引失效10种原因</h4><p><img alt="1563239560954" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563239560954.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-1"><a href="#案例分析——索引优化No-1" class="headerlink" title="案例分析——索引优化No.1"></a>案例分析——索引优化No.1</h4><h5 id="建立sql"><a href="#建立sql" class="headerlink" title="建立sql"></a>建立sql</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table staffs(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(24) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;姓名&apos;,</span><br><span class="line">	age INT NOT NULL DEFAULT 0 COMMENT &apos;年龄&apos;,</span><br><span class="line">	pos VARCHAR(20) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;职位&apos;, </span><br><span class="line">  add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;入职时间&apos;</span><br><span class="line">)CHARSET UTF8 COMMENT &apos;员工记录表&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&apos;Z3&apos;,22,&apos;MANAGER&apos;,NOW());</span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&apos;july&apos;,23,&apos;dev&apos;,NOW());</span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&apos;2000&apos;,23,&apos;dev&apos;,NOW());</span><br><span class="line"></span><br><span class="line">SELECT * from staffs;</span><br><span class="line"></span><br><span class="line">ALTER TABLE staffs add INDEX idx_nameAgePos(name,age,pos);</span><br></pre></td></tr></table></figure>



<h5 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h5><p>【1】顺序列</p>
<p><code>name</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where NAME = &apos;july&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240271179" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240271179.png" class="lazyload"></p>
<p>可以用到索引</p>
<p><code>name-&gt;age</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where NAME = &apos;july&apos; AND age = 23;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240319660" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240319660.png" class="lazyload"></p>
<p>也用到了索引</p>
<p><code>x-&gt;age-&gt;pos</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where age = 23 AND pos = &apos;dev&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240366826" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240366826.png" class="lazyload"></p>
<p>没有用到索引</p>
<p><code>x-&gt;x-&gt;pos</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain SELECT * from staffs where pos = &apos;dev&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563240405842" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240405842.png" class="lazyload"></p>
<p>也没有用到索引</p>
<p>【2】跳过中间列</p>
<p><code>name-&gt;age</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">SELECT *</span><br><span class="line">from staffs</span><br><span class="line">where NAME = &apos;july&apos; AND age = 23;</span><br></pre></td></tr></table></figure>

<p><img alt="1563241015553" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563241015553.png" class="lazyload"></p>
<p><code>name-&gt;x-&gt;pos</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">SELECT *</span><br><span class="line">from staffs</span><br><span class="line">where NAME = &apos;july&apos; AND pos = &apos;dev&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563241040433" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563241040433.png" class="lazyload"></p>
<p>发现跳过列依然用了索引，但不是全值匹配，而是部分匹配，<span style="color:red"><strong>违背了最佳左前缀法则</strong></span></p>
<hr>
<p>【结论】：</p>
<p><img alt="1563240461985" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563240461985.png" class="lazyload"></p>
<p>必须要从头开始，也就是name开始。建索引的第一个字段不能丢失</p>
<h4 id="案例分析——索引优化No-2"><a href="#案例分析——索引优化No-2" class="headerlink" title="案例分析——索引优化No.2"></a>案例分析——索引优化No.2</h4><p><img alt="1563263040242" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263040242.png" class="lazyload"></p>
<p>如下sql语句分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from staffs</span><br><span class="line">where left(name,4) = &apos;july&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563263085387" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263085387.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from staffs</span><br><span class="line">where name = &apos;july&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563263104778" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263104778.png" class="lazyload"></p>
<hr>
<p>【结论】：使用函数会索引失效，因此不在索引上做任何操作，任何不精确的操作都会出现这个问题</p>
<h4 id="案例分析——索引优化No-3"><a href="#案例分析——索引优化No-3" class="headerlink" title="案例分析——索引优化No.3"></a>案例分析——索引优化No.3</h4><p>在有索引（name-&gt;age-&gt;pos）的前提下，查询条件出现范围后，则其右边的列就会发生索引失效</p>
<p><img alt="1563263710916" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563263710916.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-4"><a href="#案例分析——索引优化No-4" class="headerlink" title="案例分析——索引优化No.4"></a>案例分析——索引优化No.4</h4><p><img alt="1563264353622" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264353622.png" class="lazyload"></p>
<p><img alt="1563264607421" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264607421.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-5"><a href="#案例分析——索引优化No-5" class="headerlink" title="案例分析——索引优化No.5"></a>案例分析——索引优化No.5</h4><p><img alt="1563264847779" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264847779.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-6"><a href="#案例分析——索引优化No-6" class="headerlink" title="案例分析——索引优化No.6"></a>案例分析——索引优化No.6</h4><p><img alt="1563264973202" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563264973202.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-7"><a href="#案例分析——索引优化No-7" class="headerlink" title="案例分析——索引优化No.7"></a>案例分析——索引优化No.7</h4><p><img alt="1563265240788" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563265240788.png" class="lazyload"></p>
<hr>
<h5 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h5><blockquote>
<p><strong>解决like ‘%字符串%’时索引不被使用的方法？</strong></p>
<p><span style="color:red"><strong>解答：使用覆盖索引 ，查询的字段包含在建立的索引中，且查询的条件字段在索引的起始位置，比如对name进行like，则索引需建立name,email,…(最佳作前缀法则)</strong></span></p>
</blockquote>
<p>【步骤】</p>
<p>【1】建立sql准备数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tbl_user(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(20) DEFAULT NULL,</span><br><span class="line">	age INT(11) DEFAULT NULL,</span><br><span class="line">	email VARCHAR(20) DEFAULT NULL,</span><br><span class="line">	PRIMARY KEY(id)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=UTF8;</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;1aa1&apos;,21,&apos;b@163.com&apos;);</span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;2aa2&apos;,222,&apos;a@163.com&apos;);</span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;3aa3&apos;,265,&apos;c@163.com&apos;);</span><br><span class="line">INSERT INTO tbl_user(NAME,age,email) VALUES(&apos;4aa4&apos;,21,&apos;d@163.com&apos;);</span><br></pre></td></tr></table></figure>



<p>【2】建立索引前explain分析</p>
<p><img alt="1563267108055" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563267108055.png" class="lazyload"></p>
<p><img alt="1563267139590" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563267139590.png" class="lazyload"></p>
<p>以上结果的type都是all，其他sql自行验证</p>
<p>【3】建立索引后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_user_nameAge on tbl_user(name,age);</span><br><span class="line"></span><br><span class="line"># [1] select name,age</span><br><span class="line">explain </span><br><span class="line">select name,age from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563267989874" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563267989874.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># [2] select id</span><br><span class="line">explain </span><br><span class="line">select id from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563268014989" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563268014989.png" class="lazyload"></p>
<p><strong><em>由于id本身为主键，主键自带了主键索引，算是查询的索引字段的默认第一个</em></strong></p>
<p>以此类推,age、id,name、id,name,age、name,age一样type都是index</p>
<p><img alt="1563268439669" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563268439669.png" class="lazyload"></p>
<p>但是select *依然失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">select * from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563268477978" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563268477978.png" class="lazyload"></p>
<p>多了email的字段也会失效，超出了索引字段的范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">select id,name,age,email from tbl_user</span><br><span class="line">WHERE name like &apos;%aa%&apos;;</span><br></pre></td></tr></table></figure>



<h4 id="案例分析——索引优化No-8"><a href="#案例分析——索引优化No-8" class="headerlink" title="案例分析——索引优化No.8"></a>案例分析——索引优化No.8</h4><p><img alt="1563327288205" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327288205.png" class="lazyload"></p>
<p>不加单引号，会引起数据类型的转换而导致全表扫描（索引失效10大原因中的第3个）</p>
<p><img alt="1563327358493" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327358493.png" class="lazyload"></p>
<p><img alt="字符串单引号" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%95%E5%BC%95%E5%8F%B7.png" class="lazyload"></p>
<h4 id="案例分析——索引优化No-9"><a href="#案例分析——索引优化No-9" class="headerlink" title="案例分析——索引优化No.9"></a>案例分析——索引优化No.9</h4><p><img alt="1563327458510" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327458510.png" class="lazyload"></p>
<p><img alt="1563327583485" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327583485.png" class="lazyload"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img alt="1563327838950" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563327838950.png" class="lazyload"></p>
<h3 id="3、面试题讲解"><a href="#3、面试题讲解" class="headerlink" title="3、面试题讲解"></a>3、面试题讲解</h3><h4 id="题目sql"><a href="#题目sql" class="headerlink" title="题目sql"></a>题目sql</h4><h5 id="1、建表SQL"><a href="#1、建表SQL" class="headerlink" title="1、建表SQL"></a>1、建表SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test03(</span><br><span class="line">	id INT PRIMARY KEY not null auto_increment,</span><br><span class="line">	c1 char(10),</span><br><span class="line">	c2 char(10),</span><br><span class="line">	c3 char(10),</span><br><span class="line">	c4 char(10),</span><br><span class="line">	c5 char(10)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;a1&apos;,&apos;a2&apos;,&apos;a3&apos;,&apos;a4&apos;,&apos;a5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;b1&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;b4&apos;,&apos;b5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;,&apos;c4&apos;,&apos;c5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;d1&apos;,&apos;d2&apos;,&apos;d3&apos;,&apos;d4&apos;,&apos;d5&apos;);</span><br><span class="line">INSERT INTO test03(c1,c2,c3,c4,c5) values(&apos;e1&apos;,&apos;e2&apos;,&apos;e3&apos;,&apos;e4&apos;,&apos;e5&apos;);</span><br></pre></td></tr></table></figure>



<h5 id="2、建索引"><a href="#2、建索引" class="headerlink" title="2、建索引"></a>2、建索引</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_c1234 on test03(c1,c2,c3,c4);</span><br><span class="line">show index from test03;</span><br></pre></td></tr></table></figure>



<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>创建了复合索引idx_c1234，根据以下SQL分析索引使用情况</p>
</blockquote>
<h5 id="情况1-——-顺序"><a href="#情况1-——-顺序" class="headerlink" title="情况1 —— 顺序"></a>情况1 —— 顺序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos;;</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos;;</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3=&apos;a3&apos;;</span><br><span class="line"></span><br><span class="line"># 全值匹配</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3=&apos;a3&apos; and c4=&apos;a4&apos;;</span><br></pre></td></tr></table></figure>

<p>都能用到索引</p>
<h5 id="情况2-——乱序"><a href="#情况2-——乱序" class="headerlink" title="情况2 ——乱序"></a>情况2 ——乱序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3=&apos;a3&apos; and c4=&apos;a4&apos;;</span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c4=&apos;a4&apos; and c3=&apos;a3&apos;;</span><br><span class="line">#[3]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c3=&apos;a3&apos; and c2=&apos;a2&apos; and c4=&apos;a4&apos;;</span><br><span class="line">#[4]</span><br><span class="line">explain select * from test03 where c2=&apos;a2&apos; and c1=&apos;a1&apos; and c3=&apos;a3&apos; and c4=&apos;a4&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563330445298" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563330445298.png" class="lazyload"></p>
<p>后面两个字段颠倒  两种情况都能使用索引</p>
<p><strong>【结论】：只要带头大哥不死，后面兄弟还在，即便乱序了，mysql会自己调整顺序都会使用索引，但是尽量按照索引的顺序来，效率比较高。如果兄弟断了，那么就只用到截断前的几个字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c4=&apos;a4&apos; and c3=&apos;a3&apos; and c2=&apos;a2&apos; and c1=&apos;a1&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563330619617" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563330619617.png" class="lazyload"></p>
<p>顺序反过来依然能用到建立的索引，<strong>原因在于mysql本有带有优化器，会对sql语句进行分析优化</strong>，比如1+2+3和3+2+1是一样的</p>
<h5 id="情况3-——-范围"><a href="#情况3-——-范围" class="headerlink" title="情况3 —— 范围"></a>情况3 —— 范围</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c3&gt;&apos;a3&apos; and c4=&apos;a4&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563331432697" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563331432697.png" class="lazyload"></p>
<p>c1和c2用上了索引，从c3开始就是range了，c4就没法使用索引了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c4&gt;&apos;a4&apos; and c3=&apos;a3&apos;;</span><br></pre></td></tr></table></figure>

<p>换了个顺序，c1、c2、c3、c4都是用了索引，<strong>mysql会自己调整顺序</strong>，c4被调整到了最后</p>
<h5 id="情况4-——-orderby顺序"><a href="#情况4-——-orderby顺序" class="headerlink" title="情况4 —— orderby顺序"></a>情况4 —— orderby顺序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c4&gt;&apos;a4&apos; </span><br><span class="line">order by c3;</span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; </span><br><span class="line">order by c3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563332191847" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563332191847.png" class="lazyload"></p>
<p><img alt="1563332352149" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563332352149.png" class="lazyload"></p>
<p><strong><em>【建立索引就是为了 查询 和 排序 】</em></strong></p>
<p>[1]   c1、c2使用到了索引，用于查询，c3其实也用到了索引，只不过用在了排序上。</p>
<p>[2] 结果一样，和c4无关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; </span><br><span class="line">order by c4;</span><br></pre></td></tr></table></figure>

<p><img alt="1563332505495" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563332505495.png" class="lazyload"></p>
<p>c1、c2使用了索引，用于查询，但是中间兄弟断了，mysql无法根据我建立的索引进行排序，只能<strong>另起炉灶对c4使用文件排序(using filesort)</strong>，性能下降</p>
<h5 id="情况5-——-orderby乱序"><a href="#情况5-——-orderby乱序" class="headerlink" title="情况5 —— orderby乱序"></a>情况5 —— orderby乱序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c2,c3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563333288174" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563333288174.png" class="lazyload"></p>
<p>c1使用到了索引进行查询，c2和c3也用到部分索引进行排序，<strong>没有using filesort</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c3,c2;</span><br></pre></td></tr></table></figure>

<p><img alt="1563333462648" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563333462648.png" class="lazyload"></p>
<p>和之前对比，发现order by顺序反了，<strong>会有using filesort</strong></p>
<h5 id="情况6-——-orderby-常量乱序"><a href="#情况6-——-orderby-常量乱序" class="headerlink" title="情况6 —— orderby 常量乱序"></a>情况6 —— orderby 常量乱序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; </span><br><span class="line">order by c2,c3;</span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c2,c3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563333682639" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563333682639.png" class="lazyload"></p>
<p>结果一样 ，c1、c2两个字段的索引，但c2、c3用于排序，<strong>没有using filesort</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c2=&apos;a2&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c3,c2;</span><br><span class="line"></span><br><span class="line">#[2]</span><br><span class="line">explain select * from test03 where c1=&apos;a1&apos; and c5=&apos;a5&apos; </span><br><span class="line">order by c3,c2;</span><br></pre></td></tr></table></figure>

<p><img alt="1563334094031" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563334094031.png" class="lazyload"></p>
<p><strong>原因：</strong></p>
<p><strong><em>一般情况下order by后面不按顺序会出现using filesort</em></strong></p>
<p>但是 [1]中c2 在where里已经是一个常量了，放在order by 后面也是一个常量，相当于<code>order by &#39;a2&#39; , c3</code> ，只用对c3进行排序即可，不会出现using filesort    ，而[2] 会出现using filesort</p>
<h5 id="情况7-——-groupby"><a href="#情况7-——-groupby" class="headerlink" title="情况7 —— groupby"></a>情况7 —— groupby</h5><p><img alt="1563334777364" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563334777364.png" class="lazyload"></p>
<p>group by 乱序后 性能差极了！！！！！</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>where条件定值为常量（查询）、范围是排序后面失效，一般order by是给个范围</p>
<p>group by基本上都需要进行排序（<strong>分组之前必排序</strong>），会导致临时表产生</p>
<p>group by和order by几乎一致</p>
<p><img alt="1563352023243" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563352023243.png" class="lazyload"></p>
<p><img alt="1563352608797" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563352608797.png" class="lazyload"></p>
<p><img alt="总结" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E6%80%BB%E7%BB%93.png" class="lazyload"></p>
<h4 id="索引优化口诀"><a href="#索引优化口诀" class="headerlink" title="索引优化口诀"></a>索引优化口诀</h4><p>全值匹配我最爱，最左前缀要遵守；</p>
<p>带头大哥不能死，中间兄弟不能断；</p>
<p>索引列上少计算，范围之后全失效；</p>
<p>Like百分写最右，覆盖索引不写星；</p>
<p>不等空值还有or，索引失效要少用；</p>
<p>VAR引号不可丢，SQL高级也不难！</p>
<h1 id="3、查询截取分析"><a href="#3、查询截取分析" class="headerlink" title="3、查询截取分析"></a>3、查询截取分析</h1><blockquote>
<p>整体查询截取的分析流程如下：</p>
<p>分析</p>
<p>1、观察，至少跑1天，看看生产的慢SQL情况</p>
<p>2、开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来</p>
<p>3、explain + 慢SQL分析</p>
<p>4、show profile</p>
<p>5、运维经理 or DBA，进行SQL数据库服务器的参数调优</p>
<p>总结：</p>
<p>0、查询优化</p>
<p>1、慢查询的开启捕获</p>
<p>2、explain + 慢SQL分析</p>
<p>3、show profile 查询SQL在Mysql服务器里面的执行细节和生命周期情况</p>
<p>4、SQL数据库服务器的参数调优</p>
</blockquote>
<h2 id="1、查询优化"><a href="#1、查询优化" class="headerlink" title="1、查询优化"></a>1、查询优化</h2><p><img alt="1563435126980" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563435126980.png" class="lazyload"></p>
<h3 id="1、小表驱动大表"><a href="#1、小表驱动大表" class="headerlink" title="1、小表驱动大表"></a>1、小表驱动大表</h3><p>数据库最耗神的操作就是连接查询释放，若一百万次查询每查一次释放一次，数据库会受不了</p>
<p><img alt="1563435403331" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563435403331.png" class="lazyload"></p>
<p><img alt="1563436328039" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563436328039.png" class="lazyload"></p>
<p><img alt="1563436424779" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563436424779.png" class="lazyload"></p>
<h4 id="in和exists"><a href="#in和exists" class="headerlink" title="in和exists"></a>in和exists</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">select * from tbl_emp e </span><br><span class="line">where e.deptId </span><br><span class="line">in (select id from tbl_dept d);</span><br><span class="line"></span><br><span class="line">#[2]</span><br><span class="line">select * from tbl_emp e </span><br><span class="line">where EXISTS (select 1 from tbl_dept d where e.deptId = d.id);</span><br></pre></td></tr></table></figure>





<h3 id="2、order-by关键字优化"><a href="#2、order-by关键字优化" class="headerlink" title="2、order by关键字优化"></a>2、order by关键字优化</h3><p><img alt="1563588187123" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563588187123.png" class="lazyload"></p>
<h4 id="使用index方式排序"><a href="#使用index方式排序" class="headerlink" title="使用index方式排序"></a>使用index方式排序</h4><h5 id="建表SQL"><a href="#建表SQL" class="headerlink" title="建表SQL"></a>建表SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tblA(</span><br><span class="line">	id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,</span><br><span class="line">	age INT,</span><br><span class="line">	birth TIMESTAMP NOT NULL </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into tblA(age,birth) VALUES(22,NOW());</span><br><span class="line">insert into tblA(age,birth) VALUES(23,NOW());</span><br><span class="line">insert into tblA(age,birth) VALUES(24,NOW());</span><br><span class="line"></span><br><span class="line">create index idx_A_ageBirth on tblA(age,birth);</span><br><span class="line"></span><br><span class="line">select * from tblA;</span><br></pre></td></tr></table></figure>

<h5 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h5><p><img alt="1563588804573" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563588804573.png" class="lazyload"></p>
<p><img alt="1563589038772" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563589038772.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1]</span><br><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from tbla</span><br><span class="line">ORDER BY age asc,birth asc</span><br><span class="line"></span><br><span class="line">#[2]</span><br><span class="line">EXPLAIN</span><br><span class="line">select *</span><br><span class="line">from tbla</span><br><span class="line">ORDER BY age desc,birth desc</span><br></pre></td></tr></table></figure>
<p>两个排序同方向的可以用到索引<br><img alt="1563589150556" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563589150556.png" class="lazyload"></p>
<hr>
<p>【结论】</p>
<p>1、MySQL支持两种方式的排序，FileSort和Index，Index效率高，它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</p>
<p>2、order by满足两种情况，会使用Index方式排序</p>
<ul>
<li><p>[1] order by 语句使用索引最左前列</p>
</li>
<li><p>[2] 使用where子句与order by子句条件列组合满足索引最左前列</p>
</li>
</ul>
<p><span style="color:red"><strong>遵循索引键的最佳作前缀</strong></span></p>
<h4 id="firesort两种算法"><a href="#firesort两种算法" class="headerlink" title="firesort两种算法"></a>firesort两种算法</h4><p><strong>如果不在索引列上，firesort有两种算法：mysql就要启动双路排序和单路排序</strong></p>
<h5 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a>双路排序</h5><p>​        MySQL4.1之前使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p>
<p>​        从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段</p>
<p>​        取一批数据，要对磁盘进行两次扫描，众所周知，I/O是很耗时的，所有在mysql4.1之后，出现了第二中改进的算法，就是单路排序</p>
<h5 id="单路排序"><a href="#单路排序" class="headerlink" title="单路排序"></a>单路排序</h5><p><img alt="1563589954385" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563589954385.png" class="lazyload"></p>
<h5 id="结论和引申"><a href="#结论和引申" class="headerlink" title="结论和引申"></a>结论和引申</h5><p>由于单路是后出的，总体而言好过双路，但是用单路有问题，一次数据拿不完还不如双路排序</p>
<p><img alt="1563590211157" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563590211157.png" class="lazyload"></p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>SQL数据库服务器的参数调优</p>
<p><img alt="1563590274583" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563590274583.png" class="lazyload"></p>
<h5 id="提高order-by的速度"><a href="#提高order-by的速度" class="headerlink" title="提高order by的速度"></a>提高order by的速度</h5><p><img alt="1563590318778" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563590318778.png" class="lazyload"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img alt="1563591106479" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563591106479.png" class="lazyload"></p>
<h3 id="3、group-by关键字优化"><a href="#3、group-by关键字优化" class="headerlink" title="3、group by关键字优化"></a>3、group by关键字优化</h3><p><img alt="1563610157651" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610157651.png" class="lazyload"></p>
<p>其他均和orderby一样</p>
<h2 id="2、慢查询日志"><a href="#2、慢查询日志" class="headerlink" title="2、慢查询日志"></a>2、慢查询日志</h2><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><img alt="1563610215972" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610215972.png" class="lazyload"></p>
<p><img alt="1563610333217" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610333217.png" class="lazyload"></p>
<h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><h4 id="1、查看是否开启了慢查询日志"><a href="#1、查看是否开启了慢查询日志" class="headerlink" title="1、查看是否开启了慢查询日志"></a>1、查看是否开启了慢查询日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES LIKE &apos;%slow_query_log%&apos;;</span><br></pre></td></tr></table></figure>
<p>win10如下：<br><img alt="1563610497080" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610497080.png" class="lazyload"></p>
<p>一般情况在如下目录</p>
<p><img alt="1563610510076" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610510076.png" class="lazyload"></p>
<p>linux如下：<br><img alt="1563610558929" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610558929.png" class="lazyload"></p>
<h4 id="2、开启慢查询日志"><a href="#2、开启慢查询日志" class="headerlink" title="2、开启慢查询日志"></a>2、开启慢查询日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log = 1;</span><br></pre></td></tr></table></figure>

<p><img alt="1563610684640" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610684640.png" class="lazyload"></p>
<p><img alt="1563610777025" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610777025.png" class="lazyload"></p>
<h4 id="3、查看设置慢查询时间"><a href="#3、查看设置慢查询时间" class="headerlink" title="3、查看设置慢查询时间"></a>3、查看设置慢查询时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%long_query_time%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563610913408" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563610913408.png" class="lazyload"></p>
<h4 id="4、设置慢查询时间"><a href="#4、设置慢查询时间" class="headerlink" title="4、设置慢查询时间"></a>4、设置慢查询时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global long_query_time = 3;</span><br></pre></td></tr></table></figure>

<p><img alt="1563611079970" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611079970.png" class="lazyload"></p>
<p>设置后满足以下两种情况才能看到变化</p>
<p><img alt="1563611124784" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611124784.png" class="lazyload"></p>
<p>模拟睡眠4秒，测试日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sleep(4);</span><br></pre></td></tr></table></figure>

<p><img alt="1563611454033" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611454033.png" class="lazyload"></p>
<p>linux下</p>
<p><img alt="1563614121741" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563614121741.png" class="lazyload"></p>
<h4 id="5、查询慢查询记录数"><a href="#5、查询慢查询记录数" class="headerlink" title="5、查询慢查询记录数"></a>5、查询慢查询记录数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global status like &apos;%Slow_queries%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563611671609" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611671609.png" class="lazyload"></p>
<p>用来查看当前系统的健康度如何</p>
<h4 id="6、永久设置"><a href="#6、永久设置" class="headerlink" title="6、永久设置"></a>6、永久设置</h4><p>修改my.cnf</p>
<p><img alt="1563611883839" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563611883839.png" class="lazyload"></p>
<h3 id="3、分析"><a href="#3、分析" class="headerlink" title="3、分析"></a>3、分析</h3><p>使用MySQL的日志分析工具 <strong>mysqldumpslow</strong>，作为生产环境中分析日志，查找、分析SQL的工具</p>
<h4 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>linux上安装mysql后mysqldumpslow为/usr/bin的命令，可以直接使用</p>
<p><img alt="1563612995357" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563612995357.png" class="lazyload"></p>
<p>windows上安装mysql后使用的是mysqldumpslow.pl，但是需要安装perl环境后（安装ActivePerl），才能执行</p>
<p><img alt="1563613028342" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563613028342.png" class="lazyload"></p>
<p>常见参数</p>
<p><img alt="1563613097870" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563613097870.png" class="lazyload"></p>
<h4 id="2、使用-1"><a href="#2、使用-1" class="headerlink" title="2、使用"></a>2、使用</h4><p>常用参考</p>
<p><img alt="1563613249650" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563613249650.png" class="lazyload"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 localhost-slow.log</span><br></pre></td></tr></table></figure>

<p><img alt="1563614233668" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563614233668.png" class="lazyload"></p>
<p><strong>建议: 为方便 可以结合 | 和 more 使用，否则可能出现爆屏</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log | more</span><br></pre></td></tr></table></figure>





<h2 id="3、批量数据脚本"><a href="#3、批量数据脚本" class="headerlink" title="3、批量数据脚本"></a>3、批量数据脚本</h2><blockquote>
<p>往表里插入1000W数据</p>
</blockquote>
<h3 id="1、建立SQL"><a href="#1、建立SQL" class="headerlink" title="1、建立SQL"></a>1、建立SQL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1] 建立表dept</span><br><span class="line">create table dept(</span><br><span class="line">	id  int PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">	deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,</span><br><span class="line">	dname VARCHAR(20) NOT NULL DEFAULT &quot;&quot;,</span><br><span class="line">	loc VARCHAR(13) NOT NULL DEFAULT &quot;&quot;</span><br><span class="line">)</span><br><span class="line">ENGINE=InnoDB</span><br><span class="line">DEFAULT CHARSET=GBK;</span><br><span class="line"></span><br><span class="line"># [2] 建立表emp</span><br><span class="line">create table emp(</span><br><span class="line">	id  int PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">	empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 COMMENT &apos;编号&apos;,</span><br><span class="line">	ename VARCHAR(20) NOT NULL DEFAULT &quot;&quot; COMMENT &apos;名字&apos;,</span><br><span class="line">	job VARCHAR(9) NOT NULL DEFAULT &quot;&quot; COMMENT &apos;工作&apos;,</span><br><span class="line">	mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 COMMENT &apos;上级编号&apos;,</span><br><span class="line">	hiredate DATE NOT NULL COMMENT &apos;入职时间&apos;,</span><br><span class="line">	sal DECIMAL(7,2) NOT NULL COMMENT &apos;薪水&apos;,</span><br><span class="line">	comm DECIMAL(7,2) NOT NULL COMMENT &apos;红利&apos;,</span><br><span class="line">	deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 COMMENT &apos;部门编号&apos;</span><br><span class="line">)</span><br><span class="line">ENGINE=InnoDB</span><br><span class="line">DEFAULT CHARSET=GBK;</span><br></pre></td></tr></table></figure>

<h3 id="2、设置参数"><a href="#2、设置参数" class="headerlink" title="2、设置参数"></a>2、设置参数</h3><blockquote>
<p>log_bin_trust_function_creators</p>
</blockquote>
<p><img alt="1563615598373" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563615598373.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># [3] 设置参数</span><br><span class="line"># 由于开启慢查询日志，因为我们开启了bin-log，就必须为我们的function指定一个参数</span><br><span class="line">show VARIABLES LIKE &apos;log_bin_trust_function_creators&apos;;</span><br><span class="line"></span><br><span class="line">set global log_bin_trust_function_creators = 1;</span><br></pre></td></tr></table></figure>



<h3 id="3、创建函数"><a href="#3、创建函数" class="headerlink" title="3、创建函数"></a>3、创建函数</h3><p>保证每条数据都不同，随机产生字符串，随机产生部门编号</p>
<h4 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a>随机产生字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建函数</span><br><span class="line"># 改变了mysql由原来用;结束语句改成了$$,因为函数中有多个;在一起</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE char_str VARCHAR(100) DEFAULT &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLNOPQRSTUVWXYZ&apos;;</span><br><span class="line">	DECLARE return_str VARCHAR(255) DEFAULT &apos;&apos;;</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	WHILE i &lt; n </span><br><span class="line">	DO</span><br><span class="line">		SET return_str = CONCAT(return_str,SUBSTRING(char_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">		SET i = i + 1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	RETURN return_str;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>

<h4 id="随机产生部门编号"><a href="#随机产生部门编号" class="headerlink" title="随机产生部门编号"></a>随机产生部门编号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_num() RETURNS INT(5)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET i = FLOOR(10+RAND()*10);</span><br><span class="line">	RETURN i;</span><br><span class="line">END $$</span><br><span class="line">#删除函数</span><br><span class="line">drop FUNCTION rand_num;</span><br></pre></td></tr></table></figure>

<h3 id="4、创建存储过程"><a href="#4、创建存储过程" class="headerlink" title="4、创建存储过程"></a>4、创建存储过程</h3><h4 id="emp表插入数据"><a href="#emp表插入数据" class="headerlink" title="emp表插入数据"></a>emp表插入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_emp(in start INT(10),in max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET autocommit = 0;</span><br><span class="line">	REPEAT</span><br><span class="line">		SET i = i+1;</span><br><span class="line">		INSERT INTO emp(empno,     ename,        job,      mgr,  hiredate, sal, comm,  deptno)</span><br><span class="line">		VALUES         (start+i,rand_string(6),&apos;SALESMAN&apos;,0001,CURDATE(),  2000, 400,   rand_num());</span><br><span class="line">		UNTIL i = max_num</span><br><span class="line">	END REPEAT;</span><br><span class="line">	COMMIT;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>



<h4 id="dept表插入数据"><a href="#dept表插入数据" class="headerlink" title="dept表插入数据"></a>dept表插入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_dept(in start INT(10),in max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET autocommit = 0;</span><br><span class="line">	REPEAT</span><br><span class="line">		SET i = i+1;</span><br><span class="line">		INSERT INTO emp(deptno,     dname,        loc)</span><br><span class="line">		VALUES         (start+i,rand_string(10),rand_string(8));</span><br><span class="line">		UNTIL i = max_num</span><br><span class="line">	END REPEAT;</span><br><span class="line">	COMMIT;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>



<h3 id="5、调用存储过程"><a href="#5、调用存储过程" class="headerlink" title="5、调用存储过程"></a>5、调用存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER ;</span><br><span class="line">call insert_dept(100,10);</span><br><span class="line"></span><br><span class="line">call insert_emp(100001,500000);</span><br><span class="line">call insert_emp(160001,500000);</span><br><span class="line">call insert_emp(1100001,500000);</span><br><span class="line">call insert_emp(1600001,500000);</span><br><span class="line">call insert_emp(2100001,500000);</span><br></pre></td></tr></table></figure>

<p>50W数据时间比较长，2分多钟</p>
<p><img alt="1563693337031" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563693337031.png" class="lazyload"></p>
<h2 id="4、show-profile（-star-star-star-）"><a href="#4、show-profile（-star-star-star-）" class="headerlink" title="4、show profile（:star::star::star:）"></a>4、show profile（:star::star::star:）</h2><h3 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于sql的调优的测量，分析SQL性能</p>
<p><img alt="1563694967549" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563694967549.png" class="lazyload"></p>
<h3 id="2、分析步骤"><a href="#2、分析步骤" class="headerlink" title="2、分析步骤"></a>2、分析步骤</h3><p><img alt="1563695234485" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563695234485.png" class="lazyload"></p>
<h4 id="1、查看当前mysql版本是否支持"><a href="#1、查看当前mysql版本是否支持" class="headerlink" title="1、查看当前mysql版本是否支持"></a>1、查看当前mysql版本是否支持</h4><p>Show profiles是5.0.37之后添加的，要想使用此功能，要确保版本在5.0.37之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看数据库版本</span><br><span class="line">select version();</span><br><span class="line"></span><br><span class="line"># 默认关闭的</span><br><span class="line">show VARIABLES like &apos;profiling&apos;;</span><br><span class="line"># show VARIABLES like &apos;profiling%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563695307056" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563695307056.png" class="lazyload"></p>
<h4 id="2、开启功能"><a href="#2、开启功能" class="headerlink" title="2、开启功能"></a>2、开启功能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set profiling = on;</span><br></pre></td></tr></table></figure>

<p><img alt="1563695378420" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563695378420.png" class="lazyload"></p>
<h4 id="3、运行SQL"><a href="#3、运行SQL" class="headerlink" title="3、运行SQL"></a>3、运行SQL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改下sql_mode ，否则不能用[1] 和[2] ,这里只是打个比方，group by不能这样用</span><br><span class="line">show variables like &quot;sql_mode&quot;;</span><br><span class="line">set sql_mode=&apos;&apos;;</span><br><span class="line">set sql_mode=&apos;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&apos;;</span><br><span class="line">#set sql_mode=&apos;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;</span><br><span class="line"></span><br><span class="line">#[1]</span><br><span class="line">select * from emp group by id%10 limit 150000;</span><br><span class="line">#[2]</span><br><span class="line">select * from emp group by id%10  order by 5;</span><br></pre></td></tr></table></figure>





<h4 id="4、诊断SQL"><a href="#4、诊断SQL" class="headerlink" title="4、诊断SQL"></a>4、诊断SQL</h4><p>执行的sql语句会被记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>

<p><img alt="1563701659351" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563701659351.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#同时查看不同资源开销   根据query_id来查看sql的生命周期</span><br><span class="line">show profile cpu,block io for query 7;</span><br></pre></td></tr></table></figure>

<p><img alt="1563701738671" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563701738671.png" class="lazyload"></p>
<p>常见的参数如下：</p>
<p><img alt="1563702101846" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563702101846.png" class="lazyload"></p>
<p>常见的状态</p>
<table>
<thead>
<tr>
<th><strong>Status</strong></th>
<th><strong>建议</strong></th>
</tr>
</thead>
<tbody><tr>
<td>System lock</td>
<td>确认是由于哪个锁引起的，通常是因为MySQL或InnoDB内核级的锁引起的建议：如果耗时较大再关注即可，一般情况下都还好</td>
</tr>
<tr>
<td>Sending data</td>
<td>从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见备注：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net建议：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量</td>
</tr>
<tr>
<td>Sorting result</td>
<td>正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序建议：创建适当的索引</td>
</tr>
<tr>
<td>Table lock</td>
<td>表级锁，没什么好说的，要么是因为MyISAM引擎表级锁，要么是其他情况显式锁表</td>
</tr>
<tr>
<td>create sort index</td>
<td>当前的SELECT中需要用到临时表在进行ORDER BY排序建议：创建适当的索引</td>
</tr>
<tr>
<td>checking query cache for querychecking privileges on cachedsending cached result to clienstoring result in query cache</td>
<td>和query cache相关的状态，已经多次强烈建议关闭</td>
</tr>
</tbody></table>
<h4 id="5、日常开发需要注意的结论"><a href="#5、日常开发需要注意的结论" class="headerlink" title="5、日常开发需要注意的结论"></a>5、日常开发需要注意的结论</h4><p>避免以下几种情况，需要优化SQL语句</p>
<p><img alt="1563702184744" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563702184744.png" class="lazyload"></p>
<p><img alt="1563710332244" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563710332244.png" class="lazyload"></p>
<h2 id="5、全局查询日志"><a href="#5、全局查询日志" class="headerlink" title="5、全局查询日志"></a>5、全局查询日志</h2><blockquote>
<p>永远不要在生产环境开启这个功能</p>
</blockquote>
<h3 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h3><p>方式一：配置文件启用</p>
<p><img alt="1563719697578" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563719697578.png" class="lazyload"></p>
<p>方式二：</p>
<p><img alt="1563719720626" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563719720626.png" class="lazyload"></p>
<p>可以查看某个时间段的sql语句，时间段故障分析</p>
<p><img alt="1563719852329" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563719852329.png" class="lazyload"></p>
<h1 id="4、MySQL锁机制"><a href="#4、MySQL锁机制" class="headerlink" title="4、MySQL锁机制"></a>4、MySQL锁机制</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p><img alt="1563760231545" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563760231545.png" class="lazyload"></p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>1、对数据操作的类型分</p>
<p>[1] 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</p>
<p>[2] 写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</p>
<p>2、对数据操作的粒度来分</p>
<p>[1] 表锁</p>
<p>[2] 行锁</p>
<h2 id="2、三锁"><a href="#2、三锁" class="headerlink" title="2、三锁"></a>2、三锁</h2><p>从开销、加锁速度、死锁、粒度、并发性能，根据具体应用的特点来说哪种锁更合适</p>
<h3 id="1、表锁（偏读）"><a href="#1、表锁（偏读）" class="headerlink" title="1、表锁（偏读）"></a>1、表锁（偏读）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率高，并发度最低</p>
</blockquote>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL-1"><a href="#建表SQL-1" class="headerlink" title="建表SQL"></a>建表SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table mylock(</span><br><span class="line">	id int not null PRIMARY KEY auto_increment,</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">)ENGINE myisam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into mylock(name) VALUES(&apos;a&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;b&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;c&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;d&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;e&apos;);</span><br><span class="line">insert into mylock(name) VALUES(&apos;f&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * from mylock;</span><br></pre></td></tr></table></figure>





<h5 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h5><p>开启两个session，分别为session1、session2</p>
<p><strong>session1对mylock表加锁时</strong></p>
<p>【1】分别读取mylock和book表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -----------       [ session1 ]     ---------------------</span><br><span class="line"># -----------[ session1对mylock表加读锁时 ]---------------</span><br><span class="line">lock table mylock read;</span><br><span class="line"></span><br><span class="line">select * from mylock;</span><br><span class="line"># session1 不能读其他表，必须释放前面的锁</span><br><span class="line">select * from book;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ------------------[ session2 ]------------------</span><br><span class="line"># ------------session1对mylock表加读锁时--------------</span><br><span class="line"># 可以读所有的表</span><br><span class="line">select * from mylock;</span><br><span class="line">select * from book;</span><br></pre></td></tr></table></figure>

<p><img alt="1563762886163" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563762886163.png" class="lazyload"></p>
<p><img alt="1563762962117" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563762962117.png" class="lazyload"></p>
<p>【2】分别修改mylock表时</p>
<p>session1不能修改mylock表，session2修改表时出现阻塞情况，必须等session1结束后session2才能修改成功</p>
<p><img alt="读锁阻塞" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E8%AF%BB%E9%94%81%E9%98%BB%E5%A1%9E.gif" class="lazyload"></p>
<p><img alt="读锁" data-src="/.cn//Users/MxRanger/Desktop/%E8%AF%BB%E9%94%81.png" class="lazyload"></p>
<h5 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h5><p><strong>session1对mylock表加锁时</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-------------[session1]--------------</span><br><span class="line">#--------------加写锁时------------------</span><br><span class="line">lock table mylock write;</span><br><span class="line"></span><br><span class="line"># 可读</span><br><span class="line">select * from mylock;</span><br><span class="line">#可更改</span><br><span class="line">update mylock set name = &apos;a4&apos; where id = 1;</span><br><span class="line"></span><br><span class="line"># 不能读其他表之前的未释放</span><br><span class="line">select * from book;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#-------------[session2]----------------</span><br><span class="line">#读其他未上锁的表正常</span><br><span class="line">select * from book;</span><br><span class="line"></span><br><span class="line">#阻塞 session1独占查询修改，session2查询都不行，修改也是一样</span><br><span class="line">select * from mylock;</span><br></pre></td></tr></table></figure>



<p><img alt="写锁" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E5%86%99%E9%94%81.png" class="lazyload"></p>
<h5 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h5><p><img alt="读写锁结论" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E8%AF%BB%E5%86%99%E9%94%81%E7%BB%93%E8%AE%BA.png" class="lazyload"></p>
<p><span style="color:red"><strong>简而言之，就是读锁会阻塞写，但是不会阻塞读。写锁会把读和写都阻塞。</strong></span></p>
<p><img alt="读写锁结论2" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E8%AF%BB%E5%86%99%E9%94%81%E7%BB%93%E8%AE%BA2.png" class="lazyload"></p>
<h3 id="2、行锁（偏写）"><a href="#2、行锁（偏写）" class="headerlink" title="2、行锁（偏写）"></a>2、行锁（偏写）</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度也最高</p>
<p><span style="color:red"><strong>InnDB与MyISAM的最大不同两点：一是支持事务；而是采用行级锁</strong></span></p>
</blockquote>
<h4 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h4><h5 id="事务、ACID属性"><a href="#事务、ACID属性" class="headerlink" title="事务、ACID属性"></a>事务、ACID属性</h5><p><img alt="1563849196042" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849196042.png" class="lazyload"></p>
<h5 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h5><p>并发事务处理带来的问题</p>
<h6 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h6><p><img alt="1563849282872" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849282872.png" class="lazyload"></p>
<h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p><img alt="1563849298280" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849298280.png" class="lazyload"></p>
<h6 id="不可重复度"><a href="#不可重复度" class="headerlink" title="不可重复度"></a>不可重复度</h6><p><img alt="1563849324263" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849324263.png" class="lazyload"></p>
<h6 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h6><p><img alt="1563849369136" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849369136.png" class="lazyload"></p>
<p><span style="color:red"><strong>总结：**</strong>脏读是事务A读取到事务B里面修改了数据，幻读是事务A读取到事务B里面新增了数据**</span></p>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p><img alt="1563849571041" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563849571041.png" class="lazyload"></p>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建立SQL-3"><a href="#建立SQL-3" class="headerlink" title="建立SQL"></a>建立SQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_innodb_lock(</span><br><span class="line">	a int(11),</span><br><span class="line">	b varchar(16)</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">insert into test_innodb_lock VALUES(1,&apos;b2&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(2,&apos;3&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(3,&apos;3000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(4,&apos;4000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(5,&apos;5000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(6,&apos;6000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(7,&apos;7000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(8,&apos;8000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(9,&apos;9000&apos;);</span><br><span class="line">insert into test_innodb_lock VALUES(1,&apos;b1&apos;);</span><br><span class="line"></span><br><span class="line">create INDEX test_innodb_a_ind on test_innodb_lock(a);</span><br><span class="line"></span><br><span class="line">create INDEX test_innodb_b_ind on test_innodb_lock(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from test_innodb_lock;</span><br></pre></td></tr></table></figure>

<h5 id="行锁基本演示"><a href="#行锁基本演示" class="headerlink" title="行锁基本演示"></a>行锁基本演示</h5><p>【1】首先查看了当前的隔离级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;tx_isolation&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563864436638" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563864436638.png" class="lazyload"></p>
<p>【2】修改同一行</p>
<p>开启两个session会话</p>
<p>两个会话同时设置<code>set autocommit = 0;</code>把自动提交关了</p>
<p>修改某行内容，两个会话同时查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#--------------[session1]-------------</span><br><span class="line">#--------------[1] 修改某行内容</span><br><span class="line">update test_innodb_lock set b = &apos;4005&apos; WHERE a = 4;</span><br><span class="line">select * from test_innodb_lock;</span><br><span class="line"></span><br><span class="line">#--------------[session2]-------------</span><br><span class="line">select * from test_innodb_lock;</span><br></pre></td></tr></table></figure>

<p><img alt="1563864779345" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563864779345.png" class="lazyload"></p>
<p>保证了隔离级别达到的不出现<strong>脏读</strong>的情况，且在session1进行commit而session2没有commit的情况下，session2依然不会读取到修改后的值，保证了不会出现<strong>不可重复读</strong></p>
<p>两个会话都<code>commit;</code>内容一致</p>
<p><img alt="1563864862384" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563864862384.png" class="lazyload"></p>
<p>当session1在修改而没有commit时，session2进行修改同一行，会出现阻塞的情况，直到session1提交才能修改成功</p>
<p><img alt="1563865115947" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563865115947.png" class="lazyload"></p>
<p>【3】修改不同行</p>
<p>不会发生冲突，<strong>大路朝天各走一边</strong></p>
<p><img alt="1563865130783" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563865130783.png" class="lazyload"></p>
<h5 id="索引失效行锁变表锁"><a href="#索引失效行锁变表锁" class="headerlink" title="索引失效行锁变表锁"></a>索引失效行锁变表锁</h5><p>正常情况下：<br><img alt="1563867004784" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867004784.png" class="lazyload"></p>
<p>索引失效情况下：行锁变表锁<br><img alt="1563867120057" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867120057.png" class="lazyload"></p>
<h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p>表中1-6缺少2的情况下</p>
<p><img alt="1563867588304" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867588304.png" class="lazyload"></p>
<p>两个会话都提交后<br><img alt="1563867629535" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867629535.png" class="lazyload"></p>
<p>【结论】<br><img alt="1563867700797" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867700797.png" class="lazyload"></p>
<h5 id="面试题-star-star-star"><a href="#面试题-star-star-star" class="headerlink" title="面试题(:star::star::star:)"></a>面试题(:star::star::star:)</h5><p>如何锁定一行</p>
<p>在sql语句后加上<code>for update</code></p>
<p><img alt="1563867967102" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563867967102.png" class="lazyload"></p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><h5 id="Innodb优缺点"><a href="#Innodb优缺点" class="headerlink" title="Innodb优缺点"></a>Innodb优缺点</h5><p><img alt="1563868323949" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868323949.png" class="lazyload"></p>
<h5 id="如何分析行锁定"><a href="#如何分析行锁定" class="headerlink" title="如何分析行锁定"></a>如何分析行锁定</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;innodb_row_lock%&apos;;</span><br></pre></td></tr></table></figure>

<p><img alt="1563868485083" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868485083.png" class="lazyload"></p>
<p><img alt="1563868650448" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868650448.png" class="lazyload"></p>
<h5 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h5><p><img alt="1563868717901" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868717901.png" class="lazyload"></p>
<h3 id="3、页锁"><a href="#3、页锁" class="headerlink" title="3、页锁"></a>3、页锁</h3><p><img alt="1563868765523" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563868765523.png" class="lazyload"></p>
<h1 id="5、主从复制"><a href="#5、主从复制" class="headerlink" title="5、主从复制"></a>5、主从复制</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>slave从master读取binlog来进行数据同步，主要做多处备份</p>
<p><img alt="1563869815730" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563869815730.png" class="lazyload"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>具体的百度搜吧，一大堆</p>
<hr>
<p>以下不用看</p>
<p>1、mysql版本一致，且互相ping通，服务正常运行</p>
<p>2、</p>
<p><img alt="1563871262129" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871262129.png" class="lazyload"></p>
<p><img alt="1563871272513" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871272513.png" class="lazyload"></p>
<p><img alt="1563871295033" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871295033.png" class="lazyload"></p>
<p><img alt="1563871308785" data-src="/images/MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/1563871308785.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题</title>
    <url>/2019/12/12/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、稀疏数组和队列"><a href="#一、稀疏数组和队列" class="headerlink" title="一、稀疏数组和队列"></a>一、稀疏数组和队列</h1><h2 id="1、稀疏数组（sparsearray）"><a href="#1、稀疏数组（sparsearray）" class="headerlink" title="1、稀疏数组（sparsearray）"></a>1、稀疏数组（sparsearray）</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img alt="1564217081634" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564217081634.png" class="lazyload"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​        当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是:</p>
<p>1)记录数组一共有几行几列，有多少个不同的值</p>
<p>2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<p><img alt="1564217192689" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564217192689.png" class="lazyload"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img alt="1564217279345" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564217279345.png" class="lazyload"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sparearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName sparearray</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/27</span></span><br><span class="line"><span class="comment"> * Time      15:37</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      1、稀疏数组的组成 + 数组复原</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpareArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//---------------------------建立稀疏数组------------------------------</span></span><br><span class="line">        <span class="comment">//[0]创建11*11二维数据</span></span><br><span class="line">        <span class="keyword">int</span> chessArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历原始数据</span></span><br><span class="line">        System.out.println(<span class="string">"----------遍历原始数据-------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : rows)&#123;</span><br><span class="line">                System.out.print(e + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---------------二维数组转稀疏数组---------------------------</span></span><br><span class="line">        <span class="comment">//[1] 遍历得到非0数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : rows)&#123;</span><br><span class="line">                <span class="keyword">if</span> (e!= <span class="number">0</span>)</span><br><span class="line">                    sum +=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(sum);</span></span><br><span class="line">        <span class="comment">//[2]创建稀疏数组 并赋值</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j]!= <span class="number">0</span>)&#123;</span><br><span class="line">                    sparseArr[index][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[index][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[index][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                    index += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------遍历稀疏数组-------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"行\t列\t值"</span>);</span><br><span class="line">        <span class="comment">//[3]遍历稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : sparseArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : rows)&#123;</span><br><span class="line">                System.out.print(e + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------复原-----------------------------------</span></span><br><span class="line">        <span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line"><span class="comment">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h2><p><img alt="1564220167546" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564220167546.png" class="lazyload"></p>
<h3 id="1、模拟普通队列"><a href="#1、模拟普通队列" class="headerlink" title="1、模拟普通队列"></a>1、模拟普通队列</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><img alt="1564220179900" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564220179900.png" class="lazyload"></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ArrayQueueDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/27</span></span><br><span class="line"><span class="comment"> * Time      16:54</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 顺序表   用数组实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">//接收用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span>(loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">//退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//模拟队列，顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列  默认指针都为-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//队列头前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;<span class="comment">//队列尾，指向队列最后一个数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定front+1 和 rear之间打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=(front+<span class="number">1</span>);i&lt;=rear;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队  rear入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//满了</span></span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//rear后移</span></span><br><span class="line">        arr[rear] = data;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队    front出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[++front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上漏洞较为明显，不能循环使用</p>
<p><img alt="1564221117008" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564221117008.png" class="lazyload"></p>
<h3 id="2、模拟环形队列"><a href="#2、模拟环形队列" class="headerlink" title="2、模拟环形队列"></a>2、模拟环形队列</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>对前面的数组模拟队列的优化，充分利用数组.因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img alt="1564299842480" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564299842480.png" class="lazyload"></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName CircleArrayQueue</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/28</span></span><br><span class="line"><span class="comment"> * Time      15:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//测试一把</span></span><br><span class="line">        System.out.println(<span class="string">"测试数组模拟环形队列的案例~~~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个环形队列</span></span><br><span class="line">        CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>); <span class="comment">//说明设置4, 其队列的有效数据最大是3</span></span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s: 显示队列\t e:退出\t a:添加\t g:去除\th:头数据"</span>);</span><br><span class="line"></span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//最大容量</span></span><br><span class="line">    <span class="comment">//front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素</span></span><br><span class="line">    <span class="comment">//front 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="comment">//rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line">    <span class="comment">//rear 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//模拟队列，顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列  默认指针都为-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        front = <span class="number">0</span>;<span class="comment">//队列头</span></span><br><span class="line">        rear = <span class="number">0</span>;<span class="comment">//队列尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队  rear入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rear为最后一个元素后的空元素位置填充</span></span><br><span class="line">        arr[rear] = data;</span><br><span class="line">        <span class="comment">//rear向后移</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队    front出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line">        <span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line">        <span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line">        <span class="keyword">int</span> data = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span> ) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 思路：从front开始遍历，遍历多少个元素,剔除最后一个空位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=front ;i&lt;= front + size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            System.out.print(arr[i % maxSize] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front ) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>链表（Linked List）是有序的列表，但是它在内存中是存储如下</p>
<p><img alt="1564299967545" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564299967545.png" class="lazyload"></p>
<h2 id="2、单链表"><a href="#2、单链表" class="headerlink" title="2、单链表"></a>2、单链表</h2><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>使用带head头的<strong>单向链表</strong>实现 –水浒英雄排行榜管理</p>
<p>【1】完成对英雄人物的<strong>增删改查</strong>操作</p>
<p>【2】第一种方法在添加英雄时，直接添加到链表的尾部</p>
<p>【3】<strong>第二种方式在添加英雄时</strong>，根据排名将英雄插入到指定位置<br> (如果有这个排名，则添加失败，并给出提示)</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p><img alt="1564536750418" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564536750418.png" class="lazyload"></p>
<h4 id="编号顺序添加"><a href="#编号顺序添加" class="headerlink" title="编号顺序添加"></a>编号顺序添加</h4><p><img alt="1564536804884" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564536804884.png" class="lazyload"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img alt="1564536820112" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564536820112.png" class="lazyload"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName SingleLinkListDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/28</span></span><br><span class="line"><span class="comment"> * Time      16:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SingleLinkList list = <span class="keyword">new</span> SingleLinkList();</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"1"</span>,<span class="string">"1"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"2"</span>,<span class="string">"2"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"3"</span>,<span class="string">"3"</span>));</span><br><span class="line"></span><br><span class="line">        list.list();</span><br><span class="line">        System.out.println(<span class="string">"-----------删除2---------------------"</span>);</span><br><span class="line">        list.del(<span class="number">2</span>);</span><br><span class="line">        list.list();</span><br><span class="line">        System.out.println(<span class="string">"-----------新增4---------------------"</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"4"</span>,<span class="string">"4"</span>));</span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------修改4---------------------"</span>);</span><br><span class="line">        list.update(<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"8"</span>,<span class="string">"8"</span>));</span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------排序添加2---------------------"</span>);</span><br><span class="line">        list.addByOrder(<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"4"</span>,<span class="string">"4"</span>));</span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SingleLinkList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode headNode = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHeadNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">//1. 找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HeroNode node = headNode;</span><br><span class="line">        <span class="keyword">while</span> (node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//不是链表的最后</span></span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">                heroNode.next = temp.next;</span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断flag 的值</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123; <span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">            System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(headNode.next == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"空列表"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示是否找到该节点</span></span><br><span class="line"></span><br><span class="line">        HeroNode tmp = headNode.next;</span><br><span class="line">        <span class="keyword">while</span> (tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.no == newHeroNode.no)&#123;</span><br><span class="line">                tmp.name = newHeroNode.name;</span><br><span class="line">                tmp.nickname = newHeroNode.nickname;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode pre = headNode;</span><br><span class="line">        HeroNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pre.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.next.no==no)&#123;</span><br><span class="line">                <span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                next = pre.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123; <span class="comment">//找到</span></span><br><span class="line">            <span class="comment">//可以删除</span></span><br><span class="line">            pre.next = next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(headNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = headNode.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移， 一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><h4 id="1、求单链表中有效节点个数"><a href="#1、求单链表中有效节点个数" class="headerlink" title="1、求单链表中有效节点个数"></a><strong>1、求单链表中有效节点个数</strong></h4><p>遍历一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123; <span class="comment">//空链表</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//定义一个辅助的变量, 这里我们没有统计头节点</span></span><br><span class="line">	HeroNode cur = head.next;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		cur = cur.next; <span class="comment">//遍历</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、查找单链表中的倒数第k个结点"><a href="#2、查找单链表中的倒数第k个结点" class="headerlink" title="2、查找单链表中的倒数第k个结点"></a><strong>2、查找单链表中的倒数第k个结点</strong></h4><p>遍历原链表，采用头插法到新链表中，再换头</p>
<p><img alt="1564538202223" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564538202223.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">		HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">		<span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line">		<span class="comment">//动脑筋</span></span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">			next = cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">			cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">			reverseHead.next = cur; <span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">			cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">		head.next = reverseHead.next;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、从尾到头打印单链表"><a href="#3、从尾到头打印单链表" class="headerlink" title="3、从尾到头打印单链表"></a><strong>3、从尾到头打印单链表</strong></h4><p>采用栈的方式打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式2：</span></span><br><span class="line">    <span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            HeroNode node = stack.pop();</span><br><span class="line">            System.out.println(node.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、双向链表"><a href="#3、双向链表" class="headerlink" title="3、双向链表"></a>3、双向链表</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>使用带head头的<strong>双向链**</strong>表**实现 –水浒英雄排行榜</p>
<p>管理单向链表的缺点分析: </p>
<p>1)单向链表，<strong>查找的方向只能是一个方向</strong>，而双向链<br> 表可以向前或者向后查找。</p>
<p>2)单向链表不能自我删除，需要靠辅助节点 ，而双向 链表，则可以<strong>自我删除</strong>，所以前面我们单链表删除 时节点，总是找到temp,temp是待删除节点的前一个节点.</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img alt="1564542184718" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564542184718.png" class="lazyload"></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName DoubleLinkedListDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/31</span></span><br><span class="line"><span class="comment"> * Time      10:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        System.out.println(<span class="string">"双向链表的测试"</span>);</span><br><span class="line">        <span class="comment">// 先创建节点</span></span><br><span class="line">        HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">// 创建一个双向链表</span></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"公孙胜"</span>, <span class="string">"入云龙"</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">"修改后的链表情况"</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表的方法</span></span><br><span class="line">    <span class="comment">// 显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个节点到双向链表的最后.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">// 形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span></span><br><span class="line">    <span class="comment">// 只是 节点类型改成 HeroNode2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line">        <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到</span></span><br><span class="line">            System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从双向链表中删除一个节点,</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1 对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line">    <span class="comment">// 2 找到后，自我删除即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;<span class="comment">// 空链表</span></span><br><span class="line">            System.out.println(<span class="string">"链表为空，无法删除"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp = head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 找到</span></span><br><span class="line">            <span class="comment">// 可以删除</span></span><br><span class="line">            <span class="comment">// temp.next = temp.next.next;[单向链表]</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">// 这里我们的代码有问题?</span></span><br><span class="line">            <span class="comment">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next; <span class="comment">// 指向下一个节点, 默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre; <span class="comment">// 指向前一个节点, 默认为null</span></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、约瑟夫（Josephu）"><a href="#4、约瑟夫（Josephu）" class="headerlink" title="4、约瑟夫（Josephu）"></a>4、约瑟夫（Josephu）</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Josephu(约瑟夫、约瑟夫环) 问题</strong></p>
<p>Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p><strong>提示</strong>：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
<h3 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h3><p><img alt="1564542413937" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564542413937.png" class="lazyload"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img alt="1564542563525" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564542563525.png" class="lazyload"></p>
<p><img alt="1564543721713" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564543721713.png" class="lazyload"></p>
<p><img alt="1564543756409" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1564543756409.png" class="lazyload"></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName JosepHu</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/7/31</span></span><br><span class="line"><span class="comment"> * Time      11:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JosepHu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">125</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">125</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">        <span class="comment">//String str = "7*2*2-5+1-5+3-3";</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个first节点,当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nums 做一个数据校验</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>; <span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">// 使用for来创建我们的环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">// 如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">                curBoy = first; <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);<span class="comment">//</span></span><br><span class="line">                boy.setNext(first);<span class="comment">//</span></span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前的环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment">     *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment">     *            表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     *            表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">"参数输入有误， 请重新输入"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123; <span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小孩报数前，先让 first 和  helper 移动 k - 1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈</span></span><br><span class="line">        <span class="comment">//这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper == first) &#123; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line">            <span class="comment">//这时将first指向的小孩节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>, first.getNo());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>1、栈的英文为(stack)</p>
<p>2、栈是一个<strong>先入后出</strong>(FILO-First In Last Out)的有序列表。</p>
<p>3、栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</p>
<p>4、根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
<p><img alt="1566870789729" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566870789729.png" class="lazyload"></p>
<p><img alt="1566870793286" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566870793286.png" class="lazyload"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1)子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。   </p>
<p>2)处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</p>
<p>3)表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</p>
<p>4)二叉树的遍历。</p>
<p>5)图形的深度优先(depth一first)搜索法。</p>
<h2 id="2、数组模拟栈"><a href="#2、数组模拟栈" class="headerlink" title="2、数组模拟栈"></a>2、数组模拟栈</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img alt="1566870928332" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566870928332.png" class="lazyload"></p>
<p>实现 栈的 思路分析</p>
<ol>
<li><p>使用数组来模拟栈</p>
</li>
<li><p>定义一个 top  来表示栈顶，初始化 为  -1</p>
</li>
<li><p><strong>入栈</strong>的操作，当有数据加入到栈时， top++;  stack[top] = data;</p>
</li>
<li><p><strong>出栈</strong>的操作， int value = stack[top]; top–, return value</p>
</li>
</ol>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.invoke.empty.Empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ArrayStackDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/8/27</span></span><br><span class="line"><span class="comment"> * Time      9:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        stack.list();</span><br><span class="line"></span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxsize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组模拟栈，数据就放在该数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">//默认为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxsize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxsize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">"栈满了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"栈空了"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> data = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"栈空了"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从栈顶打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">this</span>.stack[i] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1566871784948" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566871784948.png" class="lazyload"></p>
<h2 id="3、模拟计算器"><a href="#3、模拟计算器" class="headerlink" title="3、模拟计算器"></a>3、模拟计算器</h2><p><img alt="1566961103417" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1566961103417.png" class="lazyload"></p>
<h2 id="4、表达式"><a href="#4、表达式" class="headerlink" title="4、表达式"></a>4、表达式</h2><h3 id="1、前缀（波兰）"><a href="#1、前缀（波兰）" class="headerlink" title="1、前缀（波兰）"></a>1、前缀（波兰）</h3><p>1)前缀表达式的运算符位于操作数之前</p>
<p>2)举例说明：(3+4)×5-6 对应的前缀表达式就是*- × + 3 4 56</p>
<p>相当于数的先序遍历（根、左、右）</p>
<h4 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h4><p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<p><img alt="1567041903733" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567041903733.png" class="lazyload"></p>
<h3 id="2、中缀"><a href="#2、中缀" class="headerlink" title="2、中缀"></a>2、中缀</h3><p>1、中缀表达式就是<strong>常见的运算表达式</strong>，如(3+4)×5-6</p>
<p>2、中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，<span style="color:red"><strong>因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)</strong></span></p>
<h3 id="3、后缀（逆波兰）"><a href="#3、后缀（逆波兰）" class="headerlink" title="3、后缀（逆波兰）"></a>3、后缀（逆波兰）</h3><p>1、后缀表达式又称<strong>逆波兰表达式</strong>,与前缀表达式相似，只是运算符位于操作数之后</p>
<p>2、中举例说明： (3+4)×5-6 对应的后缀表达式就是 <strong>3</strong> <strong>4 + 5 × 6</strong> <strong>–</strong></p>
<h4 id="计算过程-1"><a href="#计算过程-1" class="headerlink" title="计算过程"></a>计算过程</h4><p><strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素<br>和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<p><img alt="1567042134351" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567042134351.png" class="lazyload"></p>
<h2 id="5、逆波兰计算器"><a href="#5、逆波兰计算器" class="headerlink" title="5、逆波兰计算器"></a>5、逆波兰计算器</h2><p><strong>思路过程如上计算过程</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName RPNDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/8/29</span></span><br><span class="line"><span class="comment"> * Time      9:34</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 逆波兰式(Reverse Polish notation,RPN,或逆波兰记法)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPNDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义逆波兰表达式(3+4)*5-6  =&gt; 3 4 + 5 × 6 -</span></span><br><span class="line">        String suffixExpression = <span class="string">"3 4 + 5 × 6 - "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、将表达式放到ArrayList中</span></span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、将ArrayList传递给一个方法，配合栈完成计算</span></span><br><span class="line">        System.out.println(<span class="string">"最终结果::"</span>+calcuate(rpnList));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span></span>&#123;</span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(split);</span><br><span class="line">        <span class="comment">//list.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcuate</span><span class="params">(List&lt;String&gt; rpnList)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String num1;</span><br><span class="line">        String num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0;i &lt; rpnList.size();i++)&#123;</span></span><br><span class="line">        <span class="keyword">for</span> (String item : rpnList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOper(item))&#123;<span class="comment">//数值压栈</span></span><br><span class="line">                System.out.println(<span class="string">"!::"</span>+item);</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(item);</span><br><span class="line">                num1 = stack.pop();</span><br><span class="line">                num2 = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> res = cal(Integer.parseInt(num1), Integer.parseInt(num2), item);</span><br><span class="line"></span><br><span class="line">                stack.push(String.valueOf(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.parseInt(stack.pop());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"+"</span>.equals(val) ||  <span class="string">"-"</span>.equals(val) || <span class="string">"×"</span>.equals(val) || <span class="string">"/"</span>.equals(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,String oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"×"</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、中缀转后缀"><a href="#6、中缀转后缀" class="headerlink" title="6、中缀转后缀"></a>6、中缀转后缀</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 <strong>中缀表达式转成后缀表达式</strong>。</p>
<p><strong>具体步骤如下:</strong></p>
<ol>
<li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p>
</li>
<li><p>从左至右扫描中缀表达式；</p>
</li>
<li><p>遇到操作数时，将其压s2；</p>
</li>
<li><p>遇到运算符时，比较其与s1栈顶运算符的优先级：</p>
<ol>
<li>如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1；</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；  </li>
</ol>
</li>
<li><p>遇到括号时：</p>
<ol>
<li>如果是左括号“(”，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li><p>重复步骤2至5，直到表达式的最右边</p>
</li>
<li><p>将s1中剩余的运算符依次弹出并压入s2</p>
</li>
<li><p>依次弹出s2中的元素并输出，<strong>结果的逆序即为中缀表达式对应的后缀表达式</strong></p>
</li>
</ol>
<p><img alt="1567049578081" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567049578081.png" class="lazyload"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName InfixConvertSuffix</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/8/29</span></span><br><span class="line"><span class="comment"> * Time      10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfixConvertSuffixDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String infixExpression = <span class="string">"( 1 + ( ( 2 + 3 ) × 4 ) ) - 5 "</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = calc(infixExpression);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最终结果::"</span>);</span><br><span class="line">        list.forEach(System.out::print);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">calc</span><span class="params">( String infixExpression)</span></span>&#123;</span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">//运算符</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//操作符</span></span><br><span class="line"></span><br><span class="line">        String[] split = infixExpression.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(split);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"("</span>.equals(item))&#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">")"</span>.equals(item))&#123;</span><br><span class="line">                System.out.println(<span class="string">"右括号"</span>);</span><br><span class="line">                <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止</span></span><br><span class="line">                <span class="comment">//将这一对括号丢弃</span></span><br><span class="line">                String curItem = s1.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!<span class="string">"("</span>.equals(curItem))&#123;</span><br><span class="line">                    s2.add(curItem);</span><br><span class="line">                    curItem = s1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//操作数</span></span><br><span class="line">                <span class="comment">//如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈</span></span><br><span class="line">                <span class="keyword">if</span> (s1.size() == <span class="number">0</span> || <span class="string">"("</span>.equals(s1.peek()))&#123;</span><br><span class="line">                    s1.push(item);</span><br><span class="line">                &#125;<span class="keyword">else</span>  <span class="keyword">if</span> (priority(item) &gt; priority(s1.peek()))&#123; <span class="comment">//否则，若优先级比栈顶运算符的高，也将运算符压入s1</span></span><br><span class="line"></span><br><span class="line">                    s1.push(item);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* System.out.println("\n======s1========");</span></span><br><span class="line"><span class="comment">            s1.forEach(System.out::print);</span></span><br><span class="line"><span class="comment">            System.out.println("\n======s2========");</span></span><br><span class="line"><span class="comment">            s2.forEach(System.out::print);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"+"</span>.equals(val) ||  <span class="string">"-"</span>.equals(val) || <span class="string">"×"</span>.equals(val) || <span class="string">"/"</span>.equals(val)</span><br><span class="line">                || <span class="string">"("</span>.equals(val)|| <span class="string">")"</span>.equals(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级由程序员确定，使用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，则优先级越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="string">"×"</span>.equals(oper) || <span class="string">"/"</span>.equals(oper))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"+"</span>.equals(oper) || <span class="string">"-"</span>.equals(oper))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定目前的表达式只有+，-，*，/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1567049345720" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1567049345720.png" class="lazyload"></p>
<h1 id="四、递归"><a href="#四、递归" class="headerlink" title="四、递归"></a>四、递归</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p><strong>递归就是方法自己调用自己,每次调用时传入不同的变量。</strong> 递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p>
<p><img alt="1568340240264" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1568340240264.png" class="lazyload"></p>
<h2 id="2、遵守规则"><a href="#2、遵守规则" class="headerlink" title="2、遵守规则"></a>2、遵守规则</h2><p>1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</p>
<p>2) 方法的局部变量是独立的，不会相互影响, 比如n变量</p>
<p>3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</p>
<p>4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)</p>
<p>5) 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</p>
<h3 id="递归用于解决什么样的问题"><a href="#递归用于解决什么样的问题" class="headerlink" title="递归用于解决什么样的问题"></a>递归用于解决什么样的问题</h3><p>1)各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)</p>
<p>2)各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</p>
<p>3)将用栈解决的问题–&gt;第归代码比较简洁</p>
<h2 id="3、案例：迷宫回溯"><a href="#3、案例：迷宫回溯" class="headerlink" title="3、案例：迷宫回溯"></a>3、案例：迷宫回溯</h2><h3 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>寻找小球能走的路径</p>
<p><img alt="1569117111168" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569117111168.png" class="lazyload"></p>
<h3 id="2、制定规则"><a href="#2、制定规则" class="headerlink" title="2、制定规则"></a>2、制定规则</h3><ol>
<li>map 表示地图</li>
<li>i,j 表示地图的哪个位置开始出发</li>
<li>如果小球能到map [6] [5] ,这说明通路找到</li>
<li>约定：<br>当 map[i] [j]  为0表示没有走过;当为1表示墙;为2表示通路可以走;3表示该点已经走过，但是走不通</li>
<li>在走迷宫时，需要确定一个策略（方法）:下 -&gt; 右 -&gt; 上 -&gt; 左，如果该点走不通，再回溯</li>
</ol>
<p>大致行走路径如下：</p>
<p><img alt="1569117347949" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569117347949.png" class="lazyload"></p>
<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MiGong</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/22</span></span><br><span class="line"><span class="comment"> * Time      9:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//1表示墙</span></span><br><span class="line">        <span class="comment">//上下全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            map[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[j][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//地图情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : ints) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归回溯，给小球找路</span></span><br><span class="line">        setWay(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出新地图，小球走过，并标识过的递归</span></span><br><span class="line">        <span class="comment">//地图情况</span></span><br><span class="line">        System.out.println(<span class="string">"小球走过，并标识过的递归....."</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : ints) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//如果找到，返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// 1. map 表示地图</span></span><br><span class="line">    <span class="comment">// 2. i,j 表示地图的哪个位置开始出发</span></span><br><span class="line">    <span class="comment">// 3. 如果小球能到map[6][5],这说明通路找到</span></span><br><span class="line">    <span class="comment">// 4.约定：</span></span><br><span class="line">    <span class="comment">// 当map[i][j] 为0表示没有走过，当为1表示墙，为2表示通路可以走</span></span><br><span class="line">    <span class="comment">// 3表示该点已经走过，但是走不通</span></span><br><span class="line">    <span class="comment">// 5. 在走迷宫时，需要确定一个策略（方法）</span></span><br><span class="line">    <span class="comment">// 下 -&gt; 右 -&gt; 上 -&gt; 左，如果该点走不通，再回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;<span class="comment">//通路找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>)&#123;<span class="comment">//如果该点没有走过</span></span><br><span class="line">                <span class="comment">//下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map,i+<span class="number">1</span>,j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点走不通</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//map[i][j] != 0  可能1,2,3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1569117441529" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569117441529.png" class="lazyload"></p>
<h2 id="4、八皇后"><a href="#4、八皇后" class="headerlink" title="4、八皇后"></a>4、八皇后</h2><h3 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<p><img alt="1569120210811" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569120210811.png" class="lazyload"></p>
<p><img alt="1569120218024" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569120218024.png" class="lazyload"></p>
<h3 id="2、思路分析"><a href="#2、思路分析" class="headerlink" title="2、思路分析"></a>2、思路分析</h3><p><strong>八皇后问题算法思路分析</strong></p>
<p>1) 第一个皇后先放第一行第一列</p>
<p>2) 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p>
<p>3) 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p>
<p>4) 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p>
<p>5) 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 【示意图】</p>
<p><strong>说明</strong>：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列</p>
<h3 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Queen8</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/22</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Queen8 queen8 = <span class="keyword">new</span> Queen8();</span><br><span class="line">        queen8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放置第n个皇后</span></span><br><span class="line">    <span class="comment">//注意：check是每一次递归时，都会有8个for循环，因此会有回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == max)&#123; <span class="comment">// n = 8，其实8个皇后就已经放好了</span></span><br><span class="line">            print();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前的皇后n 放到该行的第一列</span></span><br><span class="line">            arr[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n))&#123;<span class="comment">//不冲突</span></span><br><span class="line">                <span class="comment">//接着放n+1个</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，继续执行arr[n] = i;即将第n个皇后，放置在本行的后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们防止第n个皇后，就去检测该皇后是否和前面已经摆放的皇后是否冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == arr[n] <span class="comment">//同一列</span></span><br><span class="line">                    || Math.abs(n - i) == Math.abs(arr[n] - arr[i])<span class="comment">//行差距和列差距相同，则在对角线</span></span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，将皇后摆放的位置打印出来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、排序算法"><a href="#五、排序算法" class="headerlink" title="五、排序算法"></a>五、排序算法</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。<br>排序的分类：</p>
<p>1) 内部排序:<br>指将需要处理的所有数据都加载到内部存储器中进行排序。<br>2) 外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储进行<br>排序。<br>3) 常见的排序算法分类(见下图):</p>
<p><img alt="1569221146552" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569221146552.png" class="lazyload"></p>
<h2 id="2、算法——时间复杂度"><a href="#2、算法——时间复杂度" class="headerlink" title="2、算法——时间复杂度"></a>2、算法——时间复杂度</h2><h3 id="1、介绍-6"><a href="#1、介绍-6" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>度量一个程序(算法)执行时间的两种方法</p>
<p>【1】事后统计的方法：</p>
<p>这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, <strong>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</strong></p>
<p>【2】事前估算的方法：</p>
<p>通过分析某个算法的时间复杂度来判断哪个算法更优.</p>
<h3 id="2、时间频度"><a href="#2、时间频度" class="headerlink" title="2、时间频度"></a>2、时间频度</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p><img alt="1569288482554" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288482554.png" class="lazyload"></p>
<h4 id="忽略常数项"><a href="#忽略常数项" class="headerlink" title="忽略常数项"></a>忽略常数项</h4><p><img alt="1569288739590" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288739590.png" class="lazyload"></p>
<h4 id="忽略低次项"><a href="#忽略低次项" class="headerlink" title="忽略低次项"></a>忽略低次项</h4><p><img alt="1569288758914" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288758914.png" class="lazyload"></p>
<h4 id="忽略系数"><a href="#忽略系数" class="headerlink" title="忽略系数"></a>忽略系数</h4><p><img alt="1569288776795" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569288776795.png" class="lazyload"></p>
<h3 id="3、时间复杂度"><a href="#3、时间复杂度" class="headerlink" title="3、时间复杂度"></a>3、时间复杂度</h3><p>【1】一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>【2】T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</p>
<p>【3】计算时间复杂度的方法：</p>
<ul>
<li>用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  =&gt; T(n)=n²+7n+1</li>
<li>修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 =&gt; T(n) = n²</li>
<li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ul>
<h3 id="4、常见"><a href="#4、常见" class="headerlink" title="4、常见"></a>4、常见</h3><p><img alt="1569289528825" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289528825.png" class="lazyload"></p>
<h4 id="1、常数阶"><a href="#1、常数阶" class="headerlink" title="1、常数阶"></a>1、常数阶</h4><p><img alt="1569289932011" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289932011.png" class="lazyload"></p>
<h4 id="2、对数阶"><a href="#2、对数阶" class="headerlink" title="2、对数阶"></a>2、对数阶</h4><p><img alt="1569289945001" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289945001.png" class="lazyload"></p>
<h4 id="3、线性阶"><a href="#3、线性阶" class="headerlink" title="3、线性阶"></a>3、线性阶</h4><p><img alt="1569289962738" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569289962738.png" class="lazyload"></p>
<h4 id="4、线性对数阶"><a href="#4、线性对数阶" class="headerlink" title="4、线性对数阶"></a>4、线性对数阶</h4><p><img alt="1569290040306" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290040306.png" class="lazyload"></p>
<h4 id="5、平方阶"><a href="#5、平方阶" class="headerlink" title="5、平方阶"></a>5、平方阶</h4><p><img alt="1569290207259" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290207259.png" class="lazyload"></p>
<h3 id="5、平均和最坏"><a href="#5、平均和最坏" class="headerlink" title="5、平均和最坏"></a>5、平均和最坏</h3><p><img alt="1569290303436" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290303436.png" class="lazyload"></p>
<h2 id="3、空间复杂度"><a href="#3、空间复杂度" class="headerlink" title="3、空间复杂度"></a>3、空间复杂度</h2><p><img alt="1569290526666" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569290526666.png" class="lazyload"></p>
<h2 id="4、冒泡排序"><a href="#4、冒泡排序" class="headerlink" title="4、冒泡排序"></a>4、冒泡排序</h2><h3 id="1、介绍-7"><a href="#1、介绍-7" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><img alt="1569293021430" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569293021430.png" class="lazyload"></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img alt="1569293098871" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569293098871.png" class="lazyload"></p>
<p>代码如下：优化了规则(3)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BubbleSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/24</span></span><br><span class="line"><span class="comment"> * Time      10:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retSort</span><span class="params">(<span class="keyword">int</span>[] vals)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标识变量，表示是否变换</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.length - <span class="number">1</span>; i++) &#123; <span class="comment">//趟数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vals.length - i -<span class="number">1</span>; j++) &#123; <span class="comment">//需要比较的次数</span></span><br><span class="line">                <span class="keyword">if</span> (vals[j] &gt; vals[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = vals[j];</span><br><span class="line">                    vals[j] = vals[j+<span class="number">1</span>];</span><br><span class="line">                    vals[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟的数据为："</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : vals) &#123;</span><br><span class="line">                System.out.print(val + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!flag)&#123; <span class="comment">//在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">                System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟没有交换，结束"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;<span class="comment">//每趟重置flag，进行下次判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] vals = &#123;<span class="number">35</span>,<span class="number">88</span>,<span class="number">16</span>,<span class="number">27</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">79</span>&#125;;</span><br><span class="line">        retSort(vals);</span><br><span class="line">        System.out.println(Arrays.toString(vals));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1569309952415" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569309952415.png" class="lazyload"></p>
<h2 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1569310313714" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569310313714.png" class="lazyload"></p>
<h4 id="选择排序思路图"><a href="#选择排序思路图" class="headerlink" title="选择排序思路图"></a>选择排序思路图</h4><p><img alt="1569311330048" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569311330048.png" class="lazyload"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName SelectSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/24</span></span><br><span class="line"><span class="comment"> * Time      15:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] vals)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//存储临时值</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;<span class="comment">//存储最小索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.length -<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= vals.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(vals[min] &gt; vals[j]) &#123;</span><br><span class="line">                   min = j;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min != i)&#123; <span class="comment">//有变化</span></span><br><span class="line">                temp = vals[i];</span><br><span class="line">                vals[i] = vals[min];</span><br><span class="line">                vals[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟的数据为："</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : vals) &#123;</span><br><span class="line">                System.out.print(val + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] vals = &#123;<span class="number">35</span>,<span class="number">88</span>,<span class="number">16</span>,<span class="number">27</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">79</span>&#125;;</span><br><span class="line">        selectSort(vals);</span><br><span class="line">        System.out.println(Arrays.toString(vals));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果如下：</p>
<p><img alt="1569313443501" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569313443501.png" class="lazyload"></p>
<h2 id="6、插入排序"><a href="#6、插入排序" class="headerlink" title="6、插入排序"></a>6、插入排序</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1569375679910" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569375679910.png" class="lazyload"></p>
<h4 id="插入排序思路图"><a href="#插入排序思路图" class="headerlink" title="插入排序思路图"></a>插入排序思路图</h4><p><img alt="1569375691590" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569375691590.png" class="lazyload"></p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName InsertSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/24</span></span><br><span class="line"><span class="comment"> * Time      16:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//待插入的数</span></span><br><span class="line">            <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line">            <span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">            <span class="comment">// 说明</span></span><br><span class="line">            <span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">            <span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">            <span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">            <span class="comment">//原理：从待插入数的前一个开始依次向前找，找到insertVal &gt; arr[insertIndex] 就结束</span></span><br><span class="line">            <span class="keyword">while</span>(insertIndex &gt;=<span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex])&#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当退出while循环时，说明插入位置找到，insertIndex+1</span></span><br><span class="line">            arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            <span class="comment">//这里我们判断是否需要赋值</span></span><br><span class="line">            <span class="keyword">if</span>(insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"趟的数据为："</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">17</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">20</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="1569377419326" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569377419326.png" class="lazyload"></p>
<blockquote>
<p>结论：当需要插入的数是较小的时候，后移的次数明显增多，对效率有影响。</p>
</blockquote>
<h2 id="7、希尔排序"><a href="#7、希尔排序" class="headerlink" title="7、希尔排序"></a>7、希尔排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>简单插入排序存在的问题</p>
<p>我们看简单的插入排序可能存在的问题.<br>数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：<br>{2,3,4,5,6,6}<br>{2,3,4,5,5,6}<br>{2,3,4,4,5,6}<br>{2,3,3,4,5,6}<br>{2,2,3,4,5,6}<br>{1,2,3,4,5,6}</p>
<blockquote>
<p>*<em>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</em>。</p>
</blockquote>
<h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1569458492283" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569458492283.png" class="lazyload"></p>
<p><img alt="1569459476636" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1569459476636.png" class="lazyload"></p>
<h3 id="交换法"><a href="#交换法" class="headerlink" title="交换法"></a>交换法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ShellSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/26</span></span><br><span class="line"><span class="comment"> * Time      8:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> gap = arr.length /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//以下就是个内排序（插入是开头连续排序的，二希尔是步长跳跃排序的）</span></span><br><span class="line">            <span class="comment">//有点类似冒泡</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(gap + "::" + j);</span></span><br><span class="line">                    <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                        temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j + gap];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            gap = gap/<span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">"本趟的数据为："</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移动法"><a href="#移动法" class="headerlink" title="移动法"></a>移动法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ShellSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/9/26</span></span><br><span class="line"><span class="comment"> * Time      8:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">                        <span class="comment">//移动</span></span><br><span class="line">                        arr[j] = arr[j-gap];</span><br><span class="line">                        <span class="comment">// 只不过不是连续的，需要gap步长 和插入稍有区别</span></span><br><span class="line">                        j -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        shellSort2(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1570776568054" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1570776568054.png" class="lazyload"></p>
<h2 id="8、快速排序"><a href="#8、快速排序" class="headerlink" title="8、快速排序"></a>8、快速排序</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>​        快速排序（Quicksort）是对<span style="color:red"><strong>冒泡排序的一种改进</strong></span>。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>快速排序法示意图:</p>
<p>以11为基准，随机选取</p>
<p><img alt="1571446578900" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571446578900.png" class="lazyload"></p>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>对 [-9,78,0,23,-567,70] 进行从小到大的排序，要求使用快速排序法</p>
<p><img alt="1571446659266" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571446659266.png" class="lazyload"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName QuickSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/14</span></span><br><span class="line"><span class="comment"> * Time      9:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left; <span class="comment">//左下标</span></span><br><span class="line">        <span class="keyword">int</span> r = right; <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line">        <span class="comment">//比pivot 值大放到右边</span></span><br><span class="line">        <span class="keyword">while</span>( l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span>( arr[l] &lt; pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line">            <span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line">            <span class="keyword">if</span>( l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"本趟的数据为："</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">70</span>&#125;;</span><br><span class="line">        QuickSort.quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9、归并排序"><a href="#9、归并排序" class="headerlink" title="9、归并排序"></a>9、归并排序</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>​            归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><img alt="1571449056725" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449056725.png" class="lazyload"></p>
<h4 id="合并思想"><a href="#合并思想" class="headerlink" title="合并思想"></a>合并思想</h4><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p>
<p>arr[i] &lt; arr[j]的情况</p>
<p><img alt="1571449128168" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449128168.png" class="lazyload"></p>
<p>arr[i] &gt; arr[j]的情况</p>
<p><img alt="1571449134754" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449134754.png" class="lazyload"></p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MergeSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/19</span></span><br><span class="line"><span class="comment"> * Time      9:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分+合方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   中建索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  中转数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">//初始化j, 右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]</span></span><br><span class="line">        <span class="comment">//先把左右两边有序的数据按照规则填充到temp数组中</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">            <span class="comment">//然后 t++, i++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j])&#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]</span></span><br><span class="line">        <span class="comment">//有一边有剩余，将剩余的依次全部填充到temp数组中去</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid) &#123; <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( j &lt;= right) &#123; <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr中</span></span><br><span class="line">        <span class="comment">//注意，并不是每次都拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLeft = left; <span class="comment">//</span></span><br><span class="line">        <span class="comment">//第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span></span><br><span class="line">        <span class="comment">//最后一次 tempLeft = 0  right = 7</span></span><br><span class="line">        System.out.println(<span class="string">"tempLeft::"</span> + tempLeft + <span class="string">" right::"</span> +right);</span><br><span class="line">        <span class="keyword">while</span>(tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            tempLeft += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">//归并排序需要一个额外空间</span></span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1571449674523" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571449674523.png" class="lazyload"></p>
<h2 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</p>
</li>
<li><p>基数排序(Radix Sort)是桶排序的扩展</p>
</li>
<li><p>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
</li>
</ol>
<h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>​        将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p>{53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序</p>
<p>轮数与最高位数有关，最高三位则需要三轮，以此类推</p>
<p><strong>第一轮</strong></p>
<p><img alt="1571453587415" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571453587415.png" class="lazyload"></p>
<p><strong>第二轮</strong></p>
<p><img alt="1571453635718" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571453635718.png" class="lazyload"></p>
<p><strong>第三轮</strong></p>
<p><img alt="1571453647260" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571453647260.png" class="lazyload"></p>
<h3 id="代码实现（自己实现）"><a href="#代码实现（自己实现）" class="headerlink" title="代码实现（自己实现）"></a>代码实现（自己实现）</h3><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName RadixSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/19</span></span><br><span class="line"><span class="comment"> * Time      10:06</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int wanWei=num/10000;</span></span><br><span class="line"><span class="comment"> *     int qianWei=num%10000/1000;</span></span><br><span class="line"><span class="comment"> *     int baiWei=num%1000/100;</span></span><br><span class="line"><span class="comment"> *     int shiWei=num%100/10;</span></span><br><span class="line"><span class="comment"> *     int geWei=num%10;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> arr[][])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  递归方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> num,<span class="keyword">int</span> sum,<span class="keyword">int</span>[][] bucket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">3</span>) <span class="comment">//[0]达到最高位时结束递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]清空bucket</span></span><br><span class="line">        clear(bucket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要维护每个桶中有多少元素，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]按照位数放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = arr[i] % num / (num / <span class="number">10</span>);  <span class="comment">//确定位数</span></span><br><span class="line">            bucket[v][bucketElementCounts[v]] = arr[i]; <span class="comment">//根据位数放入值，</span></span><br><span class="line">            bucketElementCounts[v] += <span class="number">1</span>;<span class="comment">//桶里放值 +1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int[] b : bucket)</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(b));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(bucketElementCounts));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]将桶中数据依次copy会arr中</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123; <span class="comment">//桶个数循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketElementCounts[i]; j++) &#123; <span class="comment">//每桶的总个数循环</span></span><br><span class="line">                arr[index] = bucket[i][j];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"每次位数排序后arr结果："</span>+Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        sum++;</span><br><span class="line">        <span class="comment">//[4]递归</span></span><br><span class="line">        radix(arr,num * <span class="number">10</span> ,sum,bucket);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//最高位数index 即需要几轮排序</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        radix(arr,<span class="number">10</span>,sum,bucket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName RadixSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/19</span></span><br><span class="line"><span class="comment"> * Time      10:06</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int wanWei=num/10000;</span></span><br><span class="line"><span class="comment"> *     int qianWei=num%10000/1000;</span></span><br><span class="line"><span class="comment"> *     int baiWei=num%1000/100;</span></span><br><span class="line"><span class="comment"> *     int shiWei=num%100/10;</span></span><br><span class="line"><span class="comment"> *     int geWei=num%10;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> arr[][])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  非递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   原数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num   除余的基数10</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum   循环的最高位数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> num,<span class="keyword">int</span> sum,<span class="keyword">int</span>[][] bucket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> max = <span class="number">0</span>; max &lt; sum; max++) &#123;</span><br><span class="line">            num = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,(max+<span class="number">1</span>));<span class="comment">// 10 100 1000</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">            <span class="comment">//[1]清空bucket</span></span><br><span class="line">            clear(bucket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要维护每个桶中有多少元素，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">            <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//[2]按照位数放入桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = arr[i] % num / (num / <span class="number">10</span>);  <span class="comment">//确定位数</span></span><br><span class="line">                bucket[v][bucketElementCounts[v]] = arr[i]; <span class="comment">//根据位数放入值，</span></span><br><span class="line">                bucketElementCounts[v] += <span class="number">1</span>;<span class="comment">//桶里放值 +1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//[3]将桶中数据依次copy会arr中</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123; <span class="comment">//桶个数循环</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketElementCounts[i]; j++) &#123; <span class="comment">//每桶的总个数循环</span></span><br><span class="line">                    arr[index] = bucket[i][j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"每次位数排序后arr结果："</span>+Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        radix2(arr,<span class="number">10</span>,<span class="number">3</span>,bucket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>基数排序是对传统桶排序的扩展，<strong>速度很快.</strong></li>
<li><strong>基数排序是经典的空间换时间的方式</strong>，<strong>占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError</strong> 。例如：int[] arr = new int[8000000]， 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </li>
<li>基数排序时稳定的。[ 注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的 ]</li>
<li>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a> </li>
</ol>
<h2 id="排序算法对比"><a href="#排序算法对比" class="headerlink" title="排序算法对比"></a>排序算法对比</h2><p><img alt="1571552208801" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571552208801.png" class="lazyload"></p>
<p><strong>相关术语解释：</strong></p>
<p>[1] 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br>[2] 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；<br>[3] 内排序：所有排序操作都在内存中完成；<br>[4] 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p>[5] 时间复杂度： 一个算法执行所耗费的时间。<br>[6] 空间复杂度：运行完一个程序所需内存的大小。<br>[7] n: 数据规模<br>[8] k: “桶”的个数<br>[9] In-place:    不占用额外内存<br>[10] Out-place: 占用额外内存</p>
<h1 id="六、查找算法"><a href="#六、查找算法" class="headerlink" title="六、查找算法"></a>六、查找算法</h1><h2 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h2><p>在java中，我们常用的查找有四种:<br>    1) 顺序(线性)查找<br>    2) 二分查找/折半查找<br>   3) 插值查找<br>   4) 斐波那契查找</p>
<h2 id="1、线性查找"><a href="#1、线性查找" class="headerlink" title="1、线性查找"></a>1、线性查找</h2><p>逐一比对，发现相同值就返回下标</p>
<p><img alt="1571552672463" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571552672463.png" class="lazyload"></p>
<h2 id="2、折半查找"><a href="#2、折半查找" class="headerlink" title="2、折半查找"></a>2、折半查找</h2><p>请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。</p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            System.out.println(<span class="string">"not find..."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; arr[mid])&#123; <span class="comment">//左递归</span></span><br><span class="line"><span class="comment">//            right = mid - 1 ;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, left, mid, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; arr[mid])&#123; <span class="comment">//右递归</span></span><br><span class="line"><span class="comment">//            left = mid + 1;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, mid, right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"find index::"</span>+mid);</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        binary(arr,<span class="number">0</span>,arr.length,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.</p>
<p>思路：</p>
<p>已知找到1000的索引位置，数组也是有序的，那么分别向左和向右遍历，相同就记录下来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            System.out.println(<span class="string">"not find..."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; arr[mid])&#123; <span class="comment">//左递归</span></span><br><span class="line"><span class="comment">//            right = mid - 1 ;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, left, mid, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; arr[mid])&#123; <span class="comment">//右递归</span></span><br><span class="line"><span class="comment">//            left = mid + 1;</span></span><br><span class="line">            <span class="keyword">return</span> binary(arr, mid, right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"find index::"</span>+mid);</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成一个课后思考题:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment">     * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">search</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; idx = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       idx.add(index);<span class="comment">//本身找到的index位置也要放入</span></span><br><span class="line">       <span class="keyword">int</span> left_temp = index - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//向左遍历</span></span><br><span class="line">       <span class="keyword">while</span> (left_temp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val == arr[left_temp])&#123;</span><br><span class="line">               idx.add(left_temp);</span><br><span class="line">               left_temp--;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> right_temp = index + <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//向右遍历</span></span><br><span class="line">       <span class="keyword">while</span> (right_temp&lt;=arr.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val == arr[right_temp])&#123;</span><br><span class="line">               idx.add(right_temp);</span><br><span class="line">               right_temp++;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> idx;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = binary(arr,<span class="number">0</span>,arr.length,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        search(arr,index,<span class="number">1000</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="1571554732074" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571554732074.png" class="lazyload"></p>
<h2 id="3、插值查找"><a href="#3、插值查找" class="headerlink" title="3、插值查找"></a>3、插值查找</h2><h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1571555508408" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571555508408.png" class="lazyload"></p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName InsertSearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编写插值查找算法</span></span><br><span class="line">    <span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插值查找次数~~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line">        <span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出mid, 自适应</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>,<span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">1234</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、斐波那契查找"><a href="#4、斐波那契查找" class="headerlink" title="4、斐波那契查找"></a>4、斐波那契查找</h2><h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="1571556883869" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571556883869.png" class="lazyload"></p>
<h3 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h3><p>先将数组扩展成符合斐波那契形式，然后按照斐波那契的分割方式来确定mid</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName FibonacciSearch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/20</span></span><br><span class="line"><span class="comment"> * Time      15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line">    <span class="comment">//非递归方法得到一个斐波那契数列   1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ........</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写斐波那契查找算法</span></span><br><span class="line">    <span class="comment">//使用非递归的方式编写算法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a  数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//存放mid值</span></span><br><span class="line">        <span class="keyword">int</span> f[] = fib(); <span class="comment">//获取到斐波那契数列</span></span><br><span class="line">        <span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">        <span class="comment">//不足的部分会使用0填充</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">        <span class="comment">//实际上需求使用a数组最后的数填充 temp</span></span><br><span class="line">        <span class="comment">//举例:</span></span><br><span class="line">        <span class="comment">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = a[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为甚是 k--</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line">                <span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line">                <span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line">                <span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k -=2</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line">                <span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span></span><br><span class="line">                <span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line">                <span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line">                <span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"index="</span> + fibSearch(arr, <span class="number">89</span>));<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七、哈希表"><a href="#七、哈希表" class="headerlink" title="七、哈希表"></a>七、哈希表</h1><h2 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p><strong>哈希表存放在内存中，速度快</strong></p>
<p><img alt="1571559206279" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571559206279.png" class="lazyload"></p>
<p>缓存层的意义<br><img alt="1571559452930" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571559452930.png" class="lazyload"></p>
<h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p><img alt="1571622722516" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571622722516.png" class="lazyload"></p>
<h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.</p>
<p>要求: 不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)</p>
<h2 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1、Emp对象"><a href="#1、Emp对象" class="headerlink" title="1、Emp对象"></a>1、Emp对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Emp</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Emp&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、EmpLinkedList"><a href="#2、EmpLinkedList" class="headerlink" title="2、EmpLinkedList"></a>2、EmpLinkedList</h3><p>每条索引的链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName EmpLinkedList</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp</span></span><br><span class="line">    <span class="comment">//private Emp head; //默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用java的LinkedList</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Emp&gt; empLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员到链表</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line">    <span class="comment">//   因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        empLinkedList.add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">find</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : empLinkedList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (findId == emp.getId())&#123;</span><br><span class="line">                <span class="keyword">return</span> emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : empLinkedList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (findId == emp.getId())&#123;</span><br><span class="line">                empLinkedList.remove(emp);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : empLinkedList)&#123;</span><br><span class="line">            System.out.print(emp.toString() + <span class="string">'\t'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、HashTab"><a href="#3、HashTab" class="headerlink" title="3、HashTab"></a>3、HashTab</h3><p>创建HashTab，包含所有的EmpLinkedList的头信息组成的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HashTab</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:15</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建HashTab 管理多条链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化empLinkedListArray</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写散列函数, 使用一个简单取模法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据员工的id ,得到该员工应当添加到哪条链表</span></span><br><span class="line">        <span class="keyword">int</span> id = emp.getId();</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(id);</span><br><span class="line">        empLinkedListArray[index].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">find</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(findId);</span><br><span class="line">        Emp emp = empLinkedListArray[index].find(findId);</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(findId);</span><br><span class="line">        <span class="keyword">return</span> empLinkedListArray[index].del(findId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; size;i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">"第"</span>+i+<span class="string">"条::"</span>);</span><br><span class="line">            empLinkedListArray[i].list();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//=======================================</span></span><br><span class="line">        HashTab empHashTab = <span class="keyword">new</span> HashTab(<span class="number">4</span>);</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">1</span>,<span class="string">"张三"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">2</span>,<span class="string">"李四"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">3</span>,<span class="string">"王五"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">4</span>,<span class="string">"jack"</span>));</span><br><span class="line"></span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">5</span>,<span class="string">"张三2"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">6</span>,<span class="string">"李四2"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">8</span>,<span class="string">"王五2"</span>));</span><br><span class="line">        empHashTab.add(<span class="keyword">new</span> Emp(<span class="number">9</span>,<span class="string">"jack2"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        empHashTab.list();</span><br><span class="line">        empHashTab.del(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        empHashTab.list();</span><br><span class="line">        Emp emp = empHashTab.find(<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        System.out.println(emp.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1571622893210" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571622893210.png" class="lazyload"></p>
<h1 id="八、树结构"><a href="#八、树结构" class="headerlink" title="八、树结构"></a>八、树结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="使用数结构的原因"><a href="#使用数结构的原因" class="headerlink" title="使用数结构的原因"></a>使用数结构的原因</h3><p><img alt="1571642772893" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571642772893.png" class="lazyload"></p>
<p><img alt="1571642788098" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571642788098.png" class="lazyload"></p>
<p><img alt="1571642804730" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571642804730.png" class="lazyload"></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img alt="1571643339729" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571643339729.png" class="lazyload"></p>
<h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><p>1、树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。<br>2、二叉树的子节点分为左节点和右节点。</p>
<p><img alt="image-20191024153847814" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024153847814.png" class="lazyload"></p>
<p>3、如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为<strong>满二叉树</strong>。</p>
<p>4、如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为<strong>完全二叉树（叶子结点连续）</strong>。</p>
<p><img alt="1571643531652" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571643531652.png" class="lazyload"></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>先序遍历：先输出父节点，在遍历左子树和右子树</p>
<p>中序遍历：先遍历左子树，再输出父节点，在遍历右子树</p>
<p>后序遍历：先遍历左子树，再遍历右子树，最后输出父节点</p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>使用前序，中序和后序对下面的二叉树进行遍历.</p>
<p><img alt="1571649194257" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571649194257.png" class="lazyload"></p>
<p><img alt="image-20191024161333744" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024161333744.png" class="lazyload"></p>
<h3 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1、HeroNode对象节点"><a href="#1、HeroNode对象节点" class="headerlink" title="1、HeroNode对象节点"></a>1、HeroNode对象节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HeroNode</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归右字数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="comment">//递归右字数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、BinaryTree类"><a href="#2、BinaryTree类" class="headerlink" title="2、BinaryTree类"></a>2、BinaryTree类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      10:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的结点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="1571813629696" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1571813629696.png" class="lazyload"></p>
<h2 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p><img alt="image-20191024154217973" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024154217973.png" class="lazyload"></p>
<h3 id="查找思想"><a href="#查找思想" class="headerlink" title="查找思想"></a>查找思想</h3><p><strong>和遍历类似，只不过将输出段变成查找判断</strong></p>
<p><img alt="image-20191024155817317" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024155817317.png" class="lazyload"></p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preSearch</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line">    <span class="keyword">if</span>(findId == <span class="keyword">this</span>.id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">    <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//[1]递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.left.preSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="keyword">null</span>)&#123;<span class="comment">//左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]递归右子树</span></span><br><span class="line">    <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">    <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.right.preSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixSearch</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">    <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//[1]递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.left.infixSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="keyword">null</span>)&#123;<span class="comment">//左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"进入中序查找"</span>);</span><br><span class="line">    <span class="keyword">if</span>(findId == <span class="keyword">this</span>.id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]递归右子树</span></span><br><span class="line">    <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">    <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.right.infixSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postSearch</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">    <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//[1]递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.left.postSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="keyword">null</span>)&#123;<span class="comment">//左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]递归右子树</span></span><br><span class="line">    <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">    <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode =  <span class="keyword">this</span>.right.postSearch(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line">    <span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">    <span class="keyword">if</span>(findId == <span class="keyword">this</span>.id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="image-20191024160045619" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024160045619.png" class="lazyload"></p>
<h2 id="二叉树删除"><a href="#二叉树删除" class="headerlink" title="二叉树删除"></a>二叉树删除</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>此处的删除要求如下：</p>
<p><img alt="image-20191024162424289" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024162424289.png" class="lazyload"></p>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p><img alt="image-20191024164107290" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024164107290.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">[1] 判断是否为空树 只有一个root节点，置空</span><br><span class="line"></span><br><span class="line">[2] 二叉树是单向，只能借助父节点去删除子节点</span><br><span class="line"></span><br><span class="line">[3] 判断this.left!=null &amp;&amp; this.left.val == id</span><br><span class="line">		this.left = null;</span><br><span class="line">	else 返回</span><br><span class="line"></span><br><span class="line">[4] 判断this.right!=null &amp;&amp; this.right.val == id</span><br><span class="line">		this.right = null;</span><br><span class="line">	else 返回</span><br><span class="line">	</span><br><span class="line">[5] 没删除节点 继续递归[3] 和 [4]</span><br></pre></td></tr></table></figure>



<h3 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="HeroNode类"><a href="#HeroNode类" class="headerlink" title="HeroNode类"></a>HeroNode类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -------------------------删除--------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//递归删除结点</span></span><br><span class="line"><span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">			5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.id == findId)&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.id == findId)&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.delNode(findId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.delNode(findId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BinaryTree"><a href="#BinaryTree" class="headerlink" title="BinaryTree"></a>BinaryTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> findId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(root.getId() == findId)&#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.delNode(findId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"空树，不能删除"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Test类"><a href="#Test类" class="headerlink" title="Test类"></a>Test类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------删除节点-----------------------------</span></span><br><span class="line">System.out.println(<span class="string">"删除前..................."</span>);</span><br><span class="line">binaryTree.preOrder();<span class="comment">//1,2,3,5,4</span></span><br><span class="line"><span class="comment">//        binaryTree.delNode(5);</span></span><br><span class="line">binaryTree.delNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除后..................."</span>);</span><br><span class="line">binaryTree.preOrder();<span class="comment">//1,2,3,4</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191024171717983" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191024171717983.png" class="lazyload"></p>
<h2 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h2><h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><p>数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看示意图。</p>
<p><strong>顺序存储二叉树的特点:</strong></p>
<p>[1] 顺序二叉树通常只考虑完全二叉树<br>[2] 第n个元素的左子节点为  2 * n + 1<br>[3] 第n个元素的右子节点为  2 * n + 2<br>[4] 第n个元素的父节点为  (n-1) / 2</p>
<p>[5] n : 表示二叉树中的第几个元素(按0开始编号如图所示)</p>
<p><img alt="image-20191104082544384" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104082544384.png" class="lazyload"></p>
<p>要求:<br>[1] 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]<br>[2] 要求在遍历数组 arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</p>
<h3 id="案例：顺序存储二叉树遍历"><a href="#案例：顺序存储二叉树遍历" class="headerlink" title="案例：顺序存储二叉树遍历"></a>案例：顺序存储二叉树遍历</h3><h4 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h4><p>​     给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为 1,2,4,5,3,6,7</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ArrBinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/4</span></span><br><span class="line"><span class="comment"> * Time      8:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载preOrder方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成顺序存储的前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"数组为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(arr[index]+ <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span>*index + <span class="number">1</span>) &lt; arr.length)&#123;<span class="comment">//防止越界</span></span><br><span class="line">            preOrder(<span class="number">2</span>*index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span>*index + <span class="number">2</span>) &lt; arr.length) &#123;<span class="comment">//防止越界</span></span><br><span class="line">            preOrder(<span class="number">2</span>*index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr  = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line"></span><br><span class="line">        arrBinaryTree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191104084009952" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104084009952.png" class="lazyload"></p>
<h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7</p>
<p><img alt="image-20191104085623151" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104085623151.png" class="lazyload"></p>
<p>问题分析:<br>【1】当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }<br>【2】但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.<br>【3】如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?<br>【4】解决方案-线索二叉树</p>
<h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><p>【1】<strong>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。</strong>利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</p>
<p>【2】这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</p>
<p>【3】一个结点的前一个结点，称为前驱结点<br>【4】一个结点的后一个结点，称为后继结点</p>
<h3 id="案例：中序线索二叉树"><a href="#案例：中序线索二叉树" class="headerlink" title="案例：中序线索二叉树"></a>案例：中序线索二叉树</h3><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p><img alt="image-20191104090138746" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104090138746.png" class="lazyload"></p>
<p><img alt="image-20191104090221207" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104090221207.png" class="lazyload"></p>
<p><strong>说明: 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况:</strong><br>【1】 left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.<br>【3】right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="HeroNode"><a href="#HeroNode" class="headerlink" title="HeroNode"></a>HeroNode</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HeroNode</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">// leftType == 0 表示指向左子树    1 表示前驱节点</span></span><br><span class="line">    <span class="comment">// rightType == 0 表示指向右子树    1 表示后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="ThreadedBinaryTree"><a href="#ThreadedBinaryTree" class="headerlink" title="ThreadedBinaryTree"></a>ThreadedBinaryTree</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建给当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNode</span><span class="params">(HeroNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果node==null 不能线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一、先线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//二、线索化当前节点</span></span><br><span class="line">        <span class="comment">//先处理当前节点的前驱节点</span></span><br><span class="line">        <span class="comment">//以8节点来理解</span></span><br><span class="line">        <span class="comment">//8节点的left指向空</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前节点的做指针类型</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在处理当前节点的后继节点  利用下次的节点来指向</span></span><br><span class="line">        <span class="comment">//以3节点来理解	pre为8节点，将8节点的右边指向当前3节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//让前驱节点的有指针指向当前节点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱节点的有指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//三、线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ThreadedBinaryTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/4</span></span><br><span class="line"><span class="comment"> * Time      9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试中序线索二叉树</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"jack"</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"smith"</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"marry"</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"king"</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"dim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中序线索化</span></span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试: 以10号节点测试</span></span><br><span class="line">        HeroNode leftNode = node5.getLeft();</span><br><span class="line">        HeroNode rightNode = node5.getRight();</span><br><span class="line">        System.out.println(<span class="string">"10号结点的前驱结点是 ="</span>  + leftNode); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">"10号结点的后继结点是="</span>  + rightNode); <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191104145623072" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104145623072.png" class="lazyload"></p>
<h3 id="遍历线索化二叉树（中序）"><a href="#遍历线索化二叉树（中序）" class="headerlink" title="遍历线索化二叉树（中序）"></a>遍历线索化二叉树（中序）</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>[1]从根开始遍历左节点，当leftType == 1时，结束遍历</p>
<p>[2] 打印当前节点</p>
<p>[3]查看当前节点是否有后继节点 rightType == 1，若有，node = node.getRight();进入下一个循环[2]</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p><span style="color:red">在上述案例的基础进行的改进</span></p>
<h5 id="ThreadedBinaryTree类"><a href="#ThreadedBinaryTree类" class="headerlink" title="ThreadedBinaryTree类"></a>ThreadedBinaryTree类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinaryTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/10/21</span></span><br><span class="line"><span class="comment"> * Time      15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建给当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化是，pre总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//*****遍历线索化二叉树的方法***************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line"></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span>( node!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType == 1 的结点，第一个找到就是8节点</span></span><br><span class="line">            <span class="comment">//后面随着遍历二变化，因为当leftType == 1时，说明该节点是按照线索化</span></span><br><span class="line">            <span class="comment">// 处理后的有效节点</span></span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印当前这个节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前节点的有指针指向的是后继节点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//获取当前节点的后继节点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//替换这个遍历的节点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line">	..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.threadedbinary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ThreadedBinaryTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/4</span></span><br><span class="line"><span class="comment"> * Time      9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">        ...............</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线索化二叉树后，能在使用原来的遍历方法</span></span><br><span class="line">        <span class="comment">//threadedBinaryTree.infixOrder();</span></span><br><span class="line">        System.out.println(<span class="string">"使用线索化的方式遍历 线索化二叉树"</span>);</span><br><span class="line">        threadedBinaryTree.threadedList(); <span class="comment">// 8, 3, 10, 1, 14, 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="九、树结构实际应用"><a href="#九、树结构实际应用" class="headerlink" title="九、树结构实际应用"></a>九、树结构实际应用</h1><h2 id="1、堆排序"><a href="#1、堆排序" class="headerlink" title="1、堆排序"></a>1、堆排序</h2><h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h3><p>【1】堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
<p>【2】堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
<p>【3】每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
<p>【4】大顶堆举例说明</p>
<p><img alt="image-20191104154231817" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104154231817.png" class="lazyload"></p>
<p>【5】小顶堆：<code>arr[i] &lt;= arr[2*i+1] &amp;&amp; arr[i] &lt;= arr[2*i+2] // i对应第几个节点</code>，i从0开始编号</p>
<p>大顶堆：<code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code></p>
<p>【6】<strong>一般升序采用大顶堆，降序采用小顶堆</strong> </p>
<p><img alt="image-20191104162430134" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191104162430134.png" class="lazyload"></p>
<h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>堆排序的基本思想是：<br>【1】将待排序序列构造成一个大顶堆<br>【2】此时，整个序列的最大值就是堆顶的根节点。<br>【3】将其与末尾元素进行交换，此时末尾就为最大值。<br>【4】然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p> <img alt="img" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20180908013007479.gif" class="lazyload"> </p>
<h3 id="堆排序步骤"><a href="#堆排序步骤" class="headerlink" title="堆排序步骤"></a>堆排序步骤</h3><h4 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h4><p>构造初始堆，将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆）</p>
<p>原始数组 [ 4 , 6 , 8 , 5 , 9 ]</p>
<p>【1】假设给定无序序列如下</p>
<img alt="image-20191105093113140" style="zoom:80%;" data-src="/images/Java数据结构与算法/image-20191105093113140.png" class="lazyload">

<p>【2】此时我们从最后一个非叶子节点开始（叶子结点不用调整，第一个非叶子节点公式：arr.length / 2 - 1 = 5 / 2 - 1 = 1,6节点）。从左至右，从下至上进行调整</p>
<p><img alt="image-20191105093257906" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093257906.png" class="lazyload"></p>
<p>【3】找到第二个非叶子节点4，由于[ 4 , 8 , 9 ] 中9最大，4和9交换</p>
<p><img alt="image-20191105093434647" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093434647.png" class="lazyload"></p>
<p>【4】交换导致子根[ 4 , 5 , 6 ]结构混乱，继续调整，[ 4 , 5 , 6 ] 中 6 最大，交换 4 和 6</p>
<p><img alt="image-20191105093538603" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093538603.png" class="lazyload"></p>
<p>此时，无序序列改造成了一个大顶堆</p>
<h4 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h4><p>将堆顶元素与莫为元素进行交换，是末尾元素最大，然后继续调整堆，再将堆顶元素与莫为元素交换，得到第二大元素，反复进行交换、重建、交换</p>
<p>【1】将堆顶元素9和末尾元素4进行交换</p>
<p><img alt="image-20191105093758144" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093758144.png" class="lazyload"></p>
<p>【2】重建</p>
<p><img alt="image-20191105093825948" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093825948.png" class="lazyload"></p>
<p>【3】8和5交换</p>
<p><img alt="image-20191105093845108" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105093845108.png" class="lazyload"></p>
<p>【4】反复继续</p>
<img alt="image-20191105093911918" style="zoom:80%;" data-src="/images/Java数据结构与算法/image-20191105093911918.png" class="lazyload">







<h3 id="代码——大顶堆升序"><a href="#代码——大顶堆升序" class="headerlink" title="代码——大顶堆升序"></a>代码——大顶堆升序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.Tree.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HeapSort</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/5</span></span><br><span class="line"><span class="comment"> * Time      8:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"堆排序!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        //分步完成</span></span><br><span class="line"><span class="comment">        adjustHeap(arr,1,arr.length);</span></span><br><span class="line"><span class="comment">        System.out.println("第一次" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //分步完成</span></span><br><span class="line"><span class="comment">        adjustHeap(arr,0,arr.length);</span></span><br><span class="line"><span class="comment">        System.out.println("第二次" + Arrays.toString(arr));*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成我们最终代码</span></span><br><span class="line">        <span class="comment">//[1] 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组:"</span> + Arrays.toString(arr)); <span class="comment">//大顶堆</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*[2]</span></span><br><span class="line"><span class="comment">		 * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment">　　	 * 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length-<span class="number">1</span>;j &gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"数组="</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个数组，调整成一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：完成 将以i 指向的对应的非叶子节点的树，调整成大顶堆</span></span><br><span class="line"><span class="comment">     * 举例  int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125;</span></span><br><span class="line"><span class="comment">     * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   待调整数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i     表示非叶子节点索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   表示对多少个元素进行调整，逐渐减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">// 先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="comment">//开始调整</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>;k &lt; len;k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( k+<span class="number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>])&#123;<span class="comment">////说明左子结点的值小于右子结点的值</span></span><br><span class="line">                k++; <span class="comment">//k 指向右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; temp)&#123; <span class="comment">//如果子结点大于父结点</span></span><br><span class="line">                arr[i] = arr[k]; <span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">                i = k; <span class="comment">//!!! i 指向 k,继续循环比较</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">        System.out.println(<span class="string">"adjustHeap::数组="</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//要求将数组进行升序排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、赫夫曼树"><a href="#2、赫夫曼树" class="headerlink" title="2、赫夫曼树"></a>2、赫夫曼树</h2><h3 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h3><p>[1] 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的<strong>带权路径长度(wpl)</strong>达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</p>
<p>[2] 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>1、路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</p>
<p>2、结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</p>
<p>3、树的带权路径长度：<strong>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length)</strong> ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
<p>4、<strong>WPL最小的就是赫夫曼树</strong></p>
<p><img alt="image-20191105100317226" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105100317226.png" class="lazyload"></p>
<h3 id="创建赫夫曼树"><a href="#创建赫夫曼树" class="headerlink" title="创建赫夫曼树"></a>创建赫夫曼树</h3><p>构成赫夫曼树的步骤：</p>
<p>1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树<br>2) 取出根节点权值最小的两颗二叉树<br>3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </p>
<p>4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
<p>案例：</p>
<p>如何构建一颗 赫夫曼树的步骤</p>
<p>13, 7, 8, 3, 29, 6, 1</p>
<p>排序<br>1, 3, 6, 7, 8, 13, 29 </p>
<p><img alt="image-20191105101207134" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105101207134.png" class="lazyload"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.huffmantree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HuffmanTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/5</span></span><br><span class="line"><span class="comment"> * Time      10:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        Node root = createHuffmanTree(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        preOrder(root); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个前序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"是空树，不能遍历~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为了操作方便</span></span><br><span class="line">        <span class="comment">//1、遍历arr数组</span></span><br><span class="line">        <span class="comment">//2、将arr每个元素构成一个Node</span></span><br><span class="line">        <span class="comment">//3、将Node放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : arr)&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排序从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"nodes::"</span> + nodes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//去除根节点全值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">//[1] 取出全值最小的节点</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//[2] 取出全值次小的节点</span></span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//[3]构造一颗新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line"></span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//[4]从arraylist删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//[5]将parent加入arraylist</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"第一次处理后::nodes::"</span> + nodes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回哈夫曼树的root节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结点类</span></span><br><span class="line"><span class="comment">// 为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">// 让Node 实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123; <span class="comment">//理论上不打印和的节点</span></span><br><span class="line">            System.out.print(<span class="keyword">this</span> + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"value="</span> + value +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191105103436932" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191105103436932.png" class="lazyload"></p>
<h2 id="3、赫夫曼编码"><a href="#3、赫夫曼编码" class="headerlink" title="3、赫夫曼编码"></a>3、赫夫曼编码</h2><h3 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h3><p>[1] 赫夫曼编码也翻译为    哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法<br>[2] 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</p>
<p>[3] 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间<br>[4] 赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img alt="image-20191106090353546" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090353546.png" class="lazyload"></p>
<p><img alt="image-20191106090500829" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090500829.png" class="lazyload"></p>
<p><img alt="image-20191106090538052" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090538052.png" class="lazyload"></p>
<h3 id="赫夫曼编码步骤"><a href="#赫夫曼编码步骤" class="headerlink" title="赫夫曼编码步骤"></a>赫夫曼编码步骤</h3><h4 id="1、构成赫夫曼树"><a href="#1、构成赫夫曼树" class="headerlink" title="1、构成赫夫曼树"></a>1、构成赫夫曼树</h4><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>1) i like like like java do you like a java    </p>
<p>2)  d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数</p>
<p>3)  按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 </p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>构成赫夫曼树的步骤：</p>
<p>1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p>
<p>2) 取出根节点权值最小的两颗二叉树 </p>
<p>3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </p>
<p>4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
<p><img alt="image-20191106090804047" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191106090804047.png" class="lazyload"></p>
<h4 id="2、规定编码"><a href="#2、规定编码" class="headerlink" title="2、规定编码"></a>2、规定编码</h4><p>【1】根据赫夫曼树，给各个字符,规定编码 (前缀编码)， <strong>向左的路径为0 向右的路径为1</strong> ， 编码如下:<br>o: 1000   u: 10010  d: 100110  y: 100111  i: 101<br>a : 110     k: 1110    e: 1111       j: 0000       v: 0001<br>l: 001          : 01</p>
<p>【2】 按照上面的赫夫曼编码，我们的”i like like like java do you like a java”   字符串对应的编码为 (注意这里我们使用的无损压缩)<br>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110  通过赫夫曼编码处理  长度为  133</p>
<p>【3】 长度为 ： 133<br>说明:<br>原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%<br>此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性<br>赫夫曼编码是无损处理方案</p>
<h3 id="赫夫曼编码与解码"><a href="#赫夫曼编码与解码" class="headerlink" title="赫夫曼编码与解码"></a>赫夫曼编码与解码</h3><h4 id="1、编码"><a href="#1、编码" class="headerlink" title="1、编码"></a>1、编码</h4><p>【1】字符串转成字节数组</p>
<p>【2】将字节数组构建成nodes节点的集合</p>
<p>【3】根据nodes集合创建赫夫曼树</p>
<p>【4】生成赫夫曼编码</p>
<p>【5】压缩赫夫曼编码，形成赫夫曼编码字节数组</p>
<h4 id="2、解码"><a href="#2、解码" class="headerlink" title="2、解码"></a>2、解码</h4><p>【1】赫夫曼编码字节数组转成二进制字符串（赫夫曼编码）</p>
<p>【2】赫夫曼编码key与value对换，反向解码</p>
<p>【3】裁减二进制字符串与赫夫曼编码进行匹配，并将其存入集合中</p>
<p>【4】将集合转成字节数组，最终转成字符数组，解码完成</p>
<h4 id="3、完整代码"><a href="#3、完整代码" class="headerlink" title="3、完整代码"></a>3、完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.huffmancode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName HuffmanCode</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/6</span></span><br><span class="line"><span class="comment"> * Time      8:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,Integer&gt; <span class="title">countMap</span><span class="params">(<span class="keyword">byte</span>[] str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Byte,Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;Byte,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!counts.containsKey(str[i]))&#123;</span><br><span class="line">                counts.put(str[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> count = counts.get(str[i]) + <span class="number">1</span>;</span><br><span class="line">                counts.put(str[i],count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计字符出现的次数</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = countMap(bytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每个键值对转成Node对象，并加入到nodes集合</span></span><br><span class="line">        counts.forEach((k,v)-&gt;&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(k,v));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println("nodes::"+nodes);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            Collections.sort(nodes); <span class="comment">//根据node对象的compareTo方法进行排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">            Node left = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第二颗最小的二叉树</span></span><br><span class="line">            Node right = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，根节点没有data，只有权值</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>,left.getWeight() + right.getWeight()  );</span><br><span class="line">            parent.setLeft(left);</span><br><span class="line">            parent.setRight(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将新的二叉树，加入到nodes</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nodes 最后的结点，就是赫夫曼树的根结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路:</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式</span></span><br><span class="line">    <span class="comment">//   生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte, String&gt;  <span class="title">getCode</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.getLeft(),<span class="string">"0"</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.getRight(),<span class="string">"1"</span>, stringBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*huffmanCodes.forEach((k,v)-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(k + "::" + v);</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取编码  拼接编码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node,String code,StringBuilder stringBuilder)</span></span>&#123;</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        <span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//如果node == null不处理</span></span><br><span class="line">            <span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(node.getData() == <span class="keyword">null</span>)&#123; <span class="comment">//非叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    getCodes(node.getLeft(),<span class="string">"0"</span>,stringBuilder2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    getCodes(node.getRight(),<span class="string">"1"</span>,stringBuilder2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">                <span class="comment">//就表示找到某个叶子结点的最后 存字符和编码</span></span><br><span class="line">                huffmanCodes.put(node.getData(),stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCode 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[]</span></span><br><span class="line"><span class="comment">     * 举例： String content = "i like like like java do you like a java"; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100"</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes,Map&lt;Byte, String&gt; huffmanCode)&#123;</span><br><span class="line">        StringBuffer codes = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> v : bytes)&#123;</span><br><span class="line">            codes.append(huffmanCode.get(v));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(codes.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计返回  byte[] huffmanCodeBytes 长度</span></span><br><span class="line">        <span class="comment">//一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(codes.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = codes.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = codes.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; codes.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span>( i+<span class="number">8</span> &gt; codes.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = codes.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = codes.substring(i, i + <span class="number">8</span>); <span class="comment">//每8位取一块放入strByte中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="comment">//[0] 构建node节点的集合</span></span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//[1] 根据 nodes 创建的赫夫曼树</span></span><br><span class="line">        Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//[2] 对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCode(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//[3] 根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把字符串安装指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;String, Byte&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//============================不断增大key 去和 编码key进行匹配==========================================</span></span><br><span class="line">        <span class="comment">//创建要给集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//i 可以理解成就是索引,扫描 stringBuilder</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            Byte b = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">                <span class="comment">//1010100010111...</span></span><br><span class="line">                <span class="comment">//递增的取出 key 1</span></span><br><span class="line">                String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span>(b == <span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配到</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;<span class="comment">//i 直接移动到 count</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"</span></span><br><span class="line">        <span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 传入的 byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用变量保存 b</span></span><br><span class="line">        <span class="keyword">int</span> temp = b; <span class="comment">//将 b 转成 int</span></span><br><span class="line">        <span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>; <span class="comment">//按位与 256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line">        String str = Integer.toBinaryString(temp); <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">"i like like like java do you like a java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes(); <span class="comment">//转成字节数组，字符变成了ASCII码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanZip = huffmanZip(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//40  -&gt;  17    测试</span></span><br><span class="line">        System.out.println(Arrays.toString(huffmanZip) + <span class="string">"长度::"</span> + huffmanZip.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据解压</span></span><br><span class="line">        <span class="keyword">byte</span>[] decode = decode(huffmanCodes, huffmanZip);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> v : decode) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191107091628722" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191107091628722.png" class="lazyload"></p>
<h3 id="压缩-解压文件"><a href="#压缩-解压文件" class="headerlink" title="压缩/解压文件"></a>压缩/解压文件</h3><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建输出流</span></span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//创建文件的输入流</span></span><br><span class="line">    FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        is.read(b);</span><br><span class="line">        <span class="comment">//直接对源文件压缩</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">        <span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">        os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">        <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        <span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">        oos.writeObject(huffmanBytes); <span class="comment">//我们是把</span></span><br><span class="line">        <span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">        <span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">        oos.writeObject(huffmanCodes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            oos.close();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，完成对压缩文件的解压</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义文件输入流</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义一个对象输入流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义文件的输出流</span></span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">            <span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line">            <span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(huffmanCodes.size());</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">            <span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zipFile(<span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\src.txt"</span>,</span><br><span class="line">                <span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\dst.txt"</span>);</span><br><span class="line"></span><br><span class="line">        unZipFile(<span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\dst.txt"</span>,</span><br><span class="line">                <span class="string">"E:\\Ideaproject\\Algorithm\\src\\main\\java\\cn\\mxranger\\huffmancode\\src1.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191107095601709" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191107095601709.png" class="lazyload"></p>
<p><strong>赫夫曼编码压缩文件注意事项</strong></p>
<p>1)如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 [举例压一个 .ppt]</p>
<p>2)赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml文件]</p>
<p>3)如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. </p>
<h2 id="4、二叉排序树-BST"><a href="#4、二叉排序树-BST" class="headerlink" title="4、二叉排序树(BST)"></a>4、二叉排序树(BST)</h2><h3 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h3><p>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><img alt="image-20191107104248819" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191107104248819.png" class="lazyload"></p>
<h3 id="创建-amp-添加"><a href="#创建-amp-添加" class="headerlink" title="创建&amp;添加"></a>创建&amp;添加</h3><h4 id="二叉排序树添加步骤"><a href="#二叉排序树添加步骤" class="headerlink" title="二叉排序树添加步骤"></a>二叉排序树添加步骤</h4><p>1、若该树为空，将其赋给root</p>
<p>2、若该树不为空，判断其值与当前结点值的大小</p>
<p>[2.1] 若 node.val &lt; this.val  ，且node的左节点为空，则接到node.left上</p>
<p>​                若node的左节点不为空，递归左节点</p>
<p>[2.2] 若 node.val &gt; this.val  ，且node的右节点为空，则接到node.right上</p>
<p>​                若node的右节点不为空，递归右节点</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><h5 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Node</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值 和当前子树根节点的值比大小</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt; <span class="keyword">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//node.val &gt; this.val</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BinarySortTree类"><a href="#BinarySortTree类" class="headerlink" title="BinarySortTree类"></a>BinarySortTree类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySortTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOreder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Test-2"><a href="#Test-2" class="headerlink" title="Test"></a>Test</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BinarySortTree root = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : arr) &#123;</span><br><span class="line">            root.add(<span class="keyword">new</span> Node(v));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.infixOreder();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>需要考虑三种情况</p>
<p>1、 删除叶子节点 (比如：2, 5, 9, 12)<br>2、删除只有一颗子树的节点 (比如：1)<br>3、删除有两颗子树的节点. (比如：7, 3，10 )</p>
<p><img alt="image-20191108100157835" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191108100157835.png" class="lazyload"></p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><strong>情况一：删除叶子结点</strong></p>
<p>1、需要先去找到要删除的结点  targetNode</p>
<p>2、找到targetNode 的 父结点 parent </p>
<p>3、确定 targetNode 是 parent的左子结点 还是右子结点</p>
<p>如果targetNode 是 parent的左子结点，parent.left = null</p>
<p>如果targetNode 是 parent的右子结点，parent.right= null</p>
<p><strong>情况二：删除只有一颗子树的结点</strong></p>
<p>1、先去找到要删除的结点  targetNode<br>2、找到targetNode 的 父结点 parent<br>3、确定targetNode 的子结点是左子结点还是右子结点<br>4、targetNode 是 parent 的左子结点还是右子结点<br>5、如果targetNode 有左子结点</p>
<p>[5.1] parent 不为空</p>
<p>如果 targetNode 是 parent 的左子结点，parent.left = targetNode.left;<br>如果 targetNode 是 parent 的右子结点，parent.right = targetNode.left;</p>
<p>[5.2]parent为空</p>
<p>说明当前点是根结点，将左子结点给根结点，root = targetNode.left;</p>
<p>6、如果targetNode 有右子结点</p>
<p>[5.1] parent 不为空</p>
<p>如果 targetNode 是 parent 的左子结点，parent.left = targetNode.right;<br>如果 targetNode 是 parent 的右子结点，parent.right = targetNode.right;</p>
<p>[5.2]parent为空</p>
<p>说明当前点是根结点，将左子结点给根结点，root = targetNode.right;</p>
<p><strong>情况三：删除有两颗子树的结点</strong></p>
<p>1、先去找到要删除的结点  targetNode</p>
<p>2、找到targetNode 的 父结点 parent </p>
<p>3、从targetNode 的右子树找到最小的结点（都比左子树的值大）</p>
<p>4、 用一个临时变量，将 最小结点的值保存 temp = 11</p>
<p>5、删除该最小结点，将当前结点的值换掉，引用不变，targetNode.value = temp</p>
<p>代码见下面</p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>功能：添加 + 删除</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Node</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  查找要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   希望删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="keyword">this</span>.val)&#123; <span class="comment">//找到该节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val)&#123; <span class="comment">//查找的值小于当前的节点，想左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除结点的父结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.val == val) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.val == val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(val); <span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(val); <span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值 和当前子树根节点的值比大小</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt; <span class="keyword">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//node.val &gt; this.val</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BinarySortTree"><a href="#BinarySortTree" class="headerlink" title="BinarySortTree"></a>BinarySortTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySortTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法:</span></span><br><span class="line">    <span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line">    <span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时 target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.val);</span><br><span class="line">        <span class="keyword">return</span> target.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.val == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">                <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.val = minVal;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——左</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点  右——左</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——右</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点 右——右</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOreder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySortTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BinarySortTree root = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : arr) &#123;</span><br><span class="line">            root.add(<span class="keyword">new</span> Node(v));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.infixOreder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        root.delNode(<span class="number">2</span>);</span><br><span class="line">        root.delNode(<span class="number">7</span>);</span><br><span class="line">        root.infixOreder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>中序遍历结果如下：</p>
<p><img alt="image-20191108104604363" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191108104604363.png" class="lazyload"></p>
<h2 id="5、平衡二叉树（AVL）"><a href="#5、平衡二叉树（AVL）" class="headerlink" title="5、平衡二叉树（AVL）"></a>5、平衡二叉树（AVL）</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p><img alt="image-20191109085633702" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109085633702.png" class="lazyload"></p>
<h3 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h3><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</p>
<p>具有以下<strong>特点</strong>：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><h4 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h4><img alt="左旋转" style="zoom:200%;" data-src="/images/Java数据结构与算法/左旋转.png" class="lazyload">

<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋转的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建新的节点，以当前根节点的值</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">    <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">    newNode.left = left;</span><br><span class="line">    <span class="comment">//把新的结点的右子树设置成带你过去结点的右子树的左子树</span></span><br><span class="line">    newNode.right = right.left;</span><br><span class="line">    <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">    val = right.val;</span><br><span class="line">    <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">    right = right.right;</span><br><span class="line">    <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">    left = newNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h4><p><img alt="image-20191109094557964" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109094557964.png" class="lazyload"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">    newNode.right = right;</span><br><span class="line">    newNode.left = left.right;</span><br><span class="line">    val = left.val;</span><br><span class="line">    left = left.left;</span><br><span class="line">    right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h4><p>问题分析<br>当符号右旋转的条件时</p>
<ol>
<li>如果它的左子树的右子树高度大于它的左子树的高度</li>
<li>先对当前这个结点的左节点进行左旋转</li>
<li>在对当前结点进行右旋转的操作即可</li>
</ol>
<p><img alt="image-20191109100332183" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109100332183.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******当添加完节点后，(右子树的高度 - 左子树的高度) &gt; 1***********</span></span><br><span class="line">       <span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line">       <span class="keyword">if</span>(rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">           <span class="keyword">if</span>(right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">               <span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line">               right.rightRotate();</span><br><span class="line">               <span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line">               leftRotate(); <span class="comment">//左旋转..</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//直接进行左旋转即可</span></span><br><span class="line">               leftRotate();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ; <span class="comment">//必须要!!!</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line">       <span class="keyword">if</span>(leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">           <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">               <span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line">               left.leftRotate();</span><br><span class="line">               <span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">               rightRotate();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//直接进行右旋转即可</span></span><br><span class="line">               rightRotate();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="Node类-1"><a href="#Node类-1" class="headerlink" title="Node类"></a>Node类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Node</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/7</span></span><br><span class="line"><span class="comment"> * Time      10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前节点的高度，以该节点为根节点的树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height() ,</span><br><span class="line">                right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋转的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的节点，以当前根节点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">        newNode.left = left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成带你过去结点的右子树的左子树</span></span><br><span class="line">        newNode.right = right.left;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">        val = right.val;</span><br><span class="line">        <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">        right = right.right;</span><br><span class="line">        <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">        left = newNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        val = left.val;</span><br><span class="line">        left = left.left;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------二叉排序树的基本方法------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  查找要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   希望删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="keyword">this</span>.val)&#123; <span class="comment">//找到该节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val)&#123; <span class="comment">//查找的值小于当前的节点，想左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除结点的父结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.val == val) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.val == val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(val &lt; <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(val); <span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= <span class="keyword">this</span>.val &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(val); <span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值 和当前子树根节点的值比大小</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt; <span class="keyword">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//node.val &gt; this.val</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//*******当添加完节点后，(右子树的高度 - 左子树的高度) &gt; 1***********</span></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line">        <span class="keyword">if</span>(rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">            <span class="keyword">if</span>(right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                <span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line">                right.rightRotate();</span><br><span class="line">                <span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line">                leftRotate(); <span class="comment">//左旋转..</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接进行左旋转即可</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">//必须要!!!</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line">        <span class="keyword">if</span>(leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                <span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接进行右旋转即可</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOreder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AVLTree类"><a href="#AVLTree类" class="headerlink" title="AVLTree类"></a>AVLTree类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName AVLTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/9</span></span><br><span class="line"><span class="comment"> * Time      9:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法:</span></span><br><span class="line">    <span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line">    <span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时 target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.val);</span><br><span class="line">        <span class="keyword">return</span> target.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.val == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">                <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.val = minVal;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——左</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点  右——左</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点  左——右</span></span><br><span class="line">                        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点 右——右</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOreder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOreder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Test-3"><a href="#Test-3" class="headerlink" title="Test"></a>Test</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName AVLTreeDemo</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/9</span></span><br><span class="line"><span class="comment"> * Time      9:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        avlTree.infixOreder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"平衡后........"</span>);</span><br><span class="line">        System.out.println(<span class="string">"树的高度::"</span> + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(<span class="string">"树的左子树高度::"</span> + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(<span class="string">"树的右子树高度::"</span> + avlTree.getRoot().rightHeight());</span><br><span class="line">        System.out.println(avlTree.getRoot().val);</span><br><span class="line">        System.out.println(avlTree.getRoot().left.val);</span><br><span class="line">        System.out.println(avlTree.getRoot().right.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<p><img alt="image-20191109110458028" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109110458028.png" class="lazyload"></p>
<h2 id="6、2-3树"><a href="#6、2-3树" class="headerlink" title="6、2-3树"></a>6、2-3树</h2><h3 id="介绍-23"><a href="#介绍-23" class="headerlink" title="介绍"></a>介绍</h3><img alt="image-20191109165319592" style="zoom:65%;" data-src="/images/Java数据结构与算法/image-20191109165319592.png" class="lazyload">

<img alt="image-20191109165452654" style="zoom:67%;" data-src="/images/Java数据结构与算法/image-20191109165452654.png" class="lazyload">

<p><strong>2-3树是一颗绝对平衡的树（左右子树的高度相等）</strong></p>
<h3 id="插入步骤"><a href="#插入步骤" class="headerlink" title="插入步骤"></a>插入步骤</h3><p><img alt="2-3树添加" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2-3%E6%A0%91%E6%B7%BB%E5%8A%A0.png" class="lazyload"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>2-3树是最简单的B树结构, 具有如下特点:</p>
<p>1、<span style="color:red"><strong>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</strong></span><br>2、有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
<p>3、有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</p>
<p>4、2-3树是由二节点和三节点构成的树。</p>
<h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><p><img alt="image-20191109155814269" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109155814269.png" class="lazyload"></p>
<h2 id="7、红黑树"><a href="#7、红黑树" class="headerlink" title="7、红黑树"></a>7、红黑树</h2><h3 id="介绍-24"><a href="#介绍-24" class="headerlink" title="介绍"></a>介绍</h3><p>2-3树中如下：b-c在同一个节点上，b比c小，将b挂到c的左子树上去，原本b-c节点的内部关联转成了b节点和c节点，标示成红色，并将此信息放入b节点中，而普通的节点则为黑色</p>
<img alt="image-20191110152750142" style="zoom:50%;" data-src="/images/Java数据结构与算法/image-20191110152750142.png" class="lazyload">

<p>下图红黑树所示：</p>
<p><img alt="红黑树" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91.png" class="lazyload"></p>
<h4 id="4个性质"><a href="#4个性质" class="headerlink" title="4个性质"></a>4个性质</h4><p>性质1. 节点是红色或黑色。<br>性质2. 根节点是黑色。<br>性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br>性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h1 id="十、多路查找树"><a href="#十、多路查找树" class="headerlink" title="十、多路查找树"></a>十、多路查找树</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>二叉树的问题分析</p>
<p><img alt="image-20191109111021630" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109111021630.png" class="lazyload"></p>
<h2 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h2><p>1、在二叉树中，每个节点有数据项，最多有两个子节点。<strong>如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</strong></p>
<p>2、后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</p>
<p>举例说明(下面2-3树就是一颗多叉树)</p>
<p><img alt="image-20191109111057267" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109111057267.png" class="lazyload"></p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>[2-3树跳转](# 6、2-3树)</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</p>
<p><img alt="image-20191109161220051" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109161220051.png" class="lazyload"></p>
<p><img alt="image-20191109111310760" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109111310760.png" class="lazyload"></p>
<p>1、如图B树通过重新组织节点， 降低了树的高度.</p>
<p>2、文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</p>
<p>3、将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h2><p><img alt="image-20191109162216279" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109162216279.png" class="lazyload"></p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B* 树"></a>B* 树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针</p>
<p><img alt="image-20191109162435580" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191109162435580.png" class="lazyload"></p>
<h1 id="十一、图"><a href="#十一、图" class="headerlink" title="十一、图"></a>十一、图</h1><h2 id="介绍-25"><a href="#介绍-25" class="headerlink" title="介绍"></a>介绍</h2><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。</p>
<p><img alt="image-20191110162430691" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191110162430691.png" class="lazyload"></p>
<p><img alt="image-20191110162447261" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191110162447261.png" class="lazyload"></p>
<h2 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h2><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。（1：可到达  0：不可到达）</p>
<p><img alt="image-20191110163316730" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191110163316730.png" class="lazyload"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>1、邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.<br>2、邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</p>
<p><img alt="image-20191111090959899" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191111090959899.png" class="lazyload"></p>
<h2 id="邻接矩阵——代码"><a href="#邻接矩阵——代码" class="headerlink" title="邻接矩阵——代码"></a>邻接矩阵——代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Graph</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/11</span></span><br><span class="line"><span class="comment"> * Time      9:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          无向图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回结点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示权值  边对应的值  1 / 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String v : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把邻结矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img alt="image-20191111101402439" style="zoom:90%;" data-src="/images/Java数据结构与算法/image-20191111101402439.png" class="lazyload">







<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><blockquote>
<p> 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历</p>
</blockquote>
<h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><h4 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h4><p>图的深度优先搜索(Depth First Search) 。<br>1、深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：<strong>每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</strong><br>2、我们可以看到，这样的访问策略是<strong>优先往纵向挖掘深入</strong>，而不是对一个结点的所有邻接结点进行横向访问。<br>3、显然，深度优先搜索是一个递归的过程</p>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><p>1、访问初始结点v，并标记结点v为已访问。</p>
<p>2、查找结点v的第一个邻接结点w。</p>
<p>3、若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</p>
<p>4、若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</p>
<p>5、查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</p>
<p><img alt="深度优先遍历" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" class="lazyload"></p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到第一个邻接结点的下标 w</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//i 起始为0</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       例如：从第一个开始找，首先输出A，标记访问，然后找第一行第一个为1的路径B，</span></span><br><span class="line"><span class="comment">       开始遍历B行中第一个为1的路径A，发现访问过了，开始找下一个为1的路径C，标记访问，</span></span><br><span class="line"><span class="comment">       再开始遍历C行.............以此类推</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    A  B  C  D  E</span></span><br><span class="line"><span class="comment">           A       [0, 1, 1, 0, 0]</span></span><br><span class="line"><span class="comment">           B       [1, 0, 1, 1, 1]</span></span><br><span class="line"><span class="comment">           C       [1, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">           D       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">           E       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">       <span class="comment">//[1] 首先我们访问该结点,输出</span></span><br><span class="line">       System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">       <span class="comment">//[1] 将结点设置为已经访问</span></span><br><span class="line">       isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//[2] 查找结点i的第一个邻接结点w</span></span><br><span class="line">       <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">       <span class="comment">//[3]</span></span><br><span class="line">       <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//说明有</span></span><br><span class="line">           <span class="comment">//[4]</span></span><br><span class="line">           <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">               dfs(isVisited, w);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//[5] 如果w结点已经被访问过</span></span><br><span class="line">           w = getNextNeighbor(i, w);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">       <span class="comment">//遍历所有的结点，进行dfs[回溯]</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">               dfs(isVisited, i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>













<h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>图的广度优先搜索(Broad First Search) 。<br>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><p>1、访问初始结点v并标记结点v为已访问。<br>2、结点v入队列<br>3、当队列非空时，继续执行，否则算法结束。<br>4、出队列，取得队头结点u。<br>5、查找结点u的第一个邻接结点w。<br>6、若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<br>6.1 若结点w尚未被访问，则访问结点w并标记为已访问。<br>6.2 结点w入队列<br>6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p>
<p><img alt="广度优先遍历" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-1573521467725.png" class="lazyload"></p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u ; <span class="comment">// 表示队列的头结点对应下标</span></span><br><span class="line">    <span class="keyword">int</span> w ; <span class="comment">// 邻接结点w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">//[1]访问结点，输出结点信息</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">"=&gt;"</span>);</span><br><span class="line">    <span class="comment">//[1]标记为已访问</span></span><br><span class="line">    isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    queue.addLast(i);</span><br><span class="line">    <span class="comment">//[3]</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//[4]</span></span><br><span class="line">        u = (Integer) queue.removeFirst();</span><br><span class="line">        <span class="comment">//[5]得到第一个邻接结点的下标 w</span></span><br><span class="line">        w = getFirstNeighbor(u);</span><br><span class="line">        <span class="comment">//[6]</span></span><br><span class="line">        <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">            <span class="comment">//[6.1]是否访问过</span></span><br><span class="line">            <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">"=&gt;"</span>);</span><br><span class="line">                <span class="comment">//标记已经访问</span></span><br><span class="line">                isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//[6.2]入队</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//[6.2]以u为前驱点，找w后面的下一个邻结点</span></span><br><span class="line">            w = getNextNeighbor(u, w); <span class="comment">//体现出我们的广度优先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的结点，都进行广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">            bfs(isVisited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName Graph</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/11</span></span><br><span class="line"><span class="comment"> * Time      9:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          无向图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回结点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *			无向图的添加方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示权值  边对应的值  1 / 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个邻接结点的下标 w</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 起始为0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        例如：从第一个开始找，首先输出A，标记访问，然后找第一行第一个为1的路径B，</span></span><br><span class="line"><span class="comment">        开始遍历B行中第一个为1的路径A，发现访问过了，开始找下一个为1的路径C，标记访问，</span></span><br><span class="line"><span class="comment">        再开始遍历C行.............以此类推</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     A  B  C  D  E</span></span><br><span class="line"><span class="comment">            A       [0, 1, 1, 0, 0]</span></span><br><span class="line"><span class="comment">            B       [1, 0, 1, 1, 1]</span></span><br><span class="line"><span class="comment">            C       [1, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">            D       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment">            E       [0, 1, 0, 0, 0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先我们访问该结点,输出</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">        <span class="comment">//将结点设置为已经访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//查找结点i的第一个邻接结点w</span></span><br><span class="line">        <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//说明有</span></span><br><span class="line">            <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果w结点已经被访问过***************************</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//遍历所有的结点，进行dfs[回溯]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u ; <span class="comment">// 表示队列的头结点对应下标</span></span><br><span class="line">        <span class="keyword">int</span> w ; <span class="comment">// 邻接结点w</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//[1]访问结点，输出结点信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">"=&gt;"</span>);</span><br><span class="line">        <span class="comment">//[1]标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//[2]</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="comment">//[3]</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//[4]</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//[5]得到第一个邻接结点的下标 w</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="comment">//[6]</span></span><br><span class="line">            <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//[6.1]是否访问过</span></span><br><span class="line">                <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(w) + <span class="string">"=&gt;"</span>);</span><br><span class="line">                    <span class="comment">//标记已经访问</span></span><br><span class="line">                    isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//[6.2]入队</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//[6.2]以u为前驱点，找w后面的下一个邻结点*****************</span></span><br><span class="line">                w = getNextNeighbor(u, w); <span class="comment">//体现出我们的广度优先</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的结点，都进行广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String v : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把邻结矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"深度遍历"</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">        System.out.println(<span class="string">"\n广度优先!"</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>getNextNeighbor就是最大的区别，dfs跳转到另一行w找下一个邻接点，bfs是在当前行u找下一个邻节点</p>
</blockquote>
<h2 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h2><p><img alt="image-20191112095246913" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191112095246913.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String v : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新边的关系</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把邻结矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"深度遍历"</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">        System.out.println(<span class="string">"\n广度优先!"</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="十二、常用10种算法"><a href="#十二、常用10种算法" class="headerlink" title="十二、常用10种算法"></a>十二、常用10种算法</h1><h2 id="1、二分查找（非递归）"><a href="#1、二分查找（非递归）" class="headerlink" title="1、二分查找（非递归）"></a>1、二分查找（非递归）</h2><h3 id="介绍-26"><a href="#介绍-26" class="headerlink" title="介绍"></a>介绍</h3><p>​        前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式<br>​        二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找<br>​        二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.binarysearch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName BinarySearchNoRecursion</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/12</span></span><br><span class="line"><span class="comment"> * Time      10:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNoRecursion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   默认升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(arr, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"index::"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、分治算法-Divide-and-Conquer"><a href="#2、分治算法-Divide-and-Conquer" class="headerlink" title="2、分治算法(Divide-and-Conquer)"></a>2、分治算法(Divide-and-Conquer)</h2><h3 id="介绍-27"><a href="#介绍-27" class="headerlink" title="介绍"></a>介绍</h3><p>1、分治法是一种很重要的算法。字面上的解释是“<strong>分而治之</strong>”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<p>2、分治算法可以求解的一些经典问题<br>二分搜索、大整数乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、汉诺塔</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><p>分治法在每一层递归上都有三个步骤：<br>[1] 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题<br>[2] 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br>[3] 合并：将各个子问题的解合并为原问题的解。</p>
<h3 id="案例——汉诺塔"><a href="#案例——汉诺塔" class="headerlink" title="案例——汉诺塔"></a>案例——汉诺塔</h3><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>1、如果是有一个盘， A-&gt;C</p>
<p>2、如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘</p>
<p>​    [1] 先把 最上面的盘 A-&gt;B<br>​    [2] 把最下边的盘 A-&gt;C<br>​    [3] 把B塔的所有盘 从 B-&gt;C   </p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.DivideAndConquer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName DivideAndConquer</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/12</span></span><br><span class="line"><span class="comment"> * Time      10:23</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 汉诺塔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoitower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"第1个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘</span></span><br><span class="line">            <span class="comment">//1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//2. 把最下边的盘 A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span> + num + <span class="string">"个盘从 "</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">            <span class="comment">//3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、动态规划"><a href="#3、动态规划" class="headerlink" title="3、动态规划"></a>3、动态规划</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题：有一个背包，容量为4磅 ， 现有如下物品</p>
<table>
<thead>
<tr>
<th align="center"><strong>物品</strong></th>
<th align="center"><strong>重量</strong></th>
<th align="center"><strong>价格</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">吉他(G)</td>
<td align="center">1</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">音响(S)</td>
<td align="center">4</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center">电脑(L)</td>
<td align="center">3</td>
<td align="center">2000</td>
</tr>
</tbody></table>
<p>1、要求达到的目标为装入的背包的总价值最大，并且重量不超出<br>2、要求装入的物品不能重复</p>
<h3 id="介绍-28"><a href="#介绍-28" class="headerlink" title="介绍"></a>介绍</h3><p>1、动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p>
<p>2、动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>3、与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p>
<p>4、动态规划可以通过填表的方式来逐步推进，得到最优解.</p>
<p> <a href="https://blog.csdn.net/qq_38410730/article/details/81667885" target="_blank" rel="noopener">https://blog.csdn.net/qq_38410730/article/details/81667885</a> </p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</p>
<p>1、  <code>v[i][0]=v[0][j]=0;</code> //表示 填入表 第一行和第一列是0</p>
<p>2、当<code>w[i]&gt; j</code> 时：<code>v[i][j]=v[i-1][j]</code>  // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略</p>
<p>3、当<code>j&gt;=w[i]</code>时：<code>v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}</code><br> 当 准备加入的新增的商品的容量小于等于当前背包的容量,<br> 装入的方式:<br><code>v[i-1][j]</code>： 就是上一个单元格的装入的最大值<br><code>v[i]</code> : 表示当前商品的价值<br><code>v[i-1][j-w[i]]</code> ： 装入i-1商品，到剩余空间j-w[i]的最大值<br>当<code>j&gt;=w[i]</code>时：<code>v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}</code> </p>
<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><p><img alt="image-20191114144929888" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114144929888.png" class="lazyload"></p>
<p><img alt="image-20191114145024253" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114145024253.png" class="lazyload"></p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName KnapsackProblem</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/12</span></span><br><span class="line"><span class="comment"> * Time      15:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;; <span class="comment">//物品的价值 这里val[i] 就是前面讲的v[i]</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length; <span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组，</span></span><br><span class="line">        <span class="comment">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//将第一列设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//将第一行设置0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面得到公式来动态规划处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123; <span class="comment">//不处理第一行 i是从1开始的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;<span class="comment">//不处理第一列, j是从1开始的</span></span><br><span class="line">                <span class="comment">//公式</span></span><br><span class="line">                <span class="keyword">if</span>(w[i-<span class="number">1</span>]&gt; j) &#123; <span class="comment">// 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]</span></span><br><span class="line">                    v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明:</span></span><br><span class="line">                    <span class="comment">//因为我们的i 从1开始的， 因此公式需要调整成</span></span><br><span class="line">                    <span class="comment">//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                    <span class="comment">//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span></span><br><span class="line">                    <span class="comment">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式</span></span><br><span class="line">                    <span class="keyword">if</span>(v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//把当前的情况记录到path</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出一下v 看看目前的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; v.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length;j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============================"</span>);</span><br><span class="line">        <span class="comment">//输出最后我们是放入的哪些商品</span></span><br><span class="line">        <span class="comment">//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入</span></span><br><span class="line"><span class="comment">//		for(int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//			for(int j=0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">//				if(path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">//					System.out.printf("第%d个商品放入到背包\n", i);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动脑筋</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>; <span class="comment">//行的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;  <span class="comment">//列的最大下标</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> ) &#123; <span class="comment">//从path的最后开始找</span></span><br><span class="line">            <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"第%d个商品放入到背包\n"</span>, i);</span><br><span class="line">                j -= w[i-<span class="number">1</span>]; <span class="comment">//w[i-1]</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4、KMP算法"><a href="#4、KMP算法" class="headerlink" title="4、KMP算法"></a>4、KMP算法</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>不多说，一一匹配，上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.kmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName ViolenceMatch</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/14</span></span><br><span class="line"><span class="comment"> * Time      15:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolenceMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力匹配算法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s1Len = s1.length;</span><br><span class="line">        <span class="keyword">int</span> s2Len = s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i索引指向s1</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// j索引指向s2</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;<span class="comment">// 保证匹配时，不越界</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j]) &#123;<span class="comment">//匹配ok</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//没有匹配成功</span></span><br><span class="line">                <span class="comment">//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。</span></span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j == s2Len) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试暴力匹配算法</span></span><br><span class="line">        String str1 = <span class="string">"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好"</span>;</span><br><span class="line">        String str2 = <span class="string">"尚硅谷你尚硅你"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">        System.out.println(<span class="string">"index="</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="kmp介绍"><a href="#kmp介绍" class="headerlink" title="kmp介绍"></a>kmp介绍</h3><p>1、KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法.</p>
<p>2、Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.</p>
<p>3、KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</p>
<p>4、参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a> </p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h4 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h4><p><img alt="image-20191114153325121" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153325121.png" class="lazyload"></p>
<p><img alt="image-20191114153348288" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153348288.png" class="lazyload"></p>
<p><img alt="image-20191114153423389" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153423389.png" class="lazyload"></p>
<p><img alt="image-20191114153456573" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153456573.png" class="lazyload"></p>
<p><img alt="image-20191114153513844" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153513844.png" class="lazyload"></p>
<p><img alt="image-20191114153535725" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153535725.png" class="lazyload"></p>
<h4 id="部分匹配表的产生"><a href="#部分匹配表的产生" class="headerlink" title="部分匹配表的产生"></a>部分匹配表的产生</h4><p><img alt="image-20191114153809183" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153809183.png" class="lazyload"></p>
<p><img alt="image-20191114153831281" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191114153831281.png" class="lazyload"></p>
<h3 id="求next值的两种方式"><a href="#求next值的两种方式" class="headerlink" title="求next值的两种方式"></a>求next值的两种方式</h3><p>原理请看上面网址</p>
<p><img alt="kmp求解方式" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/kmp%E6%B1%82%E8%A7%A3%E6%96%B9%E5%BC%8F.png" class="lazyload"></p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName KMPAlgorithm</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/14</span></span><br><span class="line"><span class="comment"> * Time      15:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1] 获取一个字符串（子串）的部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(str2);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(<span class="string">"index="</span> + index); <span class="comment">// 15了</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写出我们的kmp搜索算法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表, 是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小</span></span><br><span class="line">            <span class="comment">//KMP算法核心点, 可以验证...</span></span><br><span class="line">            <span class="keyword">while</span>( j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == str2.length()) &#123;<span class="comment">//找到了 // j = 3 i</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//如果子串长度为1，没有公共的，部分匹配之为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line">            <span class="comment">//这时kmp算法的核心点</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j))&#123; <span class="comment">// 部分匹配值 + 1</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、贪心算法"><a href="#5、贪心算法" class="headerlink" title="5、贪心算法"></a>5、贪心算法</h2><h3 id="介绍-29"><a href="#介绍-29" class="headerlink" title="介绍"></a>介绍</h3><p>​        贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</p>
<p>​        贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p>
<h3 id="集合覆盖"><a href="#集合覆盖" class="headerlink" title="集合覆盖"></a>集合覆盖</h3><h4 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h4><p><img alt="image-20191116081400909" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116081400909.png" class="lazyload"></p>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><h5 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h5><p><img alt="image-20191116092649061" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116092649061.png" class="lazyload"></p>
<h5 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h5><p>使用贪婪算法，效率高:<br>        目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:<br>1、遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）<br>2、将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。<br>3、重复第1步直到覆盖了全部的地区</p>
<h4 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h4><p><img alt="贪婪算法步骤" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4.png" class="lazyload"></p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建广播电台,放入到Map</span></span><br><span class="line">		HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">		<span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">		HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet1.add(<span class="string">"北京"</span>);</span><br><span class="line">		hashSet1.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet1.add(<span class="string">"天津"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet2.add(<span class="string">"广州"</span>);</span><br><span class="line">		hashSet2.add(<span class="string">"北京"</span>);</span><br><span class="line">		hashSet2.add(<span class="string">"深圳"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet3.add(<span class="string">"成都"</span>);</span><br><span class="line">		hashSet3.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet3.add(<span class="string">"杭州"</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet4.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet4.add(<span class="string">"天津"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet5.add(<span class="string">"杭州"</span>);</span><br><span class="line">		hashSet5.add(<span class="string">"大连"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//加入到map</span></span><br><span class="line">		broadcasts.put(<span class="string">"K1"</span>, hashSet1);</span><br><span class="line">		broadcasts.put(<span class="string">"K2"</span>, hashSet2);</span><br><span class="line">		broadcasts.put(<span class="string">"K3"</span>, hashSet3);</span><br><span class="line">		broadcasts.put(<span class="string">"K4"</span>, hashSet4);</span><br><span class="line">		broadcasts.put(<span class="string">"K5"</span>, hashSet5);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//allAreas 存放所有的地区</span></span><br><span class="line">		HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		allAreas.add(<span class="string">"北京"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"上海"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"天津"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"广州"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"深圳"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"成都"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"杭州"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"大连"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建ArrayList, 存放选择的电台集合</span></span><br><span class="line">		ArrayList&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">		HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span></span><br><span class="line">		<span class="comment">//如果maxKey 不为null , 则会加入到 selects</span></span><br><span class="line">		String maxKey = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>(allAreas.size() != <span class="number">0</span>) &#123; <span class="comment">// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区</span></span><br><span class="line">			<span class="comment">//每进行一次while,需要</span></span><br><span class="line">			maxKey = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//遍历 broadcasts, 取出对应key</span></span><br><span class="line">			<span class="keyword">for</span>(String key : broadcasts.keySet()) &#123;</span><br><span class="line">				<span class="comment">//每进行一次for</span></span><br><span class="line">				tempSet.clear();</span><br><span class="line">				<span class="comment">//当前这个key能够覆盖的地区</span></span><br><span class="line">				HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">				tempSet.addAll(areas);</span><br><span class="line">				<span class="comment">//求出tempSet 和   allAreas 集合的交集, 交集会赋给 tempSet</span></span><br><span class="line">				tempSet.retainAll(allAreas);</span><br><span class="line">				<span class="comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span></span><br><span class="line">				<span class="comment">//就需要重置maxKey</span></span><br><span class="line">				<span class="comment">// tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的</span></span><br><span class="line">				<span class="keyword">if</span>(tempSet.size() &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">						(maxKey == <span class="keyword">null</span> || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">					maxKey = key;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//maxKey != null, 就应该将maxKey 加入selects</span></span><br><span class="line">			<span class="keyword">if</span>(maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">				selects.add(maxKey);</span><br><span class="line">				<span class="comment">//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉</span></span><br><span class="line">				allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"得到的选择结果是"</span> + selects);<span class="comment">//[K1,K2,K3,K5]</span></span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果<br>2、比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区<br>3、但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的.</p>
<h2 id="6、普里姆（Prim）算法"><a href="#6、普里姆（Prim）算法" class="headerlink" title="6、普里姆（Prim）算法"></a>6、普里姆（Prim）算法</h2><h3 id="介绍-30"><a href="#介绍-30" class="headerlink" title="介绍"></a>介绍</h3><p><img alt="image-20191116093521622" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116093521622.png" class="lazyload"></p>
<h3 id="修路问题"><a href="#修路问题" class="headerlink" title="修路问题"></a>修路问题</h3><h4 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h4><p><img alt="image-20191116093542948" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116093542948.png" class="lazyload"></p>
<p><img alt="image-20191116093614097" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116093614097.png" class="lazyload"></p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><img alt="image-20191116094718450" style="zoom:150%;" data-src="/images/Java数据结构与算法/image-20191116094718450.png" class="lazyload">



<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><h4 id="Graph类"><a href="#Graph类" class="headerlink" title="Graph类"></a>Graph类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.prim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MGraph</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/16</span></span><br><span class="line"><span class="comment"> * Time      9:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> verx;<span class="comment">//表示图的节点个数</span></span><br><span class="line">    <span class="keyword">char</span>[] data;<span class="comment">//保存节点数据</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;<span class="comment">//存放边，邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(<span class="keyword">int</span> verx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verx = verx;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">char</span>[verx];</span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">int</span>[verx][verx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVerx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> verx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVerx</span><span class="params">(<span class="keyword">int</span> verx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verx = verx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">char</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] getWeight() &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="MinTree类"><a href="#MinTree类" class="headerlink" title="MinTree类"></a>MinTree类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.prim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MinTree</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/16</span></span><br><span class="line"><span class="comment"> * Time      9:53</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建最小生成树 -&gt; 村庄图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图的邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verxs 图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(MGraph graph,<span class="keyword">int</span> verxs,<span class="keyword">char</span> data[],<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; verxs; i++) &#123;<span class="comment">//顶点</span></span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>;  j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(MGraph graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] weight = graph.getWeight();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] vs : weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(vs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写prim算法，生成最小生成树</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(MGraph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> verx = graph.getVerx();</span><br><span class="line">        <span class="keyword">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[verx];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] weight = graph.getWeight();</span><br><span class="line"></span><br><span class="line">        isVisited[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v_1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v_2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min_weight = <span class="number">100000</span>; <span class="comment">//初始大值，遍历到小的就替换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; verx; k++) &#123; <span class="comment">//因为有verx个顶点，prim结束后，有verx - 1条边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//每一次会有多个点，而每个点需要遍历，所以需要双循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;verx;i++)&#123;<span class="comment">// i结点表示被访问过的结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; verx; j++) &#123;<span class="comment">//j结点表示还没有访问过的结点</span></span><br><span class="line">                    <span class="keyword">if</span> (isVisited[i] &amp;&amp; !isVisited[j])&#123; <span class="comment">//头点已访问，尾点未访问的边</span></span><br><span class="line">                        <span class="keyword">if</span> (min_weight &gt; weight[i][j])&#123;</span><br><span class="line">                            min_weight = weight[i][j];</span><br><span class="line">                            v_1 = i;</span><br><span class="line">                            v_2 = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一条边是最小</span></span><br><span class="line">            System.out.println(<span class="string">"边&lt;"</span> + graph.data[v_1] + <span class="string">","</span> + graph.data[v_2]</span><br><span class="line">                    + <span class="string">"&gt; 权值:"</span> + min_weight);</span><br><span class="line"></span><br><span class="line">            isVisited[v_2] = <span class="keyword">true</span>;</span><br><span class="line">            min_weight = <span class="number">10000</span>; <span class="comment">//初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Test-4"><a href="#Test-4" class="headerlink" title="Test"></a>Test</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.prim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName PrimAlgorithm</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/11/16</span></span><br><span class="line"><span class="comment"> * Time      9:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试看看图是否创建ok</span></span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span></span><br><span class="line">        <span class="keyword">int</span> [][]weight=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MGraph对象</span></span><br><span class="line">        MGraph graph = <span class="keyword">new</span> MGraph(verxs);</span><br><span class="line">        <span class="comment">//创建一个MinTree对象</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试普利姆算法</span></span><br><span class="line">        minTree.prim(graph, <span class="number">0</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="image-20191116110948344" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116110948344.png" class="lazyload"></p>
<h2 id="7、克鲁斯卡尔（Kruskal）算法"><a href="#7、克鲁斯卡尔（Kruskal）算法" class="headerlink" title="7、克鲁斯卡尔（Kruskal）算法"></a>7、克鲁斯卡尔（Kruskal）算法</h2><h3 id="介绍-31"><a href="#介绍-31" class="headerlink" title="介绍"></a>介绍</h3><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p>
<p><strong>基本思想</strong>：<strong>按照权值从小到大的顺序</strong>选择n-1条边，并保证这n-1条边不构成回路</p>
<p>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p>
<h3 id="公交站问题"><a href="#公交站问题" class="headerlink" title="公交站问题"></a>公交站问题</h3><p><img alt="image-20191116140518598" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116140518598.png" class="lazyload"></p>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p><img alt="克鲁斯卡尔" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94.png" class="lazyload"></p>
<p><img alt="image-20191116143005177" data-src="/images/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20191116143005177.png" class="lazyload"></p>
<h2 id="8、-迪杰斯特拉-（Dijkstra）算法"><a href="#8、-迪杰斯特拉-（Dijkstra）算法" class="headerlink" title="8、 迪杰斯特拉 （Dijkstra）算法"></a>8、 迪杰斯特拉 （Dijkstra）算法</h2><h2 id="9、-弗洛伊德（Floyd）算法"><a href="#9、-弗洛伊德（Floyd）算法" class="headerlink" title="9、 弗洛伊德（Floyd）算法"></a>9、 弗洛伊德（Floyd）算法</h2>]]></content>
      <categories>
        <category>java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>医学图像评价指标</title>
    <url>/2019/11/25/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<p>最近写论文需要一些评价指标数据，做个总结，实现python代码</p>
<h1 id="基本评价指标"><a href="#基本评价指标" class="headerlink" title="基本评价指标"></a>基本评价指标</h1><h2 id="FP、FN、TP、TN"><a href="#FP、FN、TP、TN" class="headerlink" title="FP、FN、TP、TN"></a>FP、FN、TP、TN</h2><p><img alt="640?wx_fmt=png" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/p.png" class="lazyload"></p>
<ul>
<li><p>TP：T（预测对了true） P(预测为正样本positive)；真的正值，说明被预测为正样本，预测是真的，即真实值为正样本</p>
</li>
<li><p>TN：T（预测对了true） P(预测为负样本negative)；真的负值，说明被预测为负样本，预测是真的，即真实值为负样本</p>
</li>
<li><p>FP：T（预测错了false）P(预测为正样本positive)；假的正直：说明被预测为正样本，但预测是假的，即真实值为负样本</p>
</li>
<li><p>FN：T（预测错了false）P(预测为负样本negative)；假的负值，说明被预测为负样本，但预测是假的，即真实值为正样</p>
</li>
</ul>
<h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.seterr(divide=<span class="string">'ignore'</span>,invalid=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line">labels=[<span class="string">"dog"</span>, <span class="string">"cat"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_base</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    C2 = confusion_matrix(y_true, y_pred, labels=labels)</span><br><span class="line">    TN, FP, FN, TP = C2.ravel()</span><br><span class="line">    <span class="keyword">return</span> TN, FP, FN, TP</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    y_true = [<span class="string">"dog"</span>, <span class="string">"dog"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>]</span><br><span class="line">    y_pred = [<span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>, <span class="string">"cat"</span>]</span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br></pre></td></tr></table></figure>





<h2 id="精确率-Precision-、召回率-Recall-、准确率-Accuracy"><a href="#精确率-Precision-、召回率-Recall-、准确率-Accuracy" class="headerlink" title="精确率(Precision)、召回率(Recall)、准确率(Accuracy)"></a>精确率(Precision)、召回率(Recall)、准确率(Accuracy)</h2><p><strong>准确率(Accuracy)</strong>：这三个指标里最直观的就是准确率: 模型判断正确的数据(TP+TN)占总数据的比例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Accuracy: "</span>+str(round((tp+tn)/(tp+fp+fn+tn), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>召回率(Recall)：</strong>针对数据集中的所有正例(TP+FN)而言,模型正确判断出的正例(TP)占数据集中所有正例的比例.FN表示被模型误认为是负例但实际是正例的数据.召回率也叫查全率,以物体检测为例,我们往往把图片中的物体作为正例,此时召回率高代表着模型可以找出图片中更多的物体!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Recall: "</span>+str(round((tp)/(tp+fn), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>精确率(Precision)：</strong>针对模型判断出的所有正例(TP+FP)而言,其中真正例(TP)占的比例.精确率也叫查准率,还是以物体检测为例,精确率高表示模型检测出的物体中大部分确实是物体,只有少量不是物体的对象被当成物体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Precision: "</span>+str(round((tp)/(tp+fp), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<h3 id="python代码-1"><a href="#python代码-1" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    classification accuracy，描述分类器的分类准确率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    ACC = str(round((TP + TN)/(TP + FP + FN + TN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Accuracy: "+ ACC)</span></span><br><span class="line">    <span class="keyword">return</span> ACC</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    敏感度（sensitivity）、查全率（Recall）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Recall = str(round((TP)/(TP+FN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Recall: "+ Recall)</span></span><br><span class="line">    <span class="keyword">return</span> Recall</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    查准率（Precision）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Precision</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Precision = str(round(TP/(TP + FP), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("Precision: "+ Precision)</span></span><br><span class="line">    <span class="keyword">return</span> Precision</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    描述识别出的负例占所有负例的比例，特异度（specificity）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specificity</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    <span class="comment">#Positive predictive value</span></span><br><span class="line">    NPV = str(round(TN/(TN + FP + <span class="number">0.01</span>), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("PPV:" + NPV)</span></span><br><span class="line">    <span class="keyword">return</span> NPV</span><br></pre></td></tr></table></figure>









<h1 id="医学图像分割"><a href="#医学图像分割" class="headerlink" title="医学图像分割"></a>医学图像分割</h1><h2 id="DICE"><a href="#DICE" class="headerlink" title="DICE"></a>DICE</h2><p>DICE（值域为[0,1]）: 使用频率最高。数学定义如下，具体表示两个物体相交的面积占总面积的比值，完美分割该值为1</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612115855632.png" class="lazyload"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    python numpy版 dice损失函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">smooth = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DICE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = np.sum(y_true_f * y_pred_f)</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br></pre></td></tr></table></figure>



<h2 id="VOE"><a href="#VOE" class="headerlink" title="VOE"></a>VOE</h2><p>与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612155245106.png" class="lazyload"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    VOE（volumetric overlap error）</span></span><br><span class="line"><span class="string">    与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VOE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = abs(np.sum(y_true_f) - np.sum(y_pred_f))</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br></pre></td></tr></table></figure>



<h2 id="RVD"><a href="#RVD" class="headerlink" title="RVD"></a>RVD</h2><p>表示两者体积之间的差异</p>
<p><img alt="img" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/20180612160043818.png" class="lazyload"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    RVD（relative volume difference）：表示两者体积之间的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RVD</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    numerator = abs(np.sum(y_pred_f) - np.sum(y_true_f))</span><br><span class="line">    denominator = np.sum(y_true_f)</span><br><span class="line">    <span class="keyword">return</span> numerator / (denominator + smooth)</span><br></pre></td></tr></table></figure>



<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/11/25 15:37</span></span><br><span class="line"><span class="comment"># @Author  : MxRanger</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : eval.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.seterr(divide=<span class="string">'ignore'</span>,invalid=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># labels=["dog", "cat"]</span></span><br><span class="line">labels = [<span class="number">1</span> , <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_base</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    C2 = confusion_matrix(y_true, y_pred, labels=labels)</span><br><span class="line">    <span class="comment">#print(C2)</span></span><br><span class="line">    <span class="comment">#print("-------------")</span></span><br><span class="line">    TN, FP, FN, TP = C2.ravel()</span><br><span class="line">    <span class="keyword">return</span> TN, FP, FN, TP</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    classification accuracy，描述分类器的分类准确率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    ACC = str(round((TP + TN)/(TP + FP + FN + TN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Accuracy: "+ ACC)</span></span><br><span class="line">    <span class="keyword">return</span> ACC</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    敏感度（sensitivity）、查全率（Recall）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Recall = str(round((TP)/(TP+FN), <span class="number">3</span>))</span><br><span class="line">    <span class="comment">#print("Recall: "+ Recall)</span></span><br><span class="line">    <span class="keyword">return</span> Recall</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    查准率（Precision）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Precision</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    Precision = str(round(TP/(TP + FP), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("Precision: "+ Precision)</span></span><br><span class="line">    <span class="keyword">return</span> Precision</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    描述识别出的负例占所有负例的比例，特异度（specificity）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specificity</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    TN, FP, FN, TP = cal_base(y_true, y_pred)</span><br><span class="line">    <span class="comment">#Positive predictive value</span></span><br><span class="line">    NPV = str(round(TN/(TN + FP + <span class="number">0.01</span>), <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print("PPV:" + NPV)</span></span><br><span class="line">    <span class="keyword">return</span> NPV</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    python numpy版 dice损失函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">smooth = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DICE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = np.sum(y_true_f * y_pred_f)</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    VOE（volumetric overlap error）</span></span><br><span class="line"><span class="string">    与DICE类似，数学定义如下，它将and操作换成了减法操作，以此来代表错误率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VOE</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    intersection = abs(np.sum(y_true_f) - np.sum(y_pred_f))</span><br><span class="line">    union = np.sum(y_true_f) + np.sum(y_pred_f)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * intersection + smooth) / (union + smooth)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    RVD（relative volume difference）：表示两者体积之间的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RVD</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    y_true_f = y_true.astype(dtype=np.float32).flatten()</span><br><span class="line">    y_pred_f = y_pred.astype(dtype=np.float32).flatten()</span><br><span class="line">    numerator = abs(np.sum(y_pred_f) - np.sum(y_true_f))</span><br><span class="line">    denominator = np.sum(y_true_f)</span><br><span class="line">    <span class="keyword">return</span> numerator / (denominator + smooth)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(mha_path)</span>:</span></span><br><span class="line">    img = sitk.ReadImage(mha_path)</span><br><span class="line">    image = sitk.GetArrayFromImage(img)  <span class="comment"># indexes are z,y,x (notice the ordering)</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># y_true = ["dog", "dog", "dog", "cat", "cat", "cat", "cat"]</span></span><br><span class="line">    <span class="comment"># y_pred = ["cat", "cat", "dog", "cat", "cat", "cat", "cat"]</span></span><br><span class="line">    <span class="comment"># arr = [1,2,0,3,4,5,6]</span></span><br><span class="line">    <span class="comment"># arr[arr == 2] = 7</span></span><br><span class="line">    <span class="comment"># print(arr)</span></span><br><span class="line"></span><br><span class="line">    gt = read(<span class="string">'xxx#gt.mha'</span>)</span><br><span class="line">    pre = read(<span class="string">'xxx.mha'</span>)</span><br><span class="line"></span><br><span class="line">    print(acc(gt.flatten(),pre.flatten()))</span><br><span class="line">    print(DICE(gt,pre))</span><br><span class="line">    print(VOE(gt,pre))</span><br><span class="line">    print(RVD(gt,pre))</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191125174329852" data-src="/images/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/image-20191125174329852.png" class="lazyload"></p>
]]></content>
  </entry>
  <entry>
    <title>JAVA多线程、高并发编程</title>
    <url>/2019/11/17/JAVA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="高并发编程一"><a href="#高并发编程一" class="headerlink" title="高并发编程一"></a>高并发编程一</h1><h2 id="1、synchronized关键字"><a href="#1、synchronized关键字" class="headerlink" title="1、synchronized关键字"></a>1、synchronized关键字</h2><h3 id="1-1、对象锁"><a href="#1-1、对象锁" class="headerlink" title="1.1、对象锁"></a>1.1、对象锁</h3><blockquote>
<p>同步代码块，将需要线性安全的某个操作放入到改代码块中，可以避免超卖，破坏对象的原子性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T1</span></span><br><span class="line"><span class="comment">* synchronized关键字</span></span><br><span class="line"><span class="comment">* 对某个对象加锁</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:47</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object(); <span class="comment">// o 是引用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    栈          __________________</span></span><br><span class="line"><span class="comment">     * |        |    |   new Object()   |</span></span><br><span class="line"><span class="comment">     * |        |   /|------------------|</span></span><br><span class="line"><span class="comment">     * |        |  / |                  |</span></span><br><span class="line"><span class="comment">     * |--------| /  |                  |</span></span><br><span class="line"><span class="comment">     * |___o____|/   |__________________|</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123; <span class="comment">//任何线程要执行下面的代码，必须先拿到o的锁</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t1 = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、this对象"><a href="#1-2、this对象" class="headerlink" title="1.2、this对象"></a>1.2、this对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized关键字</span></span><br><span class="line"><span class="comment">     * 对某个对象加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">//任何线程要执行下面的代码，必须先拿到this的锁</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、synchronized修饰函数"><a href="#1-3、synchronized修饰函数" class="headerlink" title="1.3、synchronized修饰函数"></a>1.3、synchronized修饰函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//等同于在方法的代码执行时要synchronized(this)</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;t.m();&#125;,<span class="string">"t3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、静态方法"><a href="#1-4、静态方法" class="headerlink" title="1.4、静态方法"></a>1.4、静态方法</h3><blockquote>
<p>synchronized 修饰static方法的时候，等同于synchronized(T.class)，</p>
<p>但是不能写synchronized(this)，静态的属性和方法不能new出当前对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//这里等同于synchronized(yxxy.c_004.T.class)</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(T<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">//考虑一下这里写synchronized(this)是否可以？不可以，静态的属性和方法不能new出当前对象</span></span><br><span class="line">            count --;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【5】有无synchronized修饰的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T5;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T5</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分析一下这个程序的输出</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T5</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T5 t = <span class="keyword">new</span> T5();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不加结果如下：</p>
<p><img alt="1552033919404" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552033919404.png" class="lazyload"></p>
<p>加了结果如下：</p>
<p><img alt="1552033984991" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552033984991.png" class="lazyload"></p>
<p><strong>得出结论，有synchronized修饰可以保证count在修改操作的时候保证只有一个线程可以操作，而其他线程必须等待，知道拿到锁才可以进行修改</strong></p>
<h3 id="1-5、synchronized优化"><a href="#1-5、synchronized优化" class="headerlink" title="1.5、synchronized优化"></a>1.5、synchronized优化</h3><blockquote>
<p>同步代码块中的语句越少越好,细粒度锁，提高效率</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">        count ++;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">        <span class="comment">//采用细粒度的锁，可以使线程争用时间变短，从而提高效率</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//do sth need not sync</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、面试1"><a href="#2、面试1" class="headerlink" title="2、面试1"></a>2、面试1</h2><blockquote>
<p>同步方法和非同步方法是否可以同时调用？</p>
<p>可以调用，两者没有冲突</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T7;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T7</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      10:57</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同步和非同步方法是否可以同时调用？</span></span><br><span class="line"><span class="comment">* 可以，两者没有冲突</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T7 t = <span class="keyword">new</span> T7();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*new Thread(()-&gt;t.m1(), "t1").start();</span></span><br><span class="line"><span class="comment">        new Thread(()-&gt;t.m2(), "t2").start();*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、面试2"><a href="#3、面试2" class="headerlink" title="3、面试2"></a>3、面试2</h2><blockquote>
<p>一个Account类的set、get方法是否会产生脏读?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对业务写方法加锁</span></span><br><span class="line"><span class="comment">* 对业务读方法不加锁</span></span><br><span class="line"><span class="comment">* 容易产生脏读问题（dirtyRead）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 在set的时候可能会出现balance未赋值时刚好另一个在取值，若不加锁，则会以默认值输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T8Account</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">double</span> <span class="title">getBalance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T8Account a = <span class="keyword">new</span> T8Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;a.set(<span class="string">"zhangsan"</span>, <span class="number">100.0</span>)).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552035524226" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035524226.png" class="lazyload"></p>
<p>给set和get加上synchronized后结果如下：</p>
<p><img alt="1552035597466" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035597466.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：在使用set方法存储信息的时候，假设利用sleep来模拟这期间的其他进程get的时候，可能会读出默认值的情况，所以需要给set和get方法加上synchronized关键字</strong></span></p>
</blockquote>
<h2 id="4、面试3"><a href="#4、面试3" class="headerlink" title="4、面试3"></a>4、面试3</h2><blockquote>
<p>synchronized是否可以重获锁？</p>
</blockquote>
<h3 id="【1】同类中的两个方法"><a href="#【1】同类中的两个方法" class="headerlink" title="【1】同类中的两个方法"></a>【1】同类中的两个方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T9;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T9</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      11:02</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment">* 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current::this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">"m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m2 start"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current::this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m2 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        T9 t = <span class="keyword">new</span> T9();</span><br><span class="line">        t.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552035830633" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552035830633.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：    一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。也就是说synchronized获得的锁是可重入的。</strong></span></p>
</blockquote>
<h3 id="【2】父子类的情形"><a href="#【2】父子类的情形" class="headerlink" title="【2】父子类的情形"></a>【2】父子类的情形</h3><h4 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this::"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T10;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment">* 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment">* 这里是继承中有可能发生的情形，子类调用父类的同步方法</span></span><br><span class="line"><span class="comment">* 子类的同步方法可以调用父类的同步方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this::"</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">        System.out.println(<span class="string">"child m start"</span>);</span><br><span class="line">        <span class="keyword">super</span>.m();</span><br><span class="line">        System.out.println(<span class="string">"child m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TT().m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552036140086" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552036140086.png" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：在对子类进行创建对象，调用子类函数同时调用父类函数，两边的synchronized对象都是子类对象</strong></span></p>
</blockquote>
<h2 id="5、程序在执行过程中，如果出现异常，锁会被释放"><a href="#5、程序在执行过程中，如果出现异常，锁会被释放" class="headerlink" title="5、程序在执行过程中，如果出现异常，锁会被释放"></a>5、程序在执行过程中，如果出现异常，锁会被释放</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T11;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T11</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      11:06</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 程序在执行过程中，如果出现异常，默认情况锁会被释放</span></span><br><span class="line"><span class="comment">* 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。</span></span><br><span class="line"><span class="comment">* 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，</span></span><br><span class="line"><span class="comment">* 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。</span></span><br><span class="line"><span class="comment">* 因此要非常小心的处理同步业务逻辑中的异常</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">5</span>) &#123;</span><br><span class="line">               <span class="comment">/* try&#123;</span></span><br><span class="line"><span class="comment">                    int i = 1/0; //此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span></span><br><span class="line"><span class="comment">                    System.out.println(i);</span></span><br><span class="line"><span class="comment">                &#125;catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*        Runnable r1 = ()-&gt;&#123;</span></span><br><span class="line"><span class="comment">          t.m();</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="chair" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/chair.gif" class="lazyload"></p>
<p>若将异常放在try…catch中，则锁不会被释放</p>
<p><img alt="chair1" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/chair1.gif" class="lazyload"></p>
<blockquote>
<p><span style="color:red"><strong>结论：线程中出现异常则会释放锁，为保证安全性，将出现异常的代码放在try…catch中，以保证线程的安全。</strong></span></p>
</blockquote>
<h2 id="6、volatile-关键字"><a href="#6、volatile-关键字" class="headerlink" title="6、volatile 关键字"></a>6、volatile 关键字</h2><h3 id="6-1、可见性"><a href="#6-1、可见性" class="headerlink" title="6.1、可见性"></a>6.1、可见性</h3><blockquote>
<pre><code>volatile 关键字，使一个变量在多个线程间可见
A、B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道
使用volatile关键字，会让所有线程都会读到变量的修改值</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>; <span class="comment">//对比一下有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;</span><br><span class="line">            <span class="comment">/* 睡眠了一段时间，cpu会去堆内存中重新获取running的值，就会结束掉。</span></span><br><span class="line"><span class="comment">                若不设置，cpu没空去获取修改后的值</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.MILLISECONDS.sleep(10);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>结论：若不加volatile，则代码会一直运行

在上面的代码中，running是存在于堆内存的t对象中当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行

使用volatile，将会强制所有线程都去堆内存中读取running的值

![1552048554763](/images/java高并发编程/1552048554763.png)

可以阅读这篇文章进行更深入的理解
http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html

volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized

 保证线程之间的内存可见性 能用volatile的时候就不用加锁，无锁同步，synchronized做同步效率低</code></pre></blockquote>
<h3 id="6-2、原子性"><a href="#6-2、原子性" class="headerlink" title="6.2、原子性"></a>6.2、原子性</h3><blockquote>
<pre><code>volatile具备可见性，不具备原子性

synchronized保证可见性和原子性。效率低

volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) count++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o)-&gt;o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o)-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();    <span class="comment">//调用join方法，等待线程o执行完毕</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552048954983" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552048954983.png" class="lazyload"></p>
<blockquote>
<p>由此可见，volatile只保证了可见性，不保证原子性，效率高。</p>
<p>比如A、B线程，A获取到count是100，正准备+1，</p>
<p>B线程此时获取count的时候也是100，也在+1，那么最终的count不是102，应该是101。</p>
<p>volatile可以重复读取，没有保证数据的原子性。</p>
</blockquote>
<p>对以上代码做修改，将需要同步的代码用synchronized修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对比上一个程序，可以用synchronized解决，synchronized可以保证可见性和原子性，volatile只能保证可见性</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552049314896" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552049314896.png" class="lazyload"></p>
<h2 id="7、AtomicXXX类"><a href="#7、AtomicXXX类" class="headerlink" title="7、AtomicXXX类"></a>7、AtomicXXX类</h2><blockquote>
<p>AtomXXX类效率非常高<br>AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="comment">//int count = 0;</span></span><br><span class="line"> </span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            <span class="comment">//if count.get() &lt; 1000     若同时调用AtomXXX类的多个方法，而之间不加锁的话，还是会被打断</span></span><br><span class="line">            <span class="comment">// ++ 不具备原子性    incrementAndGet具备原子性</span></span><br><span class="line">            <span class="comment">//保证线程执行时不会被其他线程打断</span></span><br><span class="line">            count.incrementAndGet(); <span class="comment">//count++</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"> </span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; o.start());</span><br><span class="line"> </span><br><span class="line">        threads.forEach((o) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552049484456" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552049484456.png" class="lazyload"></p>
<blockquote>
<p>结论： ++不保证原子性，AtomXXX类保证原子性</p>
<p>AtomXXX类对象不可使用使用多个方法，方法彼此之间不保证具有原子性</p>
</blockquote>
<h2 id="8、对象锁改变"><a href="#8、对象锁改变" class="headerlink" title="8、对象锁改变"></a>8、对象锁改变</h2><blockquote>
<p>锁定某对象o，如果o的属性发生改变，不影响锁的使用。但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">//启动第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建第二个线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t::m, <span class="string">"t2"</span>);</span><br><span class="line"> </span><br><span class="line">        t.o = <span class="keyword">new</span> Object(); <span class="comment">//锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object.gif" class="lazyload"></p>
<h2 id="9、不要以字符串常量作为锁定对象"><a href="#9、不要以字符串常量作为锁定对象" class="headerlink" title="9、不要以字符串常量作为锁定对象"></a>9、不要以字符串常量作为锁定对象</h2><blockquote>
<p>不要以字符串常量作为锁定对象<br>在下面的例子中，m1和m2其实锁定的是同一个对象<br>这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，<br>但是你读不到源码，所以你在自己的代码中也锁定了”Hello”,这时候就有可能发生非常诡异的死锁阻塞，<br>因为你的程序和你用到的类库不经意间使用了同一把锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    String s2 = <span class="string">"Hello"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10、面试"><a href="#10、面试" class="headerlink" title="10、面试"></a>10、面试</h2><blockquote>
<p>题目：<br> 实现一个容器，提供两个方法，add，size<br> 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</p>
</blockquote>
<h3 id="解法一：使用volatile"><a href="#解法一：使用volatile" class="headerlink" title="解法一：使用volatile"></a>解法一：使用volatile</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer2 c = <span class="keyword">new</span> MyContainer2();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red"><strong>结论：给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu</strong></span></p>
</blockquote>
<h3 id="解法二：使用wait-、notify"><a href="#解法二：使用wait-、notify" class="headerlink" title="解法二：使用wait()、notify()"></a>解法二：使用wait()、notify()</h3><blockquote>
<p>需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以<br>这里使用wait和notify做到，wait会释放锁，而notify不会释放锁,所以若想t1执行，则必须再次wait()让t2释放锁才行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer4</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer4 c = <span class="keyword">new</span> MyContainer4();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">                <span class="keyword">if</span>(c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">                <span class="comment">//通知t1继续执行</span></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                    c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        <span class="comment">//释放锁，让t2得以执行</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object1" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object1.gif" class="lazyload"></p>
<h3 id="解法三：使用CountDownLatch"><a href="#解法三：使用CountDownLatch" class="headerlink" title="解法三：使用CountDownLatch"></a>解法三：使用CountDownLatch</h3><blockquote>
<p>使用Latch（门闩）替代wait notify来进行通知<br>好处是通信方式简单，同时也可以指定等待时间<br>使用await和countdown方法替代wait和notify<br>CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行<br>当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了<br>这时应该考虑countdownlatch/cyclicbarrier/semaphore</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer5</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer5 c = <span class="keyword">new</span> MyContainer5();</span><br><span class="line"> </span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">            <span class="keyword">if</span> (c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"size为5"</span>);</span><br><span class="line">                    <span class="comment">//也可以指定等待时间</span></span><br><span class="line">                    <span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打开门闩，让t2得以执行</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object12" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object12.gif" class="lazyload"></p>
<h1 id="java多线程、高并发编程二"><a href="#java多线程、高并发编程二" class="headerlink" title="java多线程、高并发编程二"></a>java多线程、高并发编程二</h1><blockquote>
<p> java多线程三个主要部分</p>
<ul>
<li>synchronizer</li>
<li>同步容器</li>
<li>ThreadPool、executor</li>
</ul>
</blockquote>
<h2 id="1、ReentrantLock关键字"><a href="#1、ReentrantLock关键字" class="headerlink" title="1、ReentrantLock关键字"></a>1、ReentrantLock关键字</h2><h3 id="1、手动锁"><a href="#1、手动锁" class="headerlink" title="1、手动锁"></a>1、手动锁</h3><blockquote>
<p>使用reentrantlock可以完成同样的功能</p>
<ul>
<li>需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</li>
<li>使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</li>
</ul>
<p><span style="color:red"><strong>ReentrantLock是手动锁，自己创建自己释放</strong></span></p>
<p><span style="color:red"><strong>synchronized是自动锁，{}范围就行</strong></span></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//synchronized(this)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"m2 ..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock2 rl = <span class="keyword">new</span> ReentrantLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552119906562" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552119906562.png" class="lazyload"></p>
<h3 id="2、尝试锁定"><a href="#2、尝试锁定" class="headerlink" title="2、尝试锁定"></a>2、尝试锁定</h3><blockquote>
<pre><code>使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待

根据tryLock的返回值来判定是否锁定  lock.lock()

可以指定tryLock的时间  lock.tryLock(5, TimeUnit.SECONDS)</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行</span></span><br><span class="line"><span class="comment">     * 可以根据tryLock的返回值来判定是否锁定</span></span><br><span class="line"><span class="comment">     * 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean locked = lock.tryLock();</span></span><br><span class="line"><span class="comment">        System.out.println("m2 ..." + locked);</span></span><br><span class="line"><span class="comment">        if(locked) lock.unlock();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">"m2 ..."</span> + locked);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked) lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock3 rl = <span class="keyword">new</span> ReentrantLock3();</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、打断线程"><a href="#3、打断线程" class="headerlink" title="3、打断线程"></a>3、打断线程</h3><blockquote>
<p>使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，在一个线程等待锁的过程中，可以被打断。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T20;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ReentrantLock1</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/7</span></span><br><span class="line"><span class="comment"> * Time      22:49</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* reentrantlock用于替代synchronized</span></span><br><span class="line"><span class="comment">* 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span></span><br><span class="line"><span class="comment">* 这里是复习synchronized最原始的语义</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用reentrantlock可以完成同样的功能</span></span><br><span class="line"><span class="comment">* 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span></span><br><span class="line"><span class="comment">* 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，</span></span><br><span class="line"><span class="comment">* 在一个线程等待锁的过程中，可以被打断</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//lock.lock();</span></span><br><span class="line">                System.out.println(<span class="string">"----------3"</span>);</span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">//可以对interrupt()方法做出响应</span></span><br><span class="line">                System.out.println(<span class="string">"----------4"</span>);</span><br><span class="line">                System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="string">"t2 end"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> locked = ((ReentrantLock) lock).isLocked();<span class="comment">//查询此锁是否由任何线程持有</span></span><br><span class="line">                System.out.println(<span class="string">"locked::"</span>+locked);</span><br><span class="line">                <span class="keyword">if</span> (locked != <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//不能释放别人打开的锁，否则报错Exception in thread "Thread-1" java.lang.IllegalMonitorStateException</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------1"</span>);</span><br><span class="line">        t2.interrupt(); <span class="comment">//打断线程2的等待</span></span><br><span class="line">        System.out.println(<span class="string">"-----------2"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552120908663" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552120908663.png" class="lazyload"></p>
<p>程序执行流程如下：</p>
<p><img alt="1552121643790" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552121643790.png" class="lazyload"></p>
<h3 id="4、公平锁"><a href="#4、公平锁" class="headerlink" title="4、公平锁"></a>4、公平锁</h3><blockquote>
<p>每一个线程都能平等分配到lock，只需在创建对象带入参数true即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//参数为true表示为公平锁，请对比输出结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock5 rl=<span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        Thread th1=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th2=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th3=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th4=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">        th4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>每个线程都能平等有序的分配到锁</p>
<p><img alt="1552121776463" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552121776463.png" class="lazyload"></p>
<h2 id="2、面试题"><a href="#2、面试题" class="headerlink" title="2、面试题"></a>2、面试题</h2><blockquote>
<p>面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</p>
<p>假设：生产者2个，每个生产25件。消费者10个，每个消费5件</p>
</blockquote>
<h3 id="解法一：使用synchronized、wait、notify"><a href="#解法一：使用synchronized、wait、notify" class="headerlink" title="解法一：使用synchronized、wait、notify"></a>解法一：使用synchronized、wait、notify</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T21;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/9</span></span><br><span class="line"><span class="comment"> * Time      21:34</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">10</span>;    <span class="comment">//限制容器大小10</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(list.size() == NUM)&#123;</span><br><span class="line">            System.out.println(<span class="string">"容器已满..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"正在存 ..."</span>+obj);</span><br><span class="line">        list.add(obj);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();<span class="comment">//通知所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"容器空,等待中..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T first = list.removeFirst();</span><br><span class="line">        System.out.println(<span class="string">"正在取..."</span> + first);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();<span class="comment">//通知所有等待线程</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test&lt;String&gt; test = <span class="keyword">new</span> Test&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;<span class="comment">//消费者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+test.get());</span><br><span class="line">            &#125;,<span class="string">"consumer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;<span class="comment">//生产者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++)</span><br><span class="line">                    test.put(Thread.currentThread().getName()+<span class="string">" "</span>+j);</span><br><span class="line">            &#125;,<span class="string">"producer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="object123" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/object123-1552145403929.gif" class="lazyload"></p>
<p>程序原理图如下：</p>
<h3 id="解法二：使用Lock、Condition"><a href="#解法二：使用Lock、Condition" class="headerlink" title="解法二：使用Lock、Condition"></a>解法二：使用Lock、Condition</h3><blockquote>
<p>使用Lock和Condition来实现<br>对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size() == MAX) &#123; <span class="comment">//想想为什么用while而不是用if？</span></span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            lists.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll(); <span class="comment">//通知消费者线程进行消费</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = lists.removeFirst();</span><br><span class="line">            count --;</span><br><span class="line">            producer.signalAll(); <span class="comment">//通知生产者进行生产</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer2&lt;String&gt; c = <span class="keyword">new</span> MyContainer2&lt;&gt;();</span><br><span class="line">        <span class="comment">//启动消费者线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) System.out.println(c.get());</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//启动生产者线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">            &#125;, <span class="string">"p"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、ThreadLocal关键字"><a href="#3、ThreadLocal关键字" class="headerlink" title="3、ThreadLocal关键字"></a>3、ThreadLocal关键字</h2><blockquote>
<p>ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
</blockquote>
<p>抛砖引玉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T22;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ThreadLocal1</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocal线程局部变量</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 马士兵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(p.name);</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            p.name = <span class="string">"lisi"</span>;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552181901880" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552181901880.png" class="lazyload"></p>
<blockquote>
<p>程序执行过程：</p>
<p>两个线程同时启动，第一个线程先睡2秒，第二个线程睡1秒后将name改掉后第一个线程输出lisi</p>
</blockquote>
<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><blockquote>
<p>ThreadLocal 用来提供线程的局部变量</p>
<p><span style="color:red"><strong>当前线程存的变量只能在当前线程中使用，其他线程无法使用</strong></span></p>
<p><span style="color:red"><strong>使用ThreadLocal的数据不用上锁</strong></span></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T22;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName ThreadLocal2</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocal线程局部变量</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ThreadLocal是使用空间换时间，synchronized是使用时间换空间</span></span><br><span class="line"><span class="comment">* 比如在hibernate中session就存在与ThreadLocal中，避免synchronized的使用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 运行下面的程序，理解ThreadLocal</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 马士兵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile static Person p = new Person();</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Person&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(tl.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            tl.set(<span class="keyword">new</span> Person());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="1552182492710" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552182492710.png" class="lazyload"></p>
<blockquote>
<p>闲谈：</p>
<p>数据库的高并发的处理：</p>
<p>加索引、分库、分表、读写分离、主从结构</p>
</blockquote>
<h2 id="4、Singleton-单例模式"><a href="#4、Singleton-单例模式" class="headerlink" title="4、Singleton 单例模式"></a>4、Singleton 单例模式</h2><blockquote>
<p><strong>单例模式就是说系统中对于某类的只能有一个对象，不可能出来第二个</strong></p>
</blockquote>
<h3 id="1、实例一（不使用同步锁）"><a href="#1、实例一（不使用同步锁）" class="headerlink" title="1、实例一（不使用同步锁）"></a>1、实例一（不使用同步锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sin=<span class="keyword">new</span> Singleton();    <span class="comment">///直接初始化一个实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;    <span class="comment">///private类型的构造函数，保证其他类对象不能直接new一个该对象的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSin</span><span class="params">()</span></span>&#123;    <span class="comment">///该类唯一的一个public方法  </span></span><br><span class="line">        <span class="keyword">return</span> sin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中的一个缺点是该类加载的时候就会直接new 一个静态对象出来，当系统中这样的类较多时，会使得启动速度变慢 。现在流行的设计都是讲<strong>“延迟加载”</strong>，我们可以在第一次使用的时候才初始化第一个该类对象。所以这种适合在小系统。</p>
</blockquote>
<h3 id="2、实例二（使用同步锁）"><a href="#2、实例二（使用同步锁）" class="headerlink" title="2、实例二（使用同步锁）"></a>2、实例二（使用同步锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>)   </span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、实例三（小粒度双重同步锁）"><a href="#3、实例三（小粒度双重同步锁）" class="headerlink" title="3、实例三（小粒度双重同步锁）"></a>3、实例三（小粒度双重同步锁）</h3><blockquote>
<p>上述代码中的一次锁住了一个方法， 这个粒度有点大 ，改进就是只锁住其中的new语句就OK。就是所谓的“双重锁”机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                   instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、内部类方式："><a href="#4、内部类方式：" class="headerlink" title="4、内部类方式："></a>4、内部类方式：</h3><blockquote>
<p> 既不用加锁，也能实现懒加载</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"single"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">200</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Singleton.getSingle());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Arrays.asList(ths).forEach(o-&gt;o.start());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、面试题-买票"><a href="#5、面试题-买票" class="headerlink" title="5、面试题 买票"></a>5、面试题 买票</h2><blockquote>
<p>有N张火车票，每张票都有一个编号<br>同时有10个窗口对外售票<br>请写一个模拟程序</p>
</blockquote>
<h3 id="程序一："><a href="#程序一：" class="headerlink" title="程序一："></a>程序一：</h3><blockquote>
<p>出现超卖的情况</p>
<p>list的方法不具备原子性操作，会出现只剩一个的时候多个线程同时remove导致下面的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) tickets.add(<span class="string">"票编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552194906999" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552194906999.png" class="lazyload"></p>
<h3 id="程序二：使用Vector"><a href="#程序二：使用Vector" class="headerlink" title="程序二：使用Vector"></a>程序二：使用Vector</h3><blockquote>
<p>以下代码在while中加入睡眠10秒后依然会出现上面的问题</p>
<p>原因：</p>
<p>Vector的方法虽然具备原子操作，但是同时使用两个方法不能保证原子操作，size()的原子操作范围只在判断处，remove()的原子操作在后面，判断操作和修改操作分离了，不在同一个原子操作中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Vector&lt;String&gt; tickets = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：<br>就算操作A和B都是同步的，但A和B组成的复合操作也未必是同步的，仍然需要自己进行同步<br>就像这个程序，判断size和进行remove必须是一整个的原子操作</strong></p>
</blockquote>
<h3 id="程序三：使用synchronized"><a href="#程序三：使用synchronized" class="headerlink" title="程序三：使用synchronized"></a>程序三：使用synchronized</h3><blockquote>
<p>下面程序不会出现问题，synchronized保证了tickets操作时的原子性，但是synchronized的效率很低。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(tickets) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(tickets.size() &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="程序四：使用ConcurrentLinkedQueue"><a href="#程序四：使用ConcurrentLinkedQueue" class="headerlink" title="程序四：使用ConcurrentLinkedQueue"></a>程序四：使用ConcurrentLinkedQueue</h3><blockquote>
<p>程序正常运行，不会出错。</p>
<p>ConcurrentLinkedQueue 的底层使用的是CAS算法，而非synchronized，效率高。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Queue&lt;String&gt; tickets = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    String s = tickets.poll();</span><br><span class="line">                    <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> System.out.println(<span class="string">"销售了--"</span> + s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、Map、Set"><a href="#6、Map、Set" class="headerlink" title="6、Map、Set"></a>6、Map、Set</h2><blockquote>
<p>对于map、set<br>不使用多线程（不加锁）：HashMap、TreeMap、LinkedHashMap</p>
<p>并发量小（加锁）：Hashtable、Collections.sychronizedXXX  （不怎么用，将不加锁的map转成上锁的map）</p>
<p>并发量大：ConcurrentHashMap  ConcurrentSkipListMap</p>
</blockquote>
<h3 id="1、ConcurrentMap关键字"><a href="#1、ConcurrentMap关键字" class="headerlink" title="1、ConcurrentMap关键字"></a>1、ConcurrentMap关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* http://blog.csdn.net/sunxianghuang/article/details/52221913</span></span><br><span class="line"><span class="comment">* http://www.educity.cn/java/498061.html</span></span><br><span class="line"><span class="comment">* 阅读concurrentskiplistmap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ConcurrentMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();    //262ms 大锁分成小锁</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(); <span class="comment">//高并发并且排序  340ms</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();    //370ms</span></span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //Collections.synchronizedXXX</span></span><br><span class="line">        <span class="comment">//TreeMap</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(ths.length);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) map.put(<span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>), <span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7、队列"><a href="#7、队列" class="headerlink" title="7、队列"></a>7、队列</h2><blockquote>
<p>不需要同步队列：ArrayList、LinkedList</p>
<p>并发量比较低：Collections.synchronizedXXX</p>
<p>写少读多（没有脏读，不需要锁）：CopyOnWriteList</p>
<p>并发量高：Queue<br> [1]高并发加锁队列<br> CocurrentLinkedQueue //concurrentArrayQueue<br> [2]阻塞式队列<br> BlockingQueue<br>     LinkedBQ<br>     ArrayBQ<br>     TransferQueue<br>     SynchronusQueue<br> DelayQueue——执行定时任务</p>
</blockquote>
<h3 id="1、CopyOnWriteArrayList关键字"><a href="#1、CopyOnWriteArrayList关键字" class="headerlink" title="1、CopyOnWriteArrayList关键字"></a>1、CopyOnWriteArrayList关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 写时复制容器 copy on write</span></span><br><span class="line"><span class="comment">* 多线程环境下，写时效率低，读时效率高</span></span><br><span class="line"><span class="comment">* 适合写少读多的环境</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; lists =</span><br><span class="line">                <span class="comment">//new ArrayList&lt;&gt;(); //这个会出并发问题！</span></span><br><span class="line">                <span class="comment">//new Vector();</span></span><br><span class="line">                <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) lists.add(<span class="string">"a"</span> + r.nextInt(<span class="number">10000</span>));</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        runAndComputeTime(ths);</span><br><span class="line"> </span><br><span class="line">        System.out.println(lists.size());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAndComputeTime</span><span class="params">(Thread[] ths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">        Arrays.asList(ths).forEach(t-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();<span class="comment">//Waits for this thread to die.</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(s2 - s1);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Collections-synchronizedListXXX"><a href="#2、Collections-synchronizedListXXX" class="headerlink" title="2、Collections.synchronizedListXXX"></a>2、Collections.synchronizedListXXX</h3><blockquote>
<p>给list加锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SynchronizedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//给strs加锁，所有方法都上了锁</span></span><br><span class="line">        List&lt;String&gt; strsSync = Collections.synchronizedList(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、ConcurrentLinkedQueue-关键字"><a href="#3、ConcurrentLinkedQueue-关键字" class="headerlink" title="3、ConcurrentLinkedQueue 关键字"></a>3、ConcurrentLinkedQueue 关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ConcurrentQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; strs = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            strs.offer(<span class="string">"a"</span> + i);  <span class="comment">//add 若满了，add会报异常，offer会返回false</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs);</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.poll());<span class="comment">//拿头出来并删除</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        System.out.println(strs.peek());<span class="comment">//拿头出来不删除</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//双端队列Deque</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4、LinkedBlockingQueue关键字"><a href="#4、LinkedBlockingQueue关键字" class="headerlink" title="4、LinkedBlockingQueue关键字"></a>4、LinkedBlockingQueue关键字</h3><blockquote>
<p>生产一个，消费一个，不论空的还是满的都会在等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();<span class="comment">//如果不指定容量，默认为Integer.MAX_VALUE 无界队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个生产者，生产100个</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"生产 -"</span>+i);</span><br><span class="line">                    strs.put(<span class="string">"a"</span> + i); <span class="comment">//如果满了，就会等待</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"p1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//5个消费者进行消费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" take -"</span> + strs.take()); <span class="comment">//如果空了，就会等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552303987293" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552303987293.png" class="lazyload"></p>
<h3 id="5、ArrayBlockingQueue关键字"><a href="#5、ArrayBlockingQueue关键字" class="headerlink" title="5、ArrayBlockingQueue关键字"></a>5、ArrayBlockingQueue关键字</h3><blockquote>
<p>有序队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);<span class="comment">//有界队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            strs.put(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        strs.put(<span class="string">"aaa"</span>); <span class="comment">//满了就会等待，程序阻塞</span></span><br><span class="line">        <span class="comment">//strs.add("aaa");</span></span><br><span class="line">        <span class="comment">//strs.offer("aaa");//add 若满了，add会报异常，offer会返回false</span></span><br><span class="line">        <span class="comment">//strs.offer("aaa", 1, TimeUnit.SECONDS);//按时间段加值，若加不进去就不加</span></span><br><span class="line"> </span><br><span class="line">        System.out.println(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、DelayQueue-关键字"><a href="#6、DelayQueue-关键字" class="headerlink" title="6、DelayQueue 关键字"></a>6、DelayQueue 关键字</h3><blockquote>
<p>DelayQueue 常用于执行定时任务，且队列中的对象必须实现Delayed的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();<span class="comment">//无界队列，但是消费的时候需要在一定固定时间后才能拿出来</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> runningTime;</span><br><span class="line"> </span><br><span class="line">        MyTask(<span class="keyword">long</span> rt) &#123;</span><br><span class="line">            <span class="keyword">this</span>.runningTime = rt;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还剩多长时间才能拿出</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span> + runningTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        MyTask t1 = <span class="keyword">new</span> MyTask(now + <span class="number">1000</span>);</span><br><span class="line">        MyTask t2 = <span class="keyword">new</span> MyTask(now + <span class="number">2000</span>);</span><br><span class="line">        MyTask t3 = <span class="keyword">new</span> MyTask(now + <span class="number">1500</span>);</span><br><span class="line">        MyTask t4 = <span class="keyword">new</span> MyTask(now + <span class="number">2500</span>);</span><br><span class="line">        MyTask t5 = <span class="keyword">new</span> MyTask(now + <span class="number">500</span>);</span><br><span class="line"> </span><br><span class="line">        tasks.put(t1);</span><br><span class="line">        tasks.put(t2);</span><br><span class="line">        tasks.put(t3);</span><br><span class="line">        tasks.put(t4);</span><br><span class="line">        tasks.put(t5);</span><br><span class="line"> </span><br><span class="line">        System.out.println(tasks);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(tasks.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、SynchronousQueue-关键字"><a href="#7、SynchronousQueue-关键字" class="headerlink" title="7、SynchronousQueue 关键字"></a>7、SynchronousQueue 关键字</h3><blockquote>
<p>不进入队列，当生产者生产出来的时候，必须要有消费者进行消费</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SynchronusQueue</span> </span>&#123;<span class="comment">//容量为0，有东西来消费者必须要消费掉</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(strs.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        strs.put(<span class="string">"aaa"</span>); <span class="comment">//阻塞等待消费者消费</span></span><br><span class="line">        <span class="comment">//strs.add("aaa");</span></span><br><span class="line">        System.out.println(strs.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="案例：依次打印ABABABAB…"><a href="#案例：依次打印ABABABAB…" class="headerlink" title="案例：依次打印ABABABAB…."></a>案例：依次打印ABABABAB….</h2><h3 id="解法一：使用wait-notify"><a href="#解法一：使用wait-notify" class="headerlink" title="解法一：使用wait()  notify()"></a>解法一：使用wait()  notify()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T25.printAB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/10</span></span><br><span class="line"><span class="comment"> * Time      22:21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.print(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.print(<span class="string">"B"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    object.notify();<span class="comment">//先通知</span></span><br><span class="line">                    object.wait();<span class="comment">//后释放</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.A();</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.B();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="AB" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AB.gif" class="lazyload"></p>
<h3 id="解法二：使用ReentrantLock"><a href="#解法二：使用ReentrantLock" class="headerlink" title="解法二：使用ReentrantLock"></a>解法二：使用ReentrantLock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T25.printAB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName Test2</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/10</span></span><br><span class="line"><span class="comment"> * Time      23:12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition ca = lock.newCondition();</span><br><span class="line">    Condition cb = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            System.out.print(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                ca.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cb.signalAll();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            System.out.print(<span class="string">"B"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                ca.signalAll();</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//===============================</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test2.A();</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test2.B();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="java多线程、高并发编程三"><a href="#java多线程、高并发编程三" class="headerlink" title="java多线程、高并发编程三"></a>java多线程、高并发编程三</h1><h2 id="1、线程池须知的一些接口和类"><a href="#1、线程池须知的一些接口和类" class="headerlink" title="1、线程池须知的一些接口和类"></a>1、线程池须知的一些接口和类</h2><h3 id="1、Executor-关键字"><a href="#1、Executor-关键字" class="headerlink" title="1、Executor 关键字"></a>1、Executor 关键字</h3><blockquote>
<p>调用executor的execute方法会执行Runnable的run方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 认识Executor   执行任务的接口，只有一个方法execute</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T01_MyExecutor().execute(()-&gt;System.out.println(<span class="string">"hello executor"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Thread(command).run();</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、ExecutorService-关键字"><a href="#2、ExecutorService-关键字" class="headerlink" title="2、ExecutorService 关键字"></a>2、ExecutorService 关键字</h3><blockquote>
<p>对Executor的拓展接口，其中的submit方法带有返回值</p>
</blockquote>
<p><img alt="1552379303479" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552379303479.png" class="lazyload"></p>
<h3 id="3、Callable-关键字"><a href="#3、Callable-关键字" class="headerlink" title="3、Callable 关键字"></a>3、Callable 关键字</h3><blockquote>
<p>Callable类似于Runnable</p>
<p>Runnable的run方法没有返回值，Callable的call方法有返回值</p>
</blockquote>
<p><img alt="1552379414728" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552379414728.png" class="lazyload"></p>
<h3 id="4、Executors-、Executor"><a href="#4、Executors-、Executor" class="headerlink" title="4、Executors 、Executor"></a>4、Executors 、Executor</h3><blockquote>
<p>Executor用来执行提交的对象Runnable任务</p>
<p>Executors用来调度何种线程池</p>
</blockquote>
<h2 id="2、Executors-线程池"><a href="#2、Executors-线程池" class="headerlink" title="2、Executors 线程池"></a>2、Executors 线程池</h2><h3 id="1、newFixedThreadPool"><a href="#1、newFixedThreadPool" class="headerlink" title="1、newFixedThreadPool"></a>1、newFixedThreadPool</h3><table>
<thead>
<tr>
<th>newFixedThreadPool(int nThreads)</th>
</tr>
</thead>
<tbody><tr>
<td>创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。</td>
</tr>
</tbody></table>
<p>static ExecutorService newFixedThreadPool(int nThreads)</p>
<blockquote>
<p><img alt="1552380480772" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552380480772.png" class="lazyload"></p>
<p>创建一个线程池，传入固定的线程数</p>
<p>将线程放入LinkedBlockingQueue队列中</p>
</blockquote>
<p><strong>下述代码中：</strong></p>
<pre><code>使用Executor的子接口ExecutorService来创建5个固定线程的线程池，调用execute方法便是执行了Runnable的run方法，执行了睡500毫秒打印当前线程名的任务</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//execute执行无返回值 submit执行有/无返回值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        service.shutdown();<span class="comment">//等所有任务执行完才能关闭</span></span><br><span class="line">        System.out.println(service.isTerminated());<span class="comment">//查看是否所有任务执行完</span></span><br><span class="line">        System.out.println(service.isShutdown());<span class="comment">//是不是关闭了</span></span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(service.isTerminated());</span><br><span class="line">        System.out.println(service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552380940265" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552380940265.png" class="lazyload"></p>
<h4 id="1、Future接口实现类——FutureTask"><a href="#1、Future接口实现类——FutureTask" class="headerlink" title="1、Future接口实现类——FutureTask"></a>1、Future接口实现类——FutureTask</h4><blockquote>
<p>线程可以输出返回值</p>
</blockquote>
<table>
<thead>
<tr>
<th>FutureTask(Callable<v> callable)</v></th>
</tr>
</thead>
<tbody><tr>
<td>创建一个 <code>FutureTask</code> ，它将在运行时执行给定的 <code>Callable</code>，并给出返回值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_Future</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;); <span class="comment">//new Callable () &#123; Integer call();&#125;</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(task.get()); <span class="comment">//阻塞，直到拿到Callable的call返回的值</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Future&lt;Integer&gt; f = service.submit(()-&gt;&#123;<span class="comment">//重写Callable的call方法</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">        System.out.println(f.isDone());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552398499806" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552398499806.png" class="lazyload"></p>
<h4 id="2、并行计算"><a href="#2、并行计算" class="headerlink" title="2、并行计算"></a>2、并行计算</h4><blockquote>
<p>5个线程并行计算1-200000以内的素数的时间</p>
</blockquote>
<p>在上述提到ExecutorService的submit方法的参数可以是Runnable，也可以是Callable，本次采用Callable可以收到返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池的概念</span></span><br><span class="line"><span class="comment">* nasa</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_ParallelComputing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//=====================不用线程，直接算1-200000之间的素数==============================</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        getPrime(<span class="number">1</span>, <span class="number">200000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> processors = Runtime.getRuntime().availableProcessors();<span class="comment">//返回当前电脑的cpu核数</span></span><br><span class="line">        System.out.println(<span class="string">"processorsNum::"</span>+processors);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//==========使用4个线程，将1-200000进行切片并行计算得到返回值============================</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpuCoreNum = <span class="number">4</span>;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class="line"> </span><br><span class="line">        MyTask t1 = <span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">80000</span>); <span class="comment">//1-5 5-10 10-15 15-20</span></span><br><span class="line">        MyTask t2 = <span class="keyword">new</span> MyTask(<span class="number">80001</span>, <span class="number">130000</span>);</span><br><span class="line">        MyTask t3 = <span class="keyword">new</span> MyTask(<span class="number">130001</span>, <span class="number">170000</span>);</span><br><span class="line">        MyTask t4 = <span class="keyword">new</span> MyTask(<span class="number">170001</span>, <span class="number">200000</span>);</span><br><span class="line"> </span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(t1);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(t2);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(t3);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(t4);</span><br><span class="line"> </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        f1.get();</span><br><span class="line">        f2.get();</span><br><span class="line">        f3.get();</span><br><span class="line">        f4.get();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startPos, endPos;</span><br><span class="line"> </span><br><span class="line">        MyTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = s;</span><br><span class="line">            <span class="keyword">this</span>.endPos = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; r = getPrime(startPos, endPos);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是素数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出start到end之间的素数，并放入list中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i)) results.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><strong>并行计算速度很快</strong></p>
<p><img alt="1552399229946" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552399229946.png" class="lazyload"></p>
<h3 id="2、CachedPool"><a href="#2、CachedPool" class="headerlink" title="2、CachedPool"></a>2、CachedPool</h3><blockquote>
<pre><code>弹性线程池，有一个任务，就开启一个线程，每个线程都activetime，超过这个时间未开启则销毁该线程

查看源码：存活时间为60s，无界队列，最大Integer.MAX_VALUE基本达不到
![1552399339664](/images/java高并发编程/1552399339664.png)</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T08_CachedPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:51</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 弹性线程池，有一个任务，就开启一个线程，每个线程都activetime，超过这个时间未开启则销毁该线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_CachedPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line"> </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">80</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552399699835" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552399699835.png" class="lazyload"></p>
<h3 id="3、newSingleThreadExecutor"><a href="#3、newSingleThreadExecutor" class="headerlink" title="3、newSingleThreadExecutor"></a>3、newSingleThreadExecutor</h3><blockquote>
<p>查看源码：线程数限制为1个</p>
<p><img alt="1552400118289" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400118289.png" class="lazyload"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line"> </span><br><span class="line">                System.out.println(j + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：只有一个线程在执行</strong></p>
<p><img alt="1552400068650" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400068650.png" class="lazyload"></p>
<h3 id="4、newScheduledThreadPool"><a href="#4、newScheduledThreadPool" class="headerlink" title="4、newScheduledThreadPool"></a>4、newScheduledThreadPool</h3><blockquote>
<p>源码查看：每隔一段时间执行一个线程</p>
<p><img alt="1552400446939" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400446939.png" class="lazyload"></p>
<p>service.scheduleAtFixedRate的相关参数</p>
<p><img alt="1552400730234" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552400730234.png" class="lazyload"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_ScheduledPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="schedule" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/schedule.gif" class="lazyload"></p>
<h3 id="5、ForkJoinPool"><a href="#5、ForkJoinPool" class="headerlink" title="5、ForkJoinPool"></a>5、ForkJoinPool</h3><blockquote>
<p>原理和MapReduce类似</p>
</blockquote>
<p><img alt="1552401802490" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552401802490.png" class="lazyload"></p>
<blockquote>
<p>ForkJoinPool的execute方法的参数是ForkJoinTask类</p>
<p>ForkJoinTask类有两个直接子类分类为： RecursiveAction和RecursiveTask</p>
</blockquote>
<h4 id="案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算"><a href="#案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算" class="headerlink" title="案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算"></a><strong>案例：创建数组大小为1000000，每个线程限制50000个数以内，并行求和计算</strong></h4><p>下面代码的原理图如下：</p>
<p><img alt="1552465325571" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552465325571.png" class="lazyload"></p>
<h5 id="1、RecursiveAction子类实现"><a href="#1、RecursiveAction子类实现" class="headerlink" title="1、RecursiveAction子类实现"></a>1、RecursiveAction子类实现</h5><blockquote>
<p>无返回值，只能在compute方法中打印查看</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T12_ForkJoinPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.stream(nums).sum()); <span class="comment">//stream api</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"> </span><br><span class="line">        AddTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">                System.out.println(<span class="string">"from:"</span> + start + <span class="string">" to:"</span> + end + <span class="string">" = "</span> + sum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">                AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">                AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        <span class="comment">//long result = task.join();</span></span><br><span class="line">        <span class="comment">//System.out.println(result);</span></span><br><span class="line"> </span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552464765077" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552464765077.png" class="lazyload"></p>
<h5 id="2、RecursiveTask子类实现"><a href="#2、RecursiveTask子类实现" class="headerlink" title="2、RecursiveTask子类实现"></a>2、RecursiveTask子类实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T12_ForkJoinPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.stream(nums).sum()); <span class="comment">//stream api</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"> </span><br><span class="line">        AddTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">            AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">            subTask1.fork();</span><br><span class="line">            subTask2.fork();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        <span class="keyword">long</span> result = task.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//System.in.read();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、WorkStealingPool"><a href="#6、WorkStealingPool" class="headerlink" title="6、WorkStealingPool"></a>6、WorkStealingPool</h3><blockquote>
<p><strong>WorkStealingPool是在ForkJoinPool的基础上做了封装</strong></p>
<p>WorkStealingPool中的每个线程都有自己的任务队列，如果某一个线程完成后队列也没有任务，就会去其他的线程任务队列中拿任务做。主动找活干</p>
<p>由于我的电脑是12线程，所以我开了14个线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T11_WorkStealingPool</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:52</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 主动找活干</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_WorkStealingPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));<span class="comment">//daemon</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//由于产生的是精灵线程（守护线程、后台线程），主线程不阻塞的话，看不到输出</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line"> </span><br><span class="line">        R(<span class="keyword">int</span> t) &#123;</span><br><span class="line">            <span class="keyword">this</span>.time = t;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(time  + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="1552466044537" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552466044537.png" class="lazyload"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>如果想要自己打造一个线程池，可以继承ThreadPoolExecutor来创造自己的线程池</p>
<h2 id="parallelStream-API（多线程）"><a href="#parallelStream-API（多线程）" class="headerlink" title="parallelStream API（多线程）"></a>parallelStream API（多线程）</h2><blockquote>
<p><strong>jdk1.8新增的比较方便的接口，使用多线程来进行一起做事</strong></p>
<p>List中存着10000个数，并判断是否为素数，常规方法是遍历所有的数进行判断，速度慢。</p>
<p>Collection中提供了parallelStream的方式进行遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mxranger.concurrent.T26;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName T14_ParallelStreamAPI</span></span><br><span class="line"><span class="comment"> * Author    MxRanger</span></span><br><span class="line"><span class="comment"> * Date      2019/3/8</span></span><br><span class="line"><span class="comment"> * Time      13:54</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T14_ParallelStreamAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) nums.add(<span class="number">1000000</span> + r.nextInt(<span class="number">1000000</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//System.out.println(nums);</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        nums.forEach(v-&gt;isPrime(v));</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用parallel stream api</span></span><br><span class="line"> </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        nums.parallelStream().forEach(T14_ParallelStreamAPI::isPrime);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>在判断10000个数是否为素数上速度差距很大</p>
<p><img alt="1552466241334" data-src="/images/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1552466241334.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现微信公众号信息推送</title>
    <url>/2019/11/17/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<blockquote>
<p>本教程使用的是个人测试账号，企业微信公众号稍有出入<br>主要用来做服务异常报警处理，也可以使用推送邮件，但是显得过重，所以使用微信推送消息简洁</p>
</blockquote>
<h2 id="1、注册账号"><a href="#1、注册账号" class="headerlink" title="1、注册账号"></a>1、注册账号</h2><p>前往网站 <em><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></em> 注册账号</p>
<p>获取 appID 、 appsecret，后面有用</p>
<p><img alt="1557989221693" data-src="http://img.mxranger.cn/1557989221693.png" class="lazyload"></p>
<h2 id="2、获取ACCESS-TOKEN"><a href="#2、获取ACCESS-TOKEN" class="headerlink" title="2、获取ACCESS_TOKEN"></a>2、获取ACCESS_TOKEN</h2><blockquote>
<p> 官网教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183</a></p>
</blockquote>
<p><strong>注意：access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试账号id secret</span></span><br><span class="line">    appid = <span class="string">"xxxxxxxxxxxxxxxxxx"</span></span><br><span class="line">    secret = <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="</span>+appid+<span class="string">"&amp;secret="</span>+secret</span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    access_token = res.json()[<span class="string">"access_token"</span>]</span><br><span class="line">    print(access_token)</span><br></pre></td></tr></table></figure>

<h2 id="3、设置信息模板"><a href="#3、设置信息模板" class="headerlink" title="3、设置信息模板"></a>3、设置信息模板</h2><p>首先添加用户，用来收信息的微信号，扫二维码即可,微信号后面有用</p>
<p><img alt="1557989476566" data-src="http://img.mxranger.cn/1557989476566.png" class="lazyload"><br>添加模板，按照要求填写即可</p>
<p>注意：企业公众号有固定的信息模板，个人测试则自定义即可</p>
<p><img alt="1557989560258" data-src="http://img.mxranger.cn/1557989560258.png" class="lazyload"></p>
<p>添加完成</p>
<p><img alt="1557989621986" data-src="http://img.mxranger.cn/1557989621986.png" class="lazyload"></p>
<h2 id="4、发送模板信息"><a href="#4、发送模板信息" class="headerlink" title="4、发送模板信息"></a>4、发送模板信息</h2><blockquote>
<p>官网教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433751277" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433751277</a></p>
<p><img alt="1557989712618" data-src="http://img.mxranger.cn/1557989712618.png" class="lazyload"></p>
</blockquote>
<p>代码如下：</p>
<blockquote>
<p> 解释：</p>
<pre><code>touser : 是扫二维码后生成的微信号id

template_id ：创建模板后的模板id

data：模板内容一一对应的数据，value是值，color为颜色字体</code></pre></blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url1 = <span class="string">"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="</span> + access_token</span><br><span class="line"></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">"touser"</span>:<span class="string">"xxxxxxxxxxxxxxxxxxxx"</span>, <span class="comment"># 接收信息的用户id</span></span><br><span class="line">        <span class="string">"template_id"</span>:<span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>, <span class="comment">#模板id</span></span><br><span class="line">        <span class="string">"topcolor"</span>:<span class="string">"#FF0000"</span>,</span><br><span class="line">        <span class="string">"data"</span>:&#123;</span><br><span class="line">                <span class="string">"first"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:<span class="string">"服务器正常,爬虫数据已更新"</span>,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#ff0000"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"time"</span>: &#123; </span><br><span class="line">                    <span class="string">"value"</span>:time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time())),</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#173177"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"content"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:con,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#173177"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"remark"</span>:&#123;</span><br><span class="line">                    <span class="string">"value"</span>:<span class="string">"稳定运行"</span>,</span><br><span class="line">                    <span class="string">"color"</span>:<span class="string">"#ff0000"</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res1 = requests.post(url=url1,data=json.dumps(param))</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img alt="微信图片编辑_20190516150303" data-src="http://img.mxranger.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20190516150303.jpg" class="lazyload"></p>
<p>推荐一家消息推送的网站，叫Server酱，使用简单方便</p>
<p><a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">http://sc.ftqq.com/3.version</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用教程</title>
    <url>/2019/11/17/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、docker"><a href="#一、docker" class="headerlink" title="一、docker"></a>一、docker</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><h3 id="1、什么是Dokcer"><a href="#1、什么是Dokcer" class="headerlink" title="1、什么是Dokcer"></a>1、什么是Dokcer</h3><pre><code>百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口；
使用go语言编写，在LCX（linux容器）基础上进行的封装
简单来说：
1）就是可以快速部署启动应用
2）实现虚拟化，完整资源隔离
3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用）</code></pre><h3 id="2、为什么要用"><a href="#2、为什么要用" class="headerlink" title="2、为什么要用"></a>2、为什么要用</h3><p>1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就可以直接启动运行   </p>
<p>2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动</p>
<p>3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用</p>
<p>4、更好的资源隔离和共享</p>
<p>一句话：开箱即用，快速部署，可移植性强，环境隔离</p>
<h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="1、linux安装"><a href="#1、linux安装" class="headerlink" title="1、linux安装"></a>1、linux安装</h3><p><strong>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</strong> </p>
<p>1、通过<strong>uname -r</strong>命令查看你当前的内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>2、使用 <code>root</code> 权限登录 Centos。确保 yum 包更新到最新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<p>3、卸载旧版本(如果安装过旧版本的话)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>

<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>5、设置yum源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>

<p>7、安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce #repo中默认只开启stable仓库</span><br></pre></td></tr></table></figure>

<p>8、启动并加入开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><img alt="1557193586913" data-src="http://img.mxranger.cn/docker/img/1557193586913.png" class="lazyload"></p>
<p><code>lsb_release -a</code>命令查看linux版本</p>
<p><img alt="1557133258261" data-src="http://img.mxranger.cn/docker/img/1557133258261.png" class="lazyload"></p>
<h3 id="2、win10安装"><a href="#2、win10安装" class="headerlink" title="2、win10安装"></a>2、win10安装</h3><h4 id="1、去官网注册账号，点击"><a href="#1、去官网注册账号，点击" class="headerlink" title="1、去官网注册账号，点击"></a>1、去官网注册账号，点击</h4><p><img alt="1557649468894" data-src="http://img.mxranger.cn/docker/img/1557649468894.png" class="lazyload"></p>
<p><img alt="1557649485009" data-src="http://img.mxranger.cn/docker/img/1557649485009.png" class="lazyload"></p>
<p>安装完成</p>
<p><img alt="QQ图片20180227225058.png" data-src="http://img.mxranger.cn/docker/img/201802284475_4291.png" class="lazyload"></p>
<p>单击Close and log out，会自动注销当前用户</p>
<h4 id="2、打开docker"><a href="#2、打开docker" class="headerlink" title="2、打开docker"></a>2、打开docker</h4><p>桌面打开docker，如果系统没有启动hyper-v的话，会提示你启动，点击ok启动。这个时候系统可能会重启安装hyper-v。等它重启完毕后，在桌面的右下角就能看到docker的图标，说明docker开始运行了。</p>
<p>[<img alt="windows10上安装docker" data-src="http://img.mxranger.cn/docker/img/6159252dd42a2834b433c56656b5c9ea14cebfc2.jpg" class="lazyload"></p>
<p><img alt="1557649614054" data-src="http://img.mxranger.cn/docker/img/1557649614054.png" class="lazyload"></p>
<h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p>cmd命令输入<code>docker version</code></p>
<p><img alt="1557649657623" data-src="http://img.mxranger.cn/docker/img/1557649657623.png" class="lazyload"></p>
<p>则安装完成</p>
<h3 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h3><p>由于Vmware和docker不能共用，当使用vmware时需要关闭Hyper-V，否则报错</p>
<p><img alt="vmware 报错" data-src="http://img.mxranger.cn/docker/img/Snipaste_2018-06-08_21-50-16.png" class="lazyload"></p>
<p>控制面板-&gt;程序-&gt;程序和功能-&gt;启用或关闭 Windows 功能</p>
<p><img alt="start Hyper-V" data-src="http://img.mxranger.cn/docker/img/markdown-img-paste-20180611095532509.png" class="lazyload"></p>
<p><strong>只能二选一</strong></p>
<h2 id="3、概念"><a href="#3、概念" class="headerlink" title="3、概念"></a>3、概念</h2><p>1、Docker 镜像 - Docker images：<br>容器运行时的只读模板，操作系统+软件运行环境+用户程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Docker 容器 - Docker containers：<br>容器包含了某个应用运行所需要的全部环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user = new User()</span><br></pre></td></tr></table></figure>
<p>3、Docker 仓库 - Docker registeries：<br>用来保存镜像，有公有和私有仓库，好比Maven的中央仓库和本地私服</p>
<p>镜像仓库：    </p>
<p>（参考）配置国内镜像仓库：<a href="https://blog.csdn.net/zzy1078689276/article/details/77371782" target="_blank" rel="noopener">https://blog.csdn.net/zzy1078689276/article/details/77371782</a></p>
<p>对比面向对象的方式<br>Dokcer 里面的镜像 : Java里面的类 Class<br>Docker 里面的容器 : Java里面的对象 Object<br>通过类创建对象，通过镜像创建容器</p>
<h2 id="4、docker常见命令"><a href="#4、docker常见命令" class="headerlink" title="4、docker常见命令"></a>4、docker常见命令</h2><p>常用命令（安装部署好Dokcer后，执行的命令是docker开头）,xxx是镜像名称</p>
<pre><code>搜索镜像：docker search xxx

列出当前系统存在的镜像：docker images

拉取镜像：docker pull xxx
xxx是具体某个镜像名称(格式 REPOSITORY:TAG)
REPOSITORY：表示镜像的仓库源,TAG：镜像的标签

运行一个容器：docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management
docker run - 运行一个容器
-d 后台运行
-p 端口映射
rabbitmq:management  (格式 REPOSITORY:TAG)，如果不指定tag，默认使用最新的
--name &quot;xxx&quot;

列举当前运行的容器：docker ps

检查容器内部信息：docker inspect 容器名称

删除镜像：docker rmi IMAGE_NAME
强制移除镜像不管是否有容器使用该镜像 增加 -f 参数，

停止某个容器：docker stop 容器名称/容器id

启动某个容器：docker start 容器名称/容器id

移除某个容器： docker rm 容器名称 （容器必须是停止状态）</code></pre><h3 id="安装rabbitmq镜像"><a href="#安装rabbitmq镜像" class="headerlink" title="安装rabbitmq镜像"></a>安装rabbitmq镜像</h3><p>查看镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>从仓库中拉取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>查看已安装的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img alt="1557193935767" data-src="http://img.mxranger.cn/docker/img/1557193935767.png" class="lazyload"></p>
<p>运行rabbitmq</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>查看运行的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img alt="1557193914859" data-src="http://img.mxranger.cn/docker/img/1557193914859.png" class="lazyload"></p>
<p>防火墙打开15672端口</p>
<p>RabbitMQ默认创建了一个 guest 用户，密码也是 guest, 如果访问不了记得查看防火墙，端口或者云服务器的安全组<br>          管理后台：<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></p>
<p><img alt="1557194025594" data-src="http://img.mxranger.cn/docker/img/1557194025594.png" class="lazyload"></p>
<p>停止工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称/容器id</span><br></pre></td></tr></table></figure>



<p>其他命令文档：<br>            <a href="https://blog.csdn.net/permike/article/details/51879578" target="_blank" rel="noopener">https://blog.csdn.net/permike/article/details/51879578</a></p>
<h3 id="安装nginx镜像"><a href="#安装nginx镜像" class="headerlink" title="安装nginx镜像"></a>安装nginx镜像</h3><p>1、获取镜像 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run (首先会从本地找镜像，如果有则直接启动，没有的话，从镜像仓库拉起，再启动)</span><br><span class="line"></span><br><span class="line">docker search nignx</span><br></pre></td></tr></table></figure>

<p>2、列举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>3、拉取</p>
<p>若不加-tag 则下载最新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nignx</span><br></pre></td></tr></table></figure>
<p>4、启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name &quot;xdclass_nginx&quot; -p 8088:80 nginx</span><br><span class="line">docker run -d --name &quot;xdclass_nginx2&quot; -p 8089:80 nginx</span><br><span class="line">docker run -d --name &quot;xdclass_nginx3&quot; -p 8090:80 nginx</span><br></pre></td></tr></table></figure>
<p>5、访问<br>如果是阿里云服务，记得配置安全组，腾讯云也需要配置，这个就是一个防火墙</p>
<p><img alt="1557306207106" data-src="http://img.mxranger.cn/docker/img/1557306207106.png" class="lazyload"></p>
<h3 id="安装redis镜像"><a href="#安装redis镜像" class="headerlink" title="安装redis镜像"></a>安装redis镜像</h3><p>1、搜索镜像<br><code>docker search redis</code></p>
<p>2、拉取<br><code>docker pull docker.io/redis</code></p>
<p>3、启动<br><code>docker run --name &quot;xd_redis&quot; -p 6379:6379 -d [IMAGE ID]</code><br>参考：<br><code>docker run --name &quot;xd_redis&quot; -p 6379:6379 -d [IMAGE ID] --requirepass &quot;123456&quot; -v $PWD/data:/data</code></p>
<p><code>--requirepass</code>设置密码        <code>-v</code> 本机路径:容器路径</p>
<p>4、访问redis容器里面，进行操作<br><code>docker exec -it bb5b092b5483 redis-cli</code></p>
<p><img alt="1557660802359" data-src="http://img.mxranger.cn/docker/img/1557660802359.png" class="lazyload"></p>
<p><img alt="1557660925504" data-src="http://img.mxranger.cn/docker/img/1557660925504.png" class="lazyload"></p>
<p>redis镜像配置成功</p>
<h2 id="5、镜像仓库"><a href="#5、镜像仓库" class="headerlink" title="5、镜像仓库"></a>5、镜像仓库</h2><h3 id="官方公共镜像仓库和私有镜像仓库"><a href="#官方公共镜像仓库和私有镜像仓库" class="headerlink" title="官方公共镜像仓库和私有镜像仓库"></a>官方公共镜像仓库和私有镜像仓库</h3><p>1、公共镜像仓库：<br>        官方：<a href="https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的" target="_blank" rel="noopener">https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的</a><br>        非官方：其他组织或者公司开发的镜像，供大家免费试用</p>
<p>2、私有镜像仓库：<br>        用于存放公司内部的镜像，不提供给外部试用； </p>
<pre><code>SpringCloud 开发了一个支付系统 -》做成一个镜像 （操作系统+软件运行环境+用户程序）</code></pre><p><img alt="WechatIMG1" data-src="http://img.mxranger.cn/docker/img/WechatIMG1.png" class="lazyload"></p>
<h2 id="6、镜像仓库配置"><a href="#6、镜像仓库配置" class="headerlink" title="6、镜像仓库配置"></a>6、镜像仓库配置</h2><p>使用自己的镜像仓库</p>
<p>1、点击容器镜像服务，需要设置密码</p>
<p><img alt="1557471756133" data-src="http://img.mxranger.cn/docker/img/1557471756133.png" class="lazyload"></p>
<p>2、创建镜像仓库</p>
<p><img alt="1557472324271" data-src="http://img.mxranger.cn/docker/img/1557472324271.png" class="lazyload"></p>
<p>代码源：选择本地仓库即可</p>
<p>3、管理</p>
<p><img alt="1557472406587" data-src="http://img.mxranger.cn/docker/img/1557472406587.png" class="lazyload"></p>
<p>4、根据所给命令进行pull和push</p>
<p><img alt="1557472829459" data-src="http://img.mxranger.cn/docker/img/1557472829459.png" class="lazyload"></p>
<h2 id="7、推送自己的镜像"><a href="#7、推送自己的镜像" class="headerlink" title="7、推送自己的镜像"></a>7、推送自己的镜像</h2><p>1、登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>2、推送本地镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:[镜像版本号]</span><br><span class="line"></span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:[镜像版本号]</span><br></pre></td></tr></table></figure>



<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>将之前下载的rabbitmq镜像推送到自己的镜像仓库</p>
<p><img alt="1557473073919" data-src="http://img.mxranger.cn/docker/img/1557473073919.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录	输入密码</span><br><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com  </span><br><span class="line"></span><br><span class="line">#推送</span><br><span class="line">docker tag ac759a4f2d38 registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br><span class="line"></span><br><span class="line">#push</span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br></pre></td></tr></table></figure>

<p>推送中：</p>
<p><img alt="1557473325362" data-src="http://img.mxranger.cn/docker/img/1557473325362.png" class="lazyload"></p>
<p>推送完，镜像推送成功</p>
<p><img alt="1557475433518" data-src="http://img.mxranger.cn/docker/img/1557475433518.png" class="lazyload"></p>
<h2 id="8、拉取自己仓库的镜像"><a href="#8、拉取自己仓库的镜像" class="headerlink" title="8、拉取自己仓库的镜像"></a>8、拉取自己仓库的镜像</h2><p>线上服务器拉取镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com </span><br><span class="line"></span><br><span class="line">docker pull registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:mxranger_rabbitmq</span><br><span class="line"></span><br><span class="line">#启动容器</span><br><span class="line">docker run -d --name &quot;mxranger_rabbitmq&quot; -p 15672:15672 ac759a4f2d38</span><br></pre></td></tr></table></figure>

<p><img alt="1557536682388" data-src="http://img.mxranger.cn/docker/img/1557536682388.png" class="lazyload"></p>
<h2 id="9、springboot项目打包docker镜像"><a href="#9、springboot项目打包docker镜像" class="headerlink" title="9、springboot项目打包docker镜像"></a>9、springboot项目打包docker镜像</h2><blockquote>
<p>简介:使用Docker的maven插件，构建springboot应用<br>官方文档：<a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot-docker/</a></p>
</blockquote>
<h3 id="1、简单编写springboot程序"><a href="#1、简单编写springboot程序" class="headerlink" title="1、简单编写springboot程序"></a>1、简单编写springboot程序</h3><p>只添加了web依赖，建一个controller的方法做测试用</p>
<p><img alt="1557650702452" data-src="http://img.mxranger.cn/docker/img/1557650702452.png" class="lazyload"></p>
<h3 id="2、pom-xml添加配置"><a href="#2、pom-xml添加配置" class="headerlink" title="2、pom.xml添加配置"></a>2、pom.xml添加配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>mxranger<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>docker-demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置讲解:</strong><br>        Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。<br><code>${project.build.finalName}</code> 产出物名称，缺省为<code>${project.artifactId}-${project.version}</code></p>
<h3 id="3、创建Dockerfile"><a href="#3、创建Dockerfile" class="headerlink" title="3、创建Dockerfile"></a>3、创建Dockerfile</h3><pre><code>创建Dockerfile在项目根目录（也可以修改为src/main/docker/Dockerfile,如果修则需要制定路径）
Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ARG JAR_FILE</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">ENTRYPOINT ["java","-jar","/app.jar"]</span><br></pre></td></tr></table></figure>

<p><img alt="1557647182362" data-src="http://img.mxranger.cn/docker/img/1557647182362.png" class="lazyload"></p>
<p><strong>参数讲解：</strong><br>【1】<code>FROM &lt;image&gt;:&lt;tag&gt;</code>需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令<br>【2】<code>VOLUME</code>  配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录<br>【3】<code>ARG</code>  设置编译镜像时加入的参数， ENV 是设置容器的环境变量<br>【4】<code>COPY</code> : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点<br>【5】<code>ENTRYPOINT</code> 容器启动时执行的命令<br>【6】<code>EXPOSE 8080</code> 暴露镜像端口</p>
<h3 id="4、构建镜像"><a href="#4、构建镜像" class="headerlink" title="4、构建镜像"></a>4、构建镜像</h3><p>构建前windows10必须安装docker [安装教程](# 2、win10安装)</p>
<p>在idea <code>Terminal</code>的当前项目根目录下执行命令<code>mvn install dockerfile:build</code></p>
<p><img alt="1557649939527" data-src="http://img.mxranger.cn/docker/img/1557649939527.png" class="lazyload"></p>
<p>构建完成后</p>
<p><img alt="1557649981791" data-src="http://img.mxranger.cn/docker/img/1557649981791.png" class="lazyload"></p>
<p>当前电脑中docker镜像</p>
<p><img alt="1557649998263" data-src="http://img.mxranger.cn/docker/img/1557649998263.png" class="lazyload"></p>
<h3 id="5、本地测试"><a href="#5、本地测试" class="headerlink" title="5、本地测试"></a>5、本地测试</h3><p>cmd执行命令<code>docker run -d --name demo -p 8080:8080 [IMAGES ID]</code></p>
<p>测试成功</p>
<p><img alt="1557650596662" data-src="http://img.mxranger.cn/docker/img/1557650596662.png" class="lazyload"></p>
<h3 id="6、推送到阿里云镜像服务器"><a href="#6、推送到阿里云镜像服务器" class="headerlink" title="6、推送到阿里云镜像服务器"></a>6、推送到阿里云镜像服务器</h3><p>步骤同[推送自己的镜像](# 7、推送自己的镜像)一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">登录阿里云</span></span><br><span class="line">docker login --username=墨·修 registry.cn-shanghai.aliyuncs.com</span><br><span class="line"><span class="meta">#</span><span class="bash">打标签</span></span><br><span class="line">docker tag d5267a28accd registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</span><br><span class="line"><span class="meta">#</span><span class="bash">push 推送</span></span><br><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</span><br></pre></td></tr></table></figure>
<p>推送成功<br><img alt="1557652237001" data-src="http://img.mxranger.cn/docker/img/1557652237001.png" class="lazyload"></p>
<p>已经推送阿里云镜像服务器<br><img alt="1557652190008" data-src="http://img.mxranger.cn/docker/img/1557652190008.png" class="lazyload"></p>
<h3 id="7、拉取镜像"><a href="#7、拉取镜像" class="headerlink" title="7、拉取镜像"></a>7、拉取镜像</h3><p>拉取镜像到购买的服务器，同[拉取镜像](# 8、拉取自己仓库的镜像)一样</p>
<p><code>docker pull registry.cn-shanghai.aliyuncs.com/mxranger/mxranger:docker-demo</code></p>
<p><img alt="1557652303752" data-src="http://img.mxranger.cn/docker/img/1557652303752.png" class="lazyload"></p>
<h3 id="8、启动"><a href="#8、启动" class="headerlink" title="8、启动"></a>8、启动</h3><p><img alt="1557652477807" data-src="http://img.mxranger.cn/docker/img/1557652477807.png" class="lazyload"></p>
<p>启动命令<code>docker run -d --name docker_demo -p 8080:8080  d5267a28accd</code></p>
<p>如图启动成功</p>
<p><img alt="1557652443639" data-src="http://img.mxranger.cn/docker/img/1557652443639.png" class="lazyload"></p>
<h3 id="9、查看项目启动日志"><a href="#9、查看项目启动日志" class="headerlink" title="9、查看项目启动日志"></a>9、查看项目启动日志</h3><p><code>docker logs -f  [containerid]</code></p>
<p><img alt="1557652592105" data-src="http://img.mxranger.cn/docker/img/1557652592105.png" class="lazyload"></p>
<h3 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h3><p>1、localhost:2375 connection refused:connect</p>
<p><img alt="1557649151795" data-src="http://img.mxranger.cn/docker/img/1557649151795.png" class="lazyload"></p>
<p>解决办法：右击任务栏Docker图标 点击Settings 勾选红线部分 完美解决<br><img alt="img" data-src="http://img.mxranger.cn/docker/img/20180929181816965.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用七牛云搭建图床</title>
    <url>/2019/11/17/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="七牛云做图床"><a href="#七牛云做图床" class="headerlink" title="七牛云做图床"></a>七牛云做图床</h1><blockquote>
<p>由于微博图床有些已经不能用了，所有利用七牛云进行搭建自己的图床</p>
<p>本教程是需要绑定域名，所以没有域名的请去购买域名，否则七牛云的网址会时效</p>
</blockquote>
<h2 id="1、注册七牛云"><a href="#1、注册七牛云" class="headerlink" title="1、注册七牛云"></a>1、注册七牛云</h2><p>具体不多说，见<a href="https://www.qiniu.com/" target="_blank" rel="noopener">网站</a></p>
<h2 id="2、创建七牛云存储空间"><a href="#2、创建七牛云存储空间" class="headerlink" title="2、创建七牛云存储空间"></a>2、创建七牛云存储空间</h2><p>选择对象存储</p>
<p><img alt="1559206358837" data-src="http://img.mxranger.cn/qiniu/img/1559206358837.png" class="lazyload"></p>
<p>点击新建<br><img alt="1559206384676" data-src="http://img.mxranger.cn/qiniu/img/1559206384676.png" class="lazyload"></p>
<p>内容自行填写</p>
<h2 id="3、注册二级域名"><a href="#3、注册二级域名" class="headerlink" title="3、注册二级域名"></a>3、注册二级域名</h2><p>为你自己的域名注册二级域名(以阿里云域名管理为例，进行说明)</p>
<h3 id="1、点击解析"><a href="#1、点击解析" class="headerlink" title="1、点击解析"></a>1、点击解析</h3><p><img alt="1559206549792" data-src="http://img.mxranger.cn/qiniu/img/1559206549792.png" class="lazyload"></p>
<p>​     </p>
<h3 id="2、添加记录"><a href="#2、添加记录" class="headerlink" title="2、添加记录"></a>2、添加记录</h3><p><img alt="1559206701135" data-src="http://img.mxranger.cn/qiniu/img/1559206701135.png" class="lazyload">     </p>
<p>​     </p>
<h3 id="3、添加解析页面如下所示，页面中的值如下填写即可"><a href="#3、添加解析页面如下所示，页面中的值如下填写即可" class="headerlink" title="3、添加解析页面如下所示，页面中的值如下填写即可"></a>3、添加解析页面如下所示，页面中的值如下填写即可</h3><p><img alt="1559207616427" data-src="http://img.mxranger.cn/qiniu/img/1559207616427.png" class="lazyload"></p>
<h3 id="4、七牛云存储空间绑定二级域名"><a href="#4、七牛云存储空间绑定二级域名" class="headerlink" title="4、七牛云存储空间绑定二级域名"></a>4、七牛云存储空间绑定二级域名</h3><p>1、进入到七牛云存储空间创建完成后跳转的页面，绑定域名</p>
<p><img alt="1559207640036" data-src="http://img.mxranger.cn/qiniu/img/1559207640036.png" class="lazyload"></p>
<p>2、进入到七牛云存储空间创建完成后跳转的页面，绑定域名</p>
<p><img alt="1559207655749" data-src="http://img.mxranger.cn/qiniu/img/1559207655749.png" class="lazyload"></p>
<p>3、绑定成功后，跳转的页面上有CNAME值</p>
<p><img alt="1559207680812" data-src="http://img.mxranger.cn/qiniu/img/1559207680812.png" class="lazyload"></p>
<h3 id="5、为CNAME绑定二级域名"><a href="#5、为CNAME绑定二级域名" class="headerlink" title="5、为CNAME绑定二级域名"></a>5、为CNAME绑定二级域名</h3><p>1、回到阿里云域名解析的页面，修改绑定的值</p>
<p><img alt="1559207711657" data-src="http://img.mxranger.cn/qiniu/img/1559207711657.png" class="lazyload"></p>
<p>2、修改绑定的值为CNAM，替换<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p><img alt="1559207736061" data-src="http://img.mxranger.cn/qiniu/img/1559207736061.png" class="lazyload"></p>
<h2 id="4、审核结果"><a href="#4、审核结果" class="headerlink" title="4、审核结果"></a>4、审核结果</h2><p>至此七牛云绑定域名就行完成了，等待审核结果</p>
<p>收到邮件</p>
<p><img alt="1559207797499" data-src="http://img.mxranger.cn/qiniu/img/1559207797499.png" class="lazyload"></p>
<p><img alt="1559207849766" data-src="http://img.mxranger.cn/qiniu/img/1559207849766.png" class="lazyload"></p>
<h2 id="5、上传图片"><a href="#5、上传图片" class="headerlink" title="5、上传图片"></a>5、上传图片</h2><p>可以在内容管理里面上传图片了</p>
<p><img alt="1559208005620" data-src="http://img.mxranger.cn/qiniu/img/1559208005620.png" class="lazyload"></p>
<p>获取链接</p>
<p><img alt="1559208036593" data-src="http://img.mxranger.cn/qiniu/img/1559208036593.png" class="lazyload"></p>
<p>至此，搭建图床已完成</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题</title>
    <url>/2019/11/17/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1、重建二叉树"><a href="#1、重建二叉树" class="headerlink" title="1、重建二叉树"></a>1、重建二叉树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>树的结构采用用递归来实现。</p>
<p>递归的思想其实就是解决当前节点所需要做的事，然后将下一个节点扔进去做同一件事，所以我们可以当做就解决root应该做的事，赋值 + 对接左右子树</p>
<p>根据前序遍历的特点，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。</p>
<p>根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。</p>
<p>只需要将确定的左右子树安到root上即可。如果最后只有一个元素了，那么就要返回。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rebuildTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rebuildTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//[0]前序数组为空，直接结束</span></span><br><span class="line">        <span class="comment">//可能出现在子树中没有左/右子树的情况</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]判断下以防万一</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]只需要对当前父节点进行赋值即可</span></span><br><span class="line">        <span class="keyword">int</span> root_val = pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]当中序数组中只剩下一个，直接返回，已经是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(in.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[4]记录父节点的索引位置，用来为下面划分左子树和右子树</span></span><br><span class="line">        <span class="keyword">int</span> root_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root_val == in[i])&#123;<span class="comment">//找到根节点的位置，为了一分为二</span></span><br><span class="line">                root_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[5]将前序和中序分别拆分左子树区域和右子树区域</span></span><br><span class="line">        <span class="keyword">int</span>[] pre_left = Arrays.copyOfRange(pre, <span class="number">1</span>, root_index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] pre_right = Arrays.copyOfRange(pre, root_index+<span class="number">1</span>, pre.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] in_left = Arrays.copyOfRange(in, <span class="number">0</span>, root_index);</span><br><span class="line">        <span class="keyword">int</span>[] in_right = Arrays.copyOfRange(in, root_index+<span class="number">1</span>, in.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[6]接上去即可，递归</span></span><br><span class="line">        node.left = reConstructBinaryTree(pre_left, in_left);</span><br><span class="line">        node.right= reConstructBinaryTree(pre_right,in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历打印测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">        print(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">        print(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        print(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="构建二叉树" data-src="http://img.mxranger.cn/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="lazyload"></p>
<h2 id="2、包含min函数的栈"><a href="#2、包含min函数的栈" class="headerlink" title="2、包含min函数的栈"></a>2、包含min函数的栈</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>定义一个主栈A，一个辅助栈B，用来存放最小值<br>既然是最小值，肯定只有一个</p>
<p>主栈A入栈<br>[1]如果B中无值，便入栈其值<br>[2]如果B中有值，判断B栈顶的值和入栈A的值比较<br>        B栈顶的值 &gt; 入栈A的值,将其入辅助栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|  3  |     |     |</span><br><span class="line">|  2  |     |     |</span><br><span class="line">|  4  |     |  2  |</span><br><span class="line">|_ 3__|     |_ 3__|</span><br><span class="line"></span><br><span class="line">   A           B</span><br></pre></td></tr></table></figure>


<p>主栈A出栈<br>[1]判断A出栈值和B的栈顶值<br>        A出栈值 &gt; B的栈顶值,说明A中仍存在B栈顶值，A出栈即可<br>        A出栈值 = B的栈顶值,说明A中除了该值没有再小的值了（最小值只有一个，栈的特性），A和B都出栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|     |     |     |</span><br><span class="line">|  2  |╲   |     |</span><br><span class="line">|  4  |  ╲ |  2  |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B   </span><br><span class="line"></span><br><span class="line">2号出栈</span><br><span class="line"></span><br><span class="line">|     |     |     |</span><br><span class="line">|     |     |     |</span><br><span class="line">|  4  |     |     |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B </span><br><span class="line"></span><br><span class="line">4号出栈</span><br><span class="line">|     |     |     |</span><br><span class="line">|     |╲   |     |</span><br><span class="line">|     |  ╲ |     |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B </span><br><span class="line"></span><br><span class="line">0号入栈</span><br><span class="line">|     |     |     |</span><br><span class="line">|     |╲   |     |</span><br><span class="line">|  0  |  ╲ |  0  |</span><br><span class="line">|_ 3__|     |_ 3__|         </span><br><span class="line"></span><br><span class="line">   A           B</span><br></pre></td></tr></table></figure>

<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MinStack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//辅助栈，用来存放最小值、次小值、.....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.add(node);</span><br><span class="line">        push2(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(stack2.peek() == val)&#123;<span class="comment">//若主栈出栈了最小值 和辅助栈的栈顶一致，便一起出栈，辅助栈留下来前一次的次小值</span></span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = stack2.peek();</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push2</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123; <span class="comment">//栈顶为空放值</span></span><br><span class="line">            stack2.add(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack2.peek()&gt; node)&#123; <span class="comment">//栈顶的最小值若比入栈的还要小，便将其压栈</span></span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinStack stack = <span class="keyword">new</span> MinStack();</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.min();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        stack.min();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img alt="min函数栈" data-src="http://img.mxranger.cn/min%E5%87%BD%E6%95%B0%E6%A0%88.png" class="lazyload"></p>
<h2 id="3、数的子结构"><a href="#3、数的子结构" class="headerlink" title="3、数的子结构"></a>3、数的子结构</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用递归的方式遍历子树和主数<br>[1] 当主树和子树都为空  返回false</p>
<p>[2]当 当前主树根节点和子树根节点值相同，匹配开始</p>
<pre><code>[2.1] 如果子树遍历完了，说明匹配完成，返回true
[2.2] 如果主数遍历完，说明匹配不成功，返回false (你说你把主数都遍历完了，子树还没结束，还匹配啥)
[2.3] 如果匹配的过程中，有节点不一样，返回false
[2.4] 分别将主树的左子树 + 子树的左子树 进入[2]递归
[2.5] 分别将主树的右子树 + 子树的右子树 进入[2]递归</code></pre><p>[3] 若[2]中为匹配到，则需要将主树的根节点的左子树和右子树分别进入[1]中递归</p>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChildTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123; <span class="comment">//若两个数都为空，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123; </span><br><span class="line">            <span class="comment">//当 当前主树根节点和子树根节点值相同，</span></span><br><span class="line">            <span class="comment">//考虑为匹配开始，进入HasSubtree2函数</span></span><br><span class="line">            result =  HasSubtree2( root1, root2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="comment">//如果没匹配到，遍历主树的左子树去进行匹配</span></span><br><span class="line">            result = HasSubtree(root1.left,root2); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="comment">//如果没匹配到，遍历主树的右子树去进行匹配</span></span><br><span class="line">            result = HasSubtree(root1.right,root2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree2</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;<span class="comment">//遍历子树结束了，说明都匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;<span class="comment">//若主树遍历完，说明没匹配完整，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root1.val != root2.val) &#123;  <span class="comment">//在匹配的时候中途不一样，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]当前节点匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1.1]匹配左子树是否一致</span></span><br><span class="line">        <span class="keyword">boolean</span> result_left = HasSubtree2(root1.left, root2.left); </span><br><span class="line">        <span class="comment">//[1.2]匹配右子树是否一致</span></span><br><span class="line">        <span class="keyword">boolean</span> result_right = HasSubtree2(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result_left &amp;&amp; result_right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode t1 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t1.left = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t1.left.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        t1.left.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        t1.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode t2 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        t2.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        t2.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = HasSubtree(t1, t2);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img alt="主树找子树" data-src="http://img.mxranger.cn/%E4%B8%BB%E6%A0%91%E6%89%BE%E5%AD%90%E6%A0%91.png" class="lazyload"></p>
<h2 id="4、栈的压入、弹出序列"><a href="#4、栈的压入、弹出序列" class="headerlink" title="4、栈的压入、弹出序列"></a>4、栈的压入、弹出序列</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>链接：</p>
<p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>举例：</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JudgeStack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JudgeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//辅助栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            <span class="comment">//压栈</span></span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j&lt;popA.length &amp;&amp; stack.peek() == popA[j])&#123; <span class="comment">//判断popA的第一个值是不是栈顶的值，若是，则出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123; <span class="comment">//若辅助栈出栈完毕，说明包含popA的出栈顺序</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pushA = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] popA = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> result = IsPopOrder(pushA,popA);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、从上往下打印二叉树"><a href="#4、从上往下打印二叉树" class="headerlink" title="4、从上往下打印二叉树"></a>4、从上往下打印二叉树</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">二叉树如下：</span><br><span class="line">        1</span><br><span class="line">      /   \</span><br><span class="line">    2       3</span><br><span class="line">  /  \     /  \</span><br><span class="line"> 4    5   6    7</span><br></pre></td></tr></table></figure>

<p>创建一个ArrayList<br>想象成一个队列</p>
<p>[1] 输入1入队</p>
<pre><code>----------------------
                    1
----------------------</code></pre><p>[2]将1出队，并将他的左子树和右子树入队  </p>
<pre><code>将1的值添加到ArrayList中

            ----------------------
        1                  2    3 
            ----------------------</code></pre><p>[3]将2出队，并将他的左子树4和右子树5入队</p>
<pre><code>将2的值添加到ArrayList中
            ----------------------
1       2             3    4    5 
            ----------------------</code></pre><p>[4]将3出队，并将他的左子树4和右子树5入队</p>
<pre><code>将3的值添加到ArrayList中
            ----------------------
1   2   3         4    5   6    7
            ----------------------</code></pre><p>[5] 重复上述动作，4、5、6、7没有左子树和右子树，便以此出队</p>
<p>[6] 当队列为空时，结束</p>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PrintTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; trees = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">        trees.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(trees.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode temp = trees.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                trees.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                trees.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(temp.val+ <span class="string">" "</span>);</span><br><span class="line">            nums.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        PrintFromTopToBottom(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="5、顺序打印矩阵"><a href="#5、顺序打印矩阵" class="headerlink" title="5、顺序打印矩阵"></a>5、顺序打印矩阵</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>一圈一圈打印<br>确定好每圈的左上角位置，按照[0,0] [1,1] [2,2],取一个值即可</p>
<p>每走一圈，行和列都要缩小</p>
<p>打印顺序为：顶行 -&gt; 右列-&gt; 底行 -&gt; 左列</p>
<p>可以设置上下左右的变量锁定行列的打印范围，我没做</p>
<p>单数列、单数行需要进行判断是否需要打印底行 左列</p>
<h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * printMatrix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">printMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">//每圈开始</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一圈圈打印</span></span><br><span class="line">        <span class="keyword">while</span>(row &gt; start * <span class="number">2</span> &amp;&amp; column &gt; start * <span class="number">2</span>)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;column - start;i++)&#123;<span class="comment">//打印顶行</span></span><br><span class="line">                <span class="comment">//    System.out.print(matrix[start][i] + " ");</span></span><br><span class="line">                   nums.add(matrix[start][i]);</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>;i&lt;row - start;i++)&#123;<span class="comment">//打印右列</span></span><br><span class="line">                <span class="comment">// System.out.print(matrix[i][column - start - 1] + " ");</span></span><br><span class="line">                nums.add(matrix[i][column - start - <span class="number">1</span>]);</span><br><span class="line">               &#125;</span><br><span class="line">            </span><br><span class="line">               <span class="keyword">if</span>(start != (row-start-<span class="number">1</span>))&#123; <span class="comment">//若为单行，则无需打印</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> i = column - start - <span class="number">2</span>;i&gt;=start;i--)&#123;<span class="comment">//打印底行</span></span><br><span class="line">                       <span class="comment">// System.out.print(matrix[row-start-1][i] + " ");</span></span><br><span class="line">                       nums.add(matrix[row-start-<span class="number">1</span>][i]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">                </span><br><span class="line">               <span class="keyword">if</span>(start != (column-start-<span class="number">1</span>))&#123;<span class="comment">//若为单列，则无需打印</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> i= row - start - <span class="number">2</span>;i&gt;=start+<span class="number">1</span> ;i--)&#123;<span class="comment">//打印左列</span></span><br><span class="line">                       <span class="comment">// System.out.print(matrix[i][start] + " ");</span></span><br><span class="line">                       nums.add(matrix[i][start]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">               start++;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix2 = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix3 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix4 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>&#125;&#125;;</span><br><span class="line">                        </span><br><span class="line">        ArrayList&lt;Integer&gt; nums = printMatrix(matrix);</span><br><span class="line">        </span><br><span class="line">        nums.forEach((e)-&gt;&#123;</span><br><span class="line">          System.out.print(e + <span class="string">" "</span>);  </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6、平衡二叉树"><a href="#6、平衡二叉树" class="headerlink" title="6、平衡二叉树"></a>6、平衡二叉树</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<h3 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h3><p>[1]求左子树和右子树的深度</p>
<p>[2]平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</p>
<h3 id="完整代码1"><a href="#完整代码1" class="headerlink" title="完整代码1"></a>完整代码1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; <span class="comment">//当前节点为空，情况：没有子节点或者空树    返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_depth = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth = treeDepth(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：</span></span><br><span class="line">        <span class="comment">//它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left_depth - right_depth) &lt;=<span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; <span class="comment">//当前节点为空，情况：没有子节点或者空树    返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_depth = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth = treeDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树 / 右子树 的深度 + 当前节点的深度1</span></span><br><span class="line">        <span class="keyword">return</span> left_depth &gt; right_depth ? left_depth+<span class="number">1</span> : right_depth+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h3><p>[1] 直接在求左右子树的深度时，进行深度之差判断，不平衡直接返回，剪枝效果</p>
<h3 id="完整代码2"><a href="#完整代码2" class="headerlink" title="完整代码2"></a>完整代码2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>'my-first-blog'</title>
    <url>/2019/11/16/my-first-blog/</url>
    <content><![CDATA[<p> # 前言 </p>
<p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快； </li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； </li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； </li>
</ol>
<a id="more"></a> 


<ol start="4">
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5. 博客内容可以轻松打包、转移、发布到其它平台； 6. 等等； </li>
</ol>
<p><img alt="123" data-src="/images/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94.png" class="lazyload"></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
